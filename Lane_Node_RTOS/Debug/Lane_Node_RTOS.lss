
Lane_Node_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000067b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000013c  00800060  000067b0  00006844  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000540  0080019c  0080019c  00006980  2**0
                  ALLOC
  3 .stab         00009444  00000000  00000000  00006980  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000049fc  00000000  00000000  0000fdc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  000147c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001b6  00000000  00000000  00014920  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f0d  00000000  00000000  00014ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010d2  00000000  00000000  000169e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001030  00000000  00000000  00017ab5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00018ae8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002e6  00000000  00000000  00018c68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000008f6  00000000  00000000  00018f4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00019844  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 8b 0b 	jmp	0x1716	; 0x1716 <__vector_1>
       8:	0c 94 be 0b 	jmp	0x177c	; 0x177c <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 2b 1f 	jmp	0x3e56	; 0x3e56 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__vector_10>
      2c:	0c 94 b7 06 	jmp	0xd6e	; 0xd6e <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 eb       	ldi	r30, 0xB0	; 176
      68:	f7 e6       	ldi	r31, 0x67	; 103
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3d       	cpi	r26, 0xDC	; 220
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ad 32 	call	0x655a	; 0x655a <main>
      8a:	0c 94 d6 33 	jmp	0x67ac	; 0x67ac <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 96 33 	jmp	0x672c	; 0x672c <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ac e8       	ldi	r26, 0x8C	; 140
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 b2 33 	jmp	0x6764	; 0x6764 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 a2 33 	jmp	0x6744	; 0x6744 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 11 05 	call	0xa22	; 0xa22 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 be 33 	jmp	0x677c	; 0x677c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 a2 33 	jmp	0x6744	; 0x6744 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 11 05 	call	0xa22	; 0xa22 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 be 33 	jmp	0x677c	; 0x677c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 96 33 	jmp	0x672c	; 0x672c <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8c e8       	ldi	r24, 0x8C	; 140
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 11 05 	call	0xa22	; 0xa22 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 b2 33 	jmp	0x6764	; 0x6764 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 9e 33 	jmp	0x673c	; 0x673c <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6c e8       	ldi	r22, 0x8C	; 140
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 11 05 	call	0xa22	; 0xa22 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 ba 33 	jmp	0x6774	; 0x6774 <__epilogue_restores__+0x10>

0000078a <__gesf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 a2 33 	jmp	0x6744	; 0x6744 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gesf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gesf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 5e 06 	call	0xcbc	; 0xcbc <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gesf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 be 33 	jmp	0x677c	; 0x677c <__epilogue_restores__+0x18>

000007ea <__fixsfsi>:
     7ea:	ac e0       	ldi	r26, 0x0C	; 12
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 a6 33 	jmp	0x674c	; 0x674c <__prologue_saves__+0x20>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	be 01       	movw	r22, r28
     804:	6b 5f       	subi	r22, 0xFB	; 251
     806:	7f 4f       	sbci	r23, 0xFF	; 255
     808:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__unpack_f>
     80c:	8d 81       	ldd	r24, Y+5	; 0x05
     80e:	82 30       	cpi	r24, 0x02	; 2
     810:	61 f1       	breq	.+88     	; 0x86a <__stack+0xb>
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	50 f1       	brcs	.+84     	; 0x86a <__stack+0xb>
     816:	84 30       	cpi	r24, 0x04	; 4
     818:	21 f4       	brne	.+8      	; 0x822 <__fixsfsi+0x38>
     81a:	8e 81       	ldd	r24, Y+6	; 0x06
     81c:	88 23       	and	r24, r24
     81e:	51 f1       	breq	.+84     	; 0x874 <__stack+0x15>
     820:	2e c0       	rjmp	.+92     	; 0x87e <__stack+0x1f>
     822:	2f 81       	ldd	r18, Y+7	; 0x07
     824:	38 85       	ldd	r19, Y+8	; 0x08
     826:	37 fd       	sbrc	r19, 7
     828:	20 c0       	rjmp	.+64     	; 0x86a <__stack+0xb>
     82a:	6e 81       	ldd	r22, Y+6	; 0x06
     82c:	2f 31       	cpi	r18, 0x1F	; 31
     82e:	31 05       	cpc	r19, r1
     830:	1c f0       	brlt	.+6      	; 0x838 <__fixsfsi+0x4e>
     832:	66 23       	and	r22, r22
     834:	f9 f0       	breq	.+62     	; 0x874 <__stack+0x15>
     836:	23 c0       	rjmp	.+70     	; 0x87e <__stack+0x1f>
     838:	8e e1       	ldi	r24, 0x1E	; 30
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	82 1b       	sub	r24, r18
     83e:	93 0b       	sbc	r25, r19
     840:	29 85       	ldd	r18, Y+9	; 0x09
     842:	3a 85       	ldd	r19, Y+10	; 0x0a
     844:	4b 85       	ldd	r20, Y+11	; 0x0b
     846:	5c 85       	ldd	r21, Y+12	; 0x0c
     848:	04 c0       	rjmp	.+8      	; 0x852 <__fixsfsi+0x68>
     84a:	56 95       	lsr	r21
     84c:	47 95       	ror	r20
     84e:	37 95       	ror	r19
     850:	27 95       	ror	r18
     852:	8a 95       	dec	r24
     854:	d2 f7       	brpl	.-12     	; 0x84a <__fixsfsi+0x60>
     856:	66 23       	and	r22, r22
     858:	b1 f0       	breq	.+44     	; 0x886 <__stack+0x27>
     85a:	50 95       	com	r21
     85c:	40 95       	com	r20
     85e:	30 95       	com	r19
     860:	21 95       	neg	r18
     862:	3f 4f       	sbci	r19, 0xFF	; 255
     864:	4f 4f       	sbci	r20, 0xFF	; 255
     866:	5f 4f       	sbci	r21, 0xFF	; 255
     868:	0e c0       	rjmp	.+28     	; 0x886 <__stack+0x27>
     86a:	20 e0       	ldi	r18, 0x00	; 0
     86c:	30 e0       	ldi	r19, 0x00	; 0
     86e:	40 e0       	ldi	r20, 0x00	; 0
     870:	50 e0       	ldi	r21, 0x00	; 0
     872:	09 c0       	rjmp	.+18     	; 0x886 <__stack+0x27>
     874:	2f ef       	ldi	r18, 0xFF	; 255
     876:	3f ef       	ldi	r19, 0xFF	; 255
     878:	4f ef       	ldi	r20, 0xFF	; 255
     87a:	5f e7       	ldi	r21, 0x7F	; 127
     87c:	04 c0       	rjmp	.+8      	; 0x886 <__stack+0x27>
     87e:	20 e0       	ldi	r18, 0x00	; 0
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	50 e8       	ldi	r21, 0x80	; 128
     886:	b9 01       	movw	r22, r18
     888:	ca 01       	movw	r24, r20
     88a:	2c 96       	adiw	r28, 0x0c	; 12
     88c:	e2 e0       	ldi	r30, 0x02	; 2
     88e:	0c 94 c2 33 	jmp	0x6784	; 0x6784 <__epilogue_restores__+0x20>

00000892 <__floatunsisf>:
     892:	a8 e0       	ldi	r26, 0x08	; 8
     894:	b0 e0       	ldi	r27, 0x00	; 0
     896:	ef e4       	ldi	r30, 0x4F	; 79
     898:	f4 e0       	ldi	r31, 0x04	; 4
     89a:	0c 94 9e 33 	jmp	0x673c	; 0x673c <__prologue_saves__+0x10>
     89e:	7b 01       	movw	r14, r22
     8a0:	8c 01       	movw	r16, r24
     8a2:	61 15       	cp	r22, r1
     8a4:	71 05       	cpc	r23, r1
     8a6:	81 05       	cpc	r24, r1
     8a8:	91 05       	cpc	r25, r1
     8aa:	19 f4       	brne	.+6      	; 0x8b2 <__floatunsisf+0x20>
     8ac:	82 e0       	ldi	r24, 0x02	; 2
     8ae:	89 83       	std	Y+1, r24	; 0x01
     8b0:	60 c0       	rjmp	.+192    	; 0x972 <__floatunsisf+0xe0>
     8b2:	83 e0       	ldi	r24, 0x03	; 3
     8b4:	89 83       	std	Y+1, r24	; 0x01
     8b6:	8e e1       	ldi	r24, 0x1E	; 30
     8b8:	c8 2e       	mov	r12, r24
     8ba:	d1 2c       	mov	r13, r1
     8bc:	dc 82       	std	Y+4, r13	; 0x04
     8be:	cb 82       	std	Y+3, r12	; 0x03
     8c0:	ed 82       	std	Y+5, r14	; 0x05
     8c2:	fe 82       	std	Y+6, r15	; 0x06
     8c4:	0f 83       	std	Y+7, r16	; 0x07
     8c6:	18 87       	std	Y+8, r17	; 0x08
     8c8:	c8 01       	movw	r24, r16
     8ca:	b7 01       	movw	r22, r14
     8cc:	0e 94 c2 04 	call	0x984	; 0x984 <__clzsi2>
     8d0:	fc 01       	movw	r30, r24
     8d2:	31 97       	sbiw	r30, 0x01	; 1
     8d4:	f7 ff       	sbrs	r31, 7
     8d6:	3b c0       	rjmp	.+118    	; 0x94e <__floatunsisf+0xbc>
     8d8:	22 27       	eor	r18, r18
     8da:	33 27       	eor	r19, r19
     8dc:	2e 1b       	sub	r18, r30
     8de:	3f 0b       	sbc	r19, r31
     8e0:	57 01       	movw	r10, r14
     8e2:	68 01       	movw	r12, r16
     8e4:	02 2e       	mov	r0, r18
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__floatunsisf+0x5e>
     8e8:	d6 94       	lsr	r13
     8ea:	c7 94       	ror	r12
     8ec:	b7 94       	ror	r11
     8ee:	a7 94       	ror	r10
     8f0:	0a 94       	dec	r0
     8f2:	d2 f7       	brpl	.-12     	; 0x8e8 <__floatunsisf+0x56>
     8f4:	40 e0       	ldi	r20, 0x00	; 0
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	a0 e0       	ldi	r26, 0x00	; 0
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	04 c0       	rjmp	.+8      	; 0x90e <__floatunsisf+0x7c>
     906:	88 0f       	add	r24, r24
     908:	99 1f       	adc	r25, r25
     90a:	aa 1f       	adc	r26, r26
     90c:	bb 1f       	adc	r27, r27
     90e:	2a 95       	dec	r18
     910:	d2 f7       	brpl	.-12     	; 0x906 <__floatunsisf+0x74>
     912:	01 97       	sbiw	r24, 0x01	; 1
     914:	a1 09       	sbc	r26, r1
     916:	b1 09       	sbc	r27, r1
     918:	8e 21       	and	r24, r14
     91a:	9f 21       	and	r25, r15
     91c:	a0 23       	and	r26, r16
     91e:	b1 23       	and	r27, r17
     920:	00 97       	sbiw	r24, 0x00	; 0
     922:	a1 05       	cpc	r26, r1
     924:	b1 05       	cpc	r27, r1
     926:	21 f0       	breq	.+8      	; 0x930 <__floatunsisf+0x9e>
     928:	41 e0       	ldi	r20, 0x01	; 1
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	60 e0       	ldi	r22, 0x00	; 0
     92e:	70 e0       	ldi	r23, 0x00	; 0
     930:	4a 29       	or	r20, r10
     932:	5b 29       	or	r21, r11
     934:	6c 29       	or	r22, r12
     936:	7d 29       	or	r23, r13
     938:	4d 83       	std	Y+5, r20	; 0x05
     93a:	5e 83       	std	Y+6, r21	; 0x06
     93c:	6f 83       	std	Y+7, r22	; 0x07
     93e:	78 87       	std	Y+8, r23	; 0x08
     940:	8e e1       	ldi	r24, 0x1E	; 30
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	8e 1b       	sub	r24, r30
     946:	9f 0b       	sbc	r25, r31
     948:	9c 83       	std	Y+4, r25	; 0x04
     94a:	8b 83       	std	Y+3, r24	; 0x03
     94c:	12 c0       	rjmp	.+36     	; 0x972 <__floatunsisf+0xe0>
     94e:	30 97       	sbiw	r30, 0x00	; 0
     950:	81 f0       	breq	.+32     	; 0x972 <__floatunsisf+0xe0>
     952:	0e 2e       	mov	r0, r30
     954:	04 c0       	rjmp	.+8      	; 0x95e <__floatunsisf+0xcc>
     956:	ee 0c       	add	r14, r14
     958:	ff 1c       	adc	r15, r15
     95a:	00 1f       	adc	r16, r16
     95c:	11 1f       	adc	r17, r17
     95e:	0a 94       	dec	r0
     960:	d2 f7       	brpl	.-12     	; 0x956 <__floatunsisf+0xc4>
     962:	ed 82       	std	Y+5, r14	; 0x05
     964:	fe 82       	std	Y+6, r15	; 0x06
     966:	0f 83       	std	Y+7, r16	; 0x07
     968:	18 87       	std	Y+8, r17	; 0x08
     96a:	ce 1a       	sub	r12, r30
     96c:	df 0a       	sbc	r13, r31
     96e:	dc 82       	std	Y+4, r13	; 0x04
     970:	cb 82       	std	Y+3, r12	; 0x03
     972:	1a 82       	std	Y+2, r1	; 0x02
     974:	ce 01       	movw	r24, r28
     976:	01 96       	adiw	r24, 0x01	; 1
     978:	0e 94 11 05 	call	0xa22	; 0xa22 <__pack_f>
     97c:	28 96       	adiw	r28, 0x08	; 8
     97e:	ea e0       	ldi	r30, 0x0A	; 10
     980:	0c 94 ba 33 	jmp	0x6774	; 0x6774 <__epilogue_restores__+0x10>

00000984 <__clzsi2>:
     984:	ef 92       	push	r14
     986:	ff 92       	push	r15
     988:	0f 93       	push	r16
     98a:	1f 93       	push	r17
     98c:	7b 01       	movw	r14, r22
     98e:	8c 01       	movw	r16, r24
     990:	80 e0       	ldi	r24, 0x00	; 0
     992:	e8 16       	cp	r14, r24
     994:	80 e0       	ldi	r24, 0x00	; 0
     996:	f8 06       	cpc	r15, r24
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	08 07       	cpc	r16, r24
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	18 07       	cpc	r17, r24
     9a0:	88 f4       	brcc	.+34     	; 0x9c4 <__clzsi2+0x40>
     9a2:	8f ef       	ldi	r24, 0xFF	; 255
     9a4:	e8 16       	cp	r14, r24
     9a6:	f1 04       	cpc	r15, r1
     9a8:	01 05       	cpc	r16, r1
     9aa:	11 05       	cpc	r17, r1
     9ac:	31 f0       	breq	.+12     	; 0x9ba <__clzsi2+0x36>
     9ae:	28 f0       	brcs	.+10     	; 0x9ba <__clzsi2+0x36>
     9b0:	88 e0       	ldi	r24, 0x08	; 8
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	a0 e0       	ldi	r26, 0x00	; 0
     9b6:	b0 e0       	ldi	r27, 0x00	; 0
     9b8:	17 c0       	rjmp	.+46     	; 0x9e8 <__clzsi2+0x64>
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	a0 e0       	ldi	r26, 0x00	; 0
     9c0:	b0 e0       	ldi	r27, 0x00	; 0
     9c2:	12 c0       	rjmp	.+36     	; 0x9e8 <__clzsi2+0x64>
     9c4:	80 e0       	ldi	r24, 0x00	; 0
     9c6:	e8 16       	cp	r14, r24
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	f8 06       	cpc	r15, r24
     9cc:	80 e0       	ldi	r24, 0x00	; 0
     9ce:	08 07       	cpc	r16, r24
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	18 07       	cpc	r17, r24
     9d4:	28 f0       	brcs	.+10     	; 0x9e0 <__clzsi2+0x5c>
     9d6:	88 e1       	ldi	r24, 0x18	; 24
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	a0 e0       	ldi	r26, 0x00	; 0
     9dc:	b0 e0       	ldi	r27, 0x00	; 0
     9de:	04 c0       	rjmp	.+8      	; 0x9e8 <__clzsi2+0x64>
     9e0:	80 e1       	ldi	r24, 0x10	; 16
     9e2:	90 e0       	ldi	r25, 0x00	; 0
     9e4:	a0 e0       	ldi	r26, 0x00	; 0
     9e6:	b0 e0       	ldi	r27, 0x00	; 0
     9e8:	20 e2       	ldi	r18, 0x20	; 32
     9ea:	30 e0       	ldi	r19, 0x00	; 0
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	28 1b       	sub	r18, r24
     9f2:	39 0b       	sbc	r19, r25
     9f4:	4a 0b       	sbc	r20, r26
     9f6:	5b 0b       	sbc	r21, r27
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__clzsi2+0x7e>
     9fa:	16 95       	lsr	r17
     9fc:	07 95       	ror	r16
     9fe:	f7 94       	ror	r15
     a00:	e7 94       	ror	r14
     a02:	8a 95       	dec	r24
     a04:	d2 f7       	brpl	.-12     	; 0x9fa <__clzsi2+0x76>
     a06:	f7 01       	movw	r30, r14
     a08:	ec 56       	subi	r30, 0x6C	; 108
     a0a:	ff 4f       	sbci	r31, 0xFF	; 255
     a0c:	80 81       	ld	r24, Z
     a0e:	28 1b       	sub	r18, r24
     a10:	31 09       	sbc	r19, r1
     a12:	41 09       	sbc	r20, r1
     a14:	51 09       	sbc	r21, r1
     a16:	c9 01       	movw	r24, r18
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	ef 90       	pop	r14
     a20:	08 95       	ret

00000a22 <__pack_f>:
     a22:	df 92       	push	r13
     a24:	ef 92       	push	r14
     a26:	ff 92       	push	r15
     a28:	0f 93       	push	r16
     a2a:	1f 93       	push	r17
     a2c:	fc 01       	movw	r30, r24
     a2e:	e4 80       	ldd	r14, Z+4	; 0x04
     a30:	f5 80       	ldd	r15, Z+5	; 0x05
     a32:	06 81       	ldd	r16, Z+6	; 0x06
     a34:	17 81       	ldd	r17, Z+7	; 0x07
     a36:	d1 80       	ldd	r13, Z+1	; 0x01
     a38:	80 81       	ld	r24, Z
     a3a:	82 30       	cpi	r24, 0x02	; 2
     a3c:	48 f4       	brcc	.+18     	; 0xa50 <__pack_f+0x2e>
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	a0 e1       	ldi	r26, 0x10	; 16
     a44:	b0 e0       	ldi	r27, 0x00	; 0
     a46:	e8 2a       	or	r14, r24
     a48:	f9 2a       	or	r15, r25
     a4a:	0a 2b       	or	r16, r26
     a4c:	1b 2b       	or	r17, r27
     a4e:	a5 c0       	rjmp	.+330    	; 0xb9a <__pack_f+0x178>
     a50:	84 30       	cpi	r24, 0x04	; 4
     a52:	09 f4       	brne	.+2      	; 0xa56 <__pack_f+0x34>
     a54:	9f c0       	rjmp	.+318    	; 0xb94 <__pack_f+0x172>
     a56:	82 30       	cpi	r24, 0x02	; 2
     a58:	21 f4       	brne	.+8      	; 0xa62 <__pack_f+0x40>
     a5a:	ee 24       	eor	r14, r14
     a5c:	ff 24       	eor	r15, r15
     a5e:	87 01       	movw	r16, r14
     a60:	05 c0       	rjmp	.+10     	; 0xa6c <__pack_f+0x4a>
     a62:	e1 14       	cp	r14, r1
     a64:	f1 04       	cpc	r15, r1
     a66:	01 05       	cpc	r16, r1
     a68:	11 05       	cpc	r17, r1
     a6a:	19 f4       	brne	.+6      	; 0xa72 <__pack_f+0x50>
     a6c:	e0 e0       	ldi	r30, 0x00	; 0
     a6e:	f0 e0       	ldi	r31, 0x00	; 0
     a70:	96 c0       	rjmp	.+300    	; 0xb9e <__pack_f+0x17c>
     a72:	62 81       	ldd	r22, Z+2	; 0x02
     a74:	73 81       	ldd	r23, Z+3	; 0x03
     a76:	9f ef       	ldi	r25, 0xFF	; 255
     a78:	62 38       	cpi	r22, 0x82	; 130
     a7a:	79 07       	cpc	r23, r25
     a7c:	0c f0       	brlt	.+2      	; 0xa80 <__pack_f+0x5e>
     a7e:	5b c0       	rjmp	.+182    	; 0xb36 <__pack_f+0x114>
     a80:	22 e8       	ldi	r18, 0x82	; 130
     a82:	3f ef       	ldi	r19, 0xFF	; 255
     a84:	26 1b       	sub	r18, r22
     a86:	37 0b       	sbc	r19, r23
     a88:	2a 31       	cpi	r18, 0x1A	; 26
     a8a:	31 05       	cpc	r19, r1
     a8c:	2c f0       	brlt	.+10     	; 0xa98 <__pack_f+0x76>
     a8e:	20 e0       	ldi	r18, 0x00	; 0
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	40 e0       	ldi	r20, 0x00	; 0
     a94:	50 e0       	ldi	r21, 0x00	; 0
     a96:	2a c0       	rjmp	.+84     	; 0xaec <__pack_f+0xca>
     a98:	b8 01       	movw	r22, r16
     a9a:	a7 01       	movw	r20, r14
     a9c:	02 2e       	mov	r0, r18
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__pack_f+0x86>
     aa0:	76 95       	lsr	r23
     aa2:	67 95       	ror	r22
     aa4:	57 95       	ror	r21
     aa6:	47 95       	ror	r20
     aa8:	0a 94       	dec	r0
     aaa:	d2 f7       	brpl	.-12     	; 0xaa0 <__pack_f+0x7e>
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	a0 e0       	ldi	r26, 0x00	; 0
     ab2:	b0 e0       	ldi	r27, 0x00	; 0
     ab4:	04 c0       	rjmp	.+8      	; 0xabe <__pack_f+0x9c>
     ab6:	88 0f       	add	r24, r24
     ab8:	99 1f       	adc	r25, r25
     aba:	aa 1f       	adc	r26, r26
     abc:	bb 1f       	adc	r27, r27
     abe:	2a 95       	dec	r18
     ac0:	d2 f7       	brpl	.-12     	; 0xab6 <__pack_f+0x94>
     ac2:	01 97       	sbiw	r24, 0x01	; 1
     ac4:	a1 09       	sbc	r26, r1
     ac6:	b1 09       	sbc	r27, r1
     ac8:	8e 21       	and	r24, r14
     aca:	9f 21       	and	r25, r15
     acc:	a0 23       	and	r26, r16
     ace:	b1 23       	and	r27, r17
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	a1 05       	cpc	r26, r1
     ad4:	b1 05       	cpc	r27, r1
     ad6:	21 f0       	breq	.+8      	; 0xae0 <__pack_f+0xbe>
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	9a 01       	movw	r18, r20
     ae2:	ab 01       	movw	r20, r22
     ae4:	28 2b       	or	r18, r24
     ae6:	39 2b       	or	r19, r25
     ae8:	4a 2b       	or	r20, r26
     aea:	5b 2b       	or	r21, r27
     aec:	da 01       	movw	r26, r20
     aee:	c9 01       	movw	r24, r18
     af0:	8f 77       	andi	r24, 0x7F	; 127
     af2:	90 70       	andi	r25, 0x00	; 0
     af4:	a0 70       	andi	r26, 0x00	; 0
     af6:	b0 70       	andi	r27, 0x00	; 0
     af8:	80 34       	cpi	r24, 0x40	; 64
     afa:	91 05       	cpc	r25, r1
     afc:	a1 05       	cpc	r26, r1
     afe:	b1 05       	cpc	r27, r1
     b00:	39 f4       	brne	.+14     	; 0xb10 <__pack_f+0xee>
     b02:	27 ff       	sbrs	r18, 7
     b04:	09 c0       	rjmp	.+18     	; 0xb18 <__pack_f+0xf6>
     b06:	20 5c       	subi	r18, 0xC0	; 192
     b08:	3f 4f       	sbci	r19, 0xFF	; 255
     b0a:	4f 4f       	sbci	r20, 0xFF	; 255
     b0c:	5f 4f       	sbci	r21, 0xFF	; 255
     b0e:	04 c0       	rjmp	.+8      	; 0xb18 <__pack_f+0xf6>
     b10:	21 5c       	subi	r18, 0xC1	; 193
     b12:	3f 4f       	sbci	r19, 0xFF	; 255
     b14:	4f 4f       	sbci	r20, 0xFF	; 255
     b16:	5f 4f       	sbci	r21, 0xFF	; 255
     b18:	e0 e0       	ldi	r30, 0x00	; 0
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	20 30       	cpi	r18, 0x00	; 0
     b1e:	a0 e0       	ldi	r26, 0x00	; 0
     b20:	3a 07       	cpc	r19, r26
     b22:	a0 e0       	ldi	r26, 0x00	; 0
     b24:	4a 07       	cpc	r20, r26
     b26:	a0 e4       	ldi	r26, 0x40	; 64
     b28:	5a 07       	cpc	r21, r26
     b2a:	10 f0       	brcs	.+4      	; 0xb30 <__pack_f+0x10e>
     b2c:	e1 e0       	ldi	r30, 0x01	; 1
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	79 01       	movw	r14, r18
     b32:	8a 01       	movw	r16, r20
     b34:	27 c0       	rjmp	.+78     	; 0xb84 <__pack_f+0x162>
     b36:	60 38       	cpi	r22, 0x80	; 128
     b38:	71 05       	cpc	r23, r1
     b3a:	64 f5       	brge	.+88     	; 0xb94 <__pack_f+0x172>
     b3c:	fb 01       	movw	r30, r22
     b3e:	e1 58       	subi	r30, 0x81	; 129
     b40:	ff 4f       	sbci	r31, 0xFF	; 255
     b42:	d8 01       	movw	r26, r16
     b44:	c7 01       	movw	r24, r14
     b46:	8f 77       	andi	r24, 0x7F	; 127
     b48:	90 70       	andi	r25, 0x00	; 0
     b4a:	a0 70       	andi	r26, 0x00	; 0
     b4c:	b0 70       	andi	r27, 0x00	; 0
     b4e:	80 34       	cpi	r24, 0x40	; 64
     b50:	91 05       	cpc	r25, r1
     b52:	a1 05       	cpc	r26, r1
     b54:	b1 05       	cpc	r27, r1
     b56:	39 f4       	brne	.+14     	; 0xb66 <__pack_f+0x144>
     b58:	e7 fe       	sbrs	r14, 7
     b5a:	0d c0       	rjmp	.+26     	; 0xb76 <__pack_f+0x154>
     b5c:	80 e4       	ldi	r24, 0x40	; 64
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	04 c0       	rjmp	.+8      	; 0xb6e <__pack_f+0x14c>
     b66:	8f e3       	ldi	r24, 0x3F	; 63
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	a0 e0       	ldi	r26, 0x00	; 0
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e8 0e       	add	r14, r24
     b70:	f9 1e       	adc	r15, r25
     b72:	0a 1f       	adc	r16, r26
     b74:	1b 1f       	adc	r17, r27
     b76:	17 ff       	sbrs	r17, 7
     b78:	05 c0       	rjmp	.+10     	; 0xb84 <__pack_f+0x162>
     b7a:	16 95       	lsr	r17
     b7c:	07 95       	ror	r16
     b7e:	f7 94       	ror	r15
     b80:	e7 94       	ror	r14
     b82:	31 96       	adiw	r30, 0x01	; 1
     b84:	87 e0       	ldi	r24, 0x07	; 7
     b86:	16 95       	lsr	r17
     b88:	07 95       	ror	r16
     b8a:	f7 94       	ror	r15
     b8c:	e7 94       	ror	r14
     b8e:	8a 95       	dec	r24
     b90:	d1 f7       	brne	.-12     	; 0xb86 <__pack_f+0x164>
     b92:	05 c0       	rjmp	.+10     	; 0xb9e <__pack_f+0x17c>
     b94:	ee 24       	eor	r14, r14
     b96:	ff 24       	eor	r15, r15
     b98:	87 01       	movw	r16, r14
     b9a:	ef ef       	ldi	r30, 0xFF	; 255
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	6e 2f       	mov	r22, r30
     ba0:	67 95       	ror	r22
     ba2:	66 27       	eor	r22, r22
     ba4:	67 95       	ror	r22
     ba6:	90 2f       	mov	r25, r16
     ba8:	9f 77       	andi	r25, 0x7F	; 127
     baa:	d7 94       	ror	r13
     bac:	dd 24       	eor	r13, r13
     bae:	d7 94       	ror	r13
     bb0:	8e 2f       	mov	r24, r30
     bb2:	86 95       	lsr	r24
     bb4:	49 2f       	mov	r20, r25
     bb6:	46 2b       	or	r20, r22
     bb8:	58 2f       	mov	r21, r24
     bba:	5d 29       	or	r21, r13
     bbc:	b7 01       	movw	r22, r14
     bbe:	ca 01       	movw	r24, r20
     bc0:	1f 91       	pop	r17
     bc2:	0f 91       	pop	r16
     bc4:	ff 90       	pop	r15
     bc6:	ef 90       	pop	r14
     bc8:	df 90       	pop	r13
     bca:	08 95       	ret

00000bcc <__unpack_f>:
     bcc:	fc 01       	movw	r30, r24
     bce:	db 01       	movw	r26, r22
     bd0:	40 81       	ld	r20, Z
     bd2:	51 81       	ldd	r21, Z+1	; 0x01
     bd4:	22 81       	ldd	r18, Z+2	; 0x02
     bd6:	62 2f       	mov	r22, r18
     bd8:	6f 77       	andi	r22, 0x7F	; 127
     bda:	70 e0       	ldi	r23, 0x00	; 0
     bdc:	22 1f       	adc	r18, r18
     bde:	22 27       	eor	r18, r18
     be0:	22 1f       	adc	r18, r18
     be2:	93 81       	ldd	r25, Z+3	; 0x03
     be4:	89 2f       	mov	r24, r25
     be6:	88 0f       	add	r24, r24
     be8:	82 2b       	or	r24, r18
     bea:	28 2f       	mov	r18, r24
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	99 1f       	adc	r25, r25
     bf0:	99 27       	eor	r25, r25
     bf2:	99 1f       	adc	r25, r25
     bf4:	11 96       	adiw	r26, 0x01	; 1
     bf6:	9c 93       	st	X, r25
     bf8:	11 97       	sbiw	r26, 0x01	; 1
     bfa:	21 15       	cp	r18, r1
     bfc:	31 05       	cpc	r19, r1
     bfe:	a9 f5       	brne	.+106    	; 0xc6a <__unpack_f+0x9e>
     c00:	41 15       	cp	r20, r1
     c02:	51 05       	cpc	r21, r1
     c04:	61 05       	cpc	r22, r1
     c06:	71 05       	cpc	r23, r1
     c08:	11 f4       	brne	.+4      	; 0xc0e <__unpack_f+0x42>
     c0a:	82 e0       	ldi	r24, 0x02	; 2
     c0c:	37 c0       	rjmp	.+110    	; 0xc7c <__unpack_f+0xb0>
     c0e:	82 e8       	ldi	r24, 0x82	; 130
     c10:	9f ef       	ldi	r25, 0xFF	; 255
     c12:	13 96       	adiw	r26, 0x03	; 3
     c14:	9c 93       	st	X, r25
     c16:	8e 93       	st	-X, r24
     c18:	12 97       	sbiw	r26, 0x02	; 2
     c1a:	9a 01       	movw	r18, r20
     c1c:	ab 01       	movw	r20, r22
     c1e:	67 e0       	ldi	r22, 0x07	; 7
     c20:	22 0f       	add	r18, r18
     c22:	33 1f       	adc	r19, r19
     c24:	44 1f       	adc	r20, r20
     c26:	55 1f       	adc	r21, r21
     c28:	6a 95       	dec	r22
     c2a:	d1 f7       	brne	.-12     	; 0xc20 <__unpack_f+0x54>
     c2c:	83 e0       	ldi	r24, 0x03	; 3
     c2e:	8c 93       	st	X, r24
     c30:	0d c0       	rjmp	.+26     	; 0xc4c <__unpack_f+0x80>
     c32:	22 0f       	add	r18, r18
     c34:	33 1f       	adc	r19, r19
     c36:	44 1f       	adc	r20, r20
     c38:	55 1f       	adc	r21, r21
     c3a:	12 96       	adiw	r26, 0x02	; 2
     c3c:	8d 91       	ld	r24, X+
     c3e:	9c 91       	ld	r25, X
     c40:	13 97       	sbiw	r26, 0x03	; 3
     c42:	01 97       	sbiw	r24, 0x01	; 1
     c44:	13 96       	adiw	r26, 0x03	; 3
     c46:	9c 93       	st	X, r25
     c48:	8e 93       	st	-X, r24
     c4a:	12 97       	sbiw	r26, 0x02	; 2
     c4c:	20 30       	cpi	r18, 0x00	; 0
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	38 07       	cpc	r19, r24
     c52:	80 e0       	ldi	r24, 0x00	; 0
     c54:	48 07       	cpc	r20, r24
     c56:	80 e4       	ldi	r24, 0x40	; 64
     c58:	58 07       	cpc	r21, r24
     c5a:	58 f3       	brcs	.-42     	; 0xc32 <__unpack_f+0x66>
     c5c:	14 96       	adiw	r26, 0x04	; 4
     c5e:	2d 93       	st	X+, r18
     c60:	3d 93       	st	X+, r19
     c62:	4d 93       	st	X+, r20
     c64:	5c 93       	st	X, r21
     c66:	17 97       	sbiw	r26, 0x07	; 7
     c68:	08 95       	ret
     c6a:	2f 3f       	cpi	r18, 0xFF	; 255
     c6c:	31 05       	cpc	r19, r1
     c6e:	79 f4       	brne	.+30     	; 0xc8e <__unpack_f+0xc2>
     c70:	41 15       	cp	r20, r1
     c72:	51 05       	cpc	r21, r1
     c74:	61 05       	cpc	r22, r1
     c76:	71 05       	cpc	r23, r1
     c78:	19 f4       	brne	.+6      	; 0xc80 <__unpack_f+0xb4>
     c7a:	84 e0       	ldi	r24, 0x04	; 4
     c7c:	8c 93       	st	X, r24
     c7e:	08 95       	ret
     c80:	64 ff       	sbrs	r22, 4
     c82:	03 c0       	rjmp	.+6      	; 0xc8a <__unpack_f+0xbe>
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	8c 93       	st	X, r24
     c88:	12 c0       	rjmp	.+36     	; 0xcae <__unpack_f+0xe2>
     c8a:	1c 92       	st	X, r1
     c8c:	10 c0       	rjmp	.+32     	; 0xcae <__unpack_f+0xe2>
     c8e:	2f 57       	subi	r18, 0x7F	; 127
     c90:	30 40       	sbci	r19, 0x00	; 0
     c92:	13 96       	adiw	r26, 0x03	; 3
     c94:	3c 93       	st	X, r19
     c96:	2e 93       	st	-X, r18
     c98:	12 97       	sbiw	r26, 0x02	; 2
     c9a:	83 e0       	ldi	r24, 0x03	; 3
     c9c:	8c 93       	st	X, r24
     c9e:	87 e0       	ldi	r24, 0x07	; 7
     ca0:	44 0f       	add	r20, r20
     ca2:	55 1f       	adc	r21, r21
     ca4:	66 1f       	adc	r22, r22
     ca6:	77 1f       	adc	r23, r23
     ca8:	8a 95       	dec	r24
     caa:	d1 f7       	brne	.-12     	; 0xca0 <__unpack_f+0xd4>
     cac:	70 64       	ori	r23, 0x40	; 64
     cae:	14 96       	adiw	r26, 0x04	; 4
     cb0:	4d 93       	st	X+, r20
     cb2:	5d 93       	st	X+, r21
     cb4:	6d 93       	st	X+, r22
     cb6:	7c 93       	st	X, r23
     cb8:	17 97       	sbiw	r26, 0x07	; 7
     cba:	08 95       	ret

00000cbc <__fpcmp_parts_f>:
     cbc:	1f 93       	push	r17
     cbe:	dc 01       	movw	r26, r24
     cc0:	fb 01       	movw	r30, r22
     cc2:	9c 91       	ld	r25, X
     cc4:	92 30       	cpi	r25, 0x02	; 2
     cc6:	08 f4       	brcc	.+2      	; 0xcca <__fpcmp_parts_f+0xe>
     cc8:	47 c0       	rjmp	.+142    	; 0xd58 <__fpcmp_parts_f+0x9c>
     cca:	80 81       	ld	r24, Z
     ccc:	82 30       	cpi	r24, 0x02	; 2
     cce:	08 f4       	brcc	.+2      	; 0xcd2 <__fpcmp_parts_f+0x16>
     cd0:	43 c0       	rjmp	.+134    	; 0xd58 <__fpcmp_parts_f+0x9c>
     cd2:	94 30       	cpi	r25, 0x04	; 4
     cd4:	51 f4       	brne	.+20     	; 0xcea <__fpcmp_parts_f+0x2e>
     cd6:	11 96       	adiw	r26, 0x01	; 1
     cd8:	1c 91       	ld	r17, X
     cda:	84 30       	cpi	r24, 0x04	; 4
     cdc:	99 f5       	brne	.+102    	; 0xd44 <__fpcmp_parts_f+0x88>
     cde:	81 81       	ldd	r24, Z+1	; 0x01
     ce0:	68 2f       	mov	r22, r24
     ce2:	70 e0       	ldi	r23, 0x00	; 0
     ce4:	61 1b       	sub	r22, r17
     ce6:	71 09       	sbc	r23, r1
     ce8:	3f c0       	rjmp	.+126    	; 0xd68 <__fpcmp_parts_f+0xac>
     cea:	84 30       	cpi	r24, 0x04	; 4
     cec:	21 f0       	breq	.+8      	; 0xcf6 <__fpcmp_parts_f+0x3a>
     cee:	92 30       	cpi	r25, 0x02	; 2
     cf0:	31 f4       	brne	.+12     	; 0xcfe <__fpcmp_parts_f+0x42>
     cf2:	82 30       	cpi	r24, 0x02	; 2
     cf4:	b9 f1       	breq	.+110    	; 0xd64 <__fpcmp_parts_f+0xa8>
     cf6:	81 81       	ldd	r24, Z+1	; 0x01
     cf8:	88 23       	and	r24, r24
     cfa:	89 f1       	breq	.+98     	; 0xd5e <__fpcmp_parts_f+0xa2>
     cfc:	2d c0       	rjmp	.+90     	; 0xd58 <__fpcmp_parts_f+0x9c>
     cfe:	11 96       	adiw	r26, 0x01	; 1
     d00:	1c 91       	ld	r17, X
     d02:	11 97       	sbiw	r26, 0x01	; 1
     d04:	82 30       	cpi	r24, 0x02	; 2
     d06:	f1 f0       	breq	.+60     	; 0xd44 <__fpcmp_parts_f+0x88>
     d08:	81 81       	ldd	r24, Z+1	; 0x01
     d0a:	18 17       	cp	r17, r24
     d0c:	d9 f4       	brne	.+54     	; 0xd44 <__fpcmp_parts_f+0x88>
     d0e:	12 96       	adiw	r26, 0x02	; 2
     d10:	2d 91       	ld	r18, X+
     d12:	3c 91       	ld	r19, X
     d14:	13 97       	sbiw	r26, 0x03	; 3
     d16:	82 81       	ldd	r24, Z+2	; 0x02
     d18:	93 81       	ldd	r25, Z+3	; 0x03
     d1a:	82 17       	cp	r24, r18
     d1c:	93 07       	cpc	r25, r19
     d1e:	94 f0       	brlt	.+36     	; 0xd44 <__fpcmp_parts_f+0x88>
     d20:	28 17       	cp	r18, r24
     d22:	39 07       	cpc	r19, r25
     d24:	bc f0       	brlt	.+46     	; 0xd54 <__fpcmp_parts_f+0x98>
     d26:	14 96       	adiw	r26, 0x04	; 4
     d28:	8d 91       	ld	r24, X+
     d2a:	9d 91       	ld	r25, X+
     d2c:	0d 90       	ld	r0, X+
     d2e:	bc 91       	ld	r27, X
     d30:	a0 2d       	mov	r26, r0
     d32:	24 81       	ldd	r18, Z+4	; 0x04
     d34:	35 81       	ldd	r19, Z+5	; 0x05
     d36:	46 81       	ldd	r20, Z+6	; 0x06
     d38:	57 81       	ldd	r21, Z+7	; 0x07
     d3a:	28 17       	cp	r18, r24
     d3c:	39 07       	cpc	r19, r25
     d3e:	4a 07       	cpc	r20, r26
     d40:	5b 07       	cpc	r21, r27
     d42:	18 f4       	brcc	.+6      	; 0xd4a <__fpcmp_parts_f+0x8e>
     d44:	11 23       	and	r17, r17
     d46:	41 f0       	breq	.+16     	; 0xd58 <__fpcmp_parts_f+0x9c>
     d48:	0a c0       	rjmp	.+20     	; 0xd5e <__fpcmp_parts_f+0xa2>
     d4a:	82 17       	cp	r24, r18
     d4c:	93 07       	cpc	r25, r19
     d4e:	a4 07       	cpc	r26, r20
     d50:	b5 07       	cpc	r27, r21
     d52:	40 f4       	brcc	.+16     	; 0xd64 <__fpcmp_parts_f+0xa8>
     d54:	11 23       	and	r17, r17
     d56:	19 f0       	breq	.+6      	; 0xd5e <__fpcmp_parts_f+0xa2>
     d58:	61 e0       	ldi	r22, 0x01	; 1
     d5a:	70 e0       	ldi	r23, 0x00	; 0
     d5c:	05 c0       	rjmp	.+10     	; 0xd68 <__fpcmp_parts_f+0xac>
     d5e:	6f ef       	ldi	r22, 0xFF	; 255
     d60:	7f ef       	ldi	r23, 0xFF	; 255
     d62:	02 c0       	rjmp	.+4      	; 0xd68 <__fpcmp_parts_f+0xac>
     d64:	60 e0       	ldi	r22, 0x00	; 0
     d66:	70 e0       	ldi	r23, 0x00	; 0
     d68:	cb 01       	movw	r24, r22
     d6a:	1f 91       	pop	r17
     d6c:	08 95       	ret

00000d6e <__vector_11>:
#define Timer0_WG_PWM_Reserved_Option   (u8)1

static void (*Timer0_Tovf_cbk_Fptr)(void) = NULL;
static void (*Timer0_Ctc_cbk_Fptr)(void) = NULL;

ISR(TIMER0_OVF_vect){
     d6e:	1f 92       	push	r1
     d70:	0f 92       	push	r0
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	0f 92       	push	r0
     d76:	11 24       	eor	r1, r1
     d78:	2f 93       	push	r18
     d7a:	3f 93       	push	r19
     d7c:	4f 93       	push	r20
     d7e:	5f 93       	push	r21
     d80:	6f 93       	push	r22
     d82:	7f 93       	push	r23
     d84:	8f 93       	push	r24
     d86:	9f 93       	push	r25
     d88:	af 93       	push	r26
     d8a:	bf 93       	push	r27
     d8c:	ef 93       	push	r30
     d8e:	ff 93       	push	r31
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
	if(Timer0_Tovf_cbk_Fptr != NULL){
     d98:	80 91 9c 01 	lds	r24, 0x019C
     d9c:	90 91 9d 01 	lds	r25, 0x019D
     da0:	00 97       	sbiw	r24, 0x00	; 0
     da2:	29 f0       	breq	.+10     	; 0xdae <__vector_11+0x40>
		Timer0_Tovf_cbk_Fptr();
     da4:	e0 91 9c 01 	lds	r30, 0x019C
     da8:	f0 91 9d 01 	lds	r31, 0x019D
     dac:	09 95       	icall
	}
}
     dae:	cf 91       	pop	r28
     db0:	df 91       	pop	r29
     db2:	ff 91       	pop	r31
     db4:	ef 91       	pop	r30
     db6:	bf 91       	pop	r27
     db8:	af 91       	pop	r26
     dba:	9f 91       	pop	r25
     dbc:	8f 91       	pop	r24
     dbe:	7f 91       	pop	r23
     dc0:	6f 91       	pop	r22
     dc2:	5f 91       	pop	r21
     dc4:	4f 91       	pop	r20
     dc6:	3f 91       	pop	r19
     dc8:	2f 91       	pop	r18
     dca:	0f 90       	pop	r0
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	0f 90       	pop	r0
     dd0:	1f 90       	pop	r1
     dd2:	18 95       	reti

00000dd4 <__vector_10>:

ISR(TIMER0_COMP_vect){
     dd4:	1f 92       	push	r1
     dd6:	0f 92       	push	r0
     dd8:	0f b6       	in	r0, 0x3f	; 63
     dda:	0f 92       	push	r0
     ddc:	11 24       	eor	r1, r1
     dde:	2f 93       	push	r18
     de0:	3f 93       	push	r19
     de2:	4f 93       	push	r20
     de4:	5f 93       	push	r21
     de6:	6f 93       	push	r22
     de8:	7f 93       	push	r23
     dea:	8f 93       	push	r24
     dec:	9f 93       	push	r25
     dee:	af 93       	push	r26
     df0:	bf 93       	push	r27
     df2:	ef 93       	push	r30
     df4:	ff 93       	push	r31
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
	if(Timer0_Ctc_cbk_Fptr != NULL){
     dfe:	80 91 9e 01 	lds	r24, 0x019E
     e02:	90 91 9f 01 	lds	r25, 0x019F
     e06:	00 97       	sbiw	r24, 0x00	; 0
     e08:	29 f0       	breq	.+10     	; 0xe14 <__vector_10+0x40>
		Timer0_Ctc_cbk_Fptr();
     e0a:	e0 91 9e 01 	lds	r30, 0x019E
     e0e:	f0 91 9f 01 	lds	r31, 0x019F
     e12:	09 95       	icall
	}
}
     e14:	cf 91       	pop	r28
     e16:	df 91       	pop	r29
     e18:	ff 91       	pop	r31
     e1a:	ef 91       	pop	r30
     e1c:	bf 91       	pop	r27
     e1e:	af 91       	pop	r26
     e20:	9f 91       	pop	r25
     e22:	8f 91       	pop	r24
     e24:	7f 91       	pop	r23
     e26:	6f 91       	pop	r22
     e28:	5f 91       	pop	r21
     e2a:	4f 91       	pop	r20
     e2c:	3f 91       	pop	r19
     e2e:	2f 91       	pop	r18
     e30:	0f 90       	pop	r0
     e32:	0f be       	out	0x3f, r0	; 63
     e34:	0f 90       	pop	r0
     e36:	1f 90       	pop	r1
     e38:	18 95       	reti

00000e3a <Timer0_vidinit>:

static Timer0_Prescaller_e TIMER0_CLK_SLCT = Timer0_Prescaller_e_No;

void Timer0_vidinit(void){
     e3a:	df 93       	push	r29
     e3c:	cf 93       	push	r28
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
#if TIMER0_MODE == NORMAL_MODE
	CLR_BIT(TCCR0_REG, 3);
     e42:	a3 e5       	ldi	r26, 0x53	; 83
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	e3 e5       	ldi	r30, 0x53	; 83
     e48:	f0 e0       	ldi	r31, 0x00	; 0
     e4a:	80 81       	ld	r24, Z
     e4c:	87 7f       	andi	r24, 0xF7	; 247
     e4e:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG, 6);
     e50:	a3 e5       	ldi	r26, 0x53	; 83
     e52:	b0 e0       	ldi	r27, 0x00	; 0
     e54:	e3 e5       	ldi	r30, 0x53	; 83
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	80 81       	ld	r24, Z
     e5a:	8f 7b       	andi	r24, 0xBF	; 191
     e5c:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG, 5);
#elif TIMER0_COMPARE_OUTPUT_MODE == TOGGLE_ON_CM_MODE
	SET_BIT(TCCR0_REG, 4);
	CLR_BIT(TCCR0_REG, 5);
#elif TIMER0_COMPARE_OUTPUT_MODE == CLEAR_ON_CM_MODE || TIMER0_COMPARE_OUTPUT_MODE == INVERTED_MODE
	CLR_BIT(TCCR0_REG, 4);
     e5e:	a3 e5       	ldi	r26, 0x53	; 83
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	e3 e5       	ldi	r30, 0x53	; 83
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	8f 7e       	andi	r24, 0xEF	; 239
     e6a:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG, 5);
     e6c:	a3 e5       	ldi	r26, 0x53	; 83
     e6e:	b0 e0       	ldi	r27, 0x00	; 0
     e70:	e3 e5       	ldi	r30, 0x53	; 83
     e72:	f0 e0       	ldi	r31, 0x00	; 0
     e74:	80 81       	ld	r24, Z
     e76:	80 62       	ori	r24, 0x20	; 32
     e78:	8c 93       	st	X, r24
#elif TIMER0_COMPARE_OUTPUT_MODE == SET_ON_CM_MODE || TIMER0_COMPARE_OUTPUT_MODE == NON_INVERTED_MODE
	SET_BIT(TCCR0_REG, 5);
	SET_BIT(TCCR0_REG, 5);
#endif
}
     e7a:	cf 91       	pop	r28
     e7c:	df 91       	pop	r29
     e7e:	08 95       	ret

00000e80 <Timer0_vidSlctPrescaller>:

void Timer0_vidSlctPrescaller(Timer0_Prescaller_e Copy_Timer0_Prescaller_e_value){
     e80:	df 93       	push	r29
     e82:	cf 93       	push	r28
     e84:	0f 92       	push	r0
     e86:	cd b7       	in	r28, 0x3d	; 61
     e88:	de b7       	in	r29, 0x3e	; 62
     e8a:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_Timer0_Prescaller_e_value >= Timer0_Prescaller_e_No &&
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	88 23       	and	r24, r24
     e90:	31 f0       	breq	.+12     	; 0xe9e <Timer0_vidSlctPrescaller+0x1e>
     e92:	89 81       	ldd	r24, Y+1	; 0x01
     e94:	88 30       	cpi	r24, 0x08	; 8
     e96:	18 f4       	brcc	.+6      	; 0xe9e <Timer0_vidSlctPrescaller+0x1e>
			Copy_Timer0_Prescaller_e_value <= Timer0_Prescaller_e_Ext_Rising_Edge ){
		TIMER0_CLK_SLCT = Copy_Timer0_Prescaller_e_value;
     e98:	89 81       	ldd	r24, Y+1	; 0x01
     e9a:	80 93 94 01 	sts	0x0194, r24
	}
}
     e9e:	0f 90       	pop	r0
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	08 95       	ret

00000ea6 <Timer0_vidSetPreloadVlaue>:

void Timer0_vidSetPreloadVlaue(u8 Copy_u8PreloadValue){
     ea6:	df 93       	push	r29
     ea8:	cf 93       	push	r28
     eaa:	0f 92       	push	r0
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
     eb0:	89 83       	std	Y+1, r24	; 0x01
	TCNT0_REG = Copy_u8PreloadValue;
     eb2:	e2 e5       	ldi	r30, 0x52	; 82
     eb4:	f0 e0       	ldi	r31, 0x00	; 0
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	80 83       	st	Z, r24
}
     eba:	0f 90       	pop	r0
     ebc:	cf 91       	pop	r28
     ebe:	df 91       	pop	r29
     ec0:	08 95       	ret

00000ec2 <Timer0_vidSetCTCValue>:

void Timer0_vidSetCTCValue(u8 Copy_u8CtcValue){
     ec2:	df 93       	push	r29
     ec4:	cf 93       	push	r28
     ec6:	0f 92       	push	r0
     ec8:	cd b7       	in	r28, 0x3d	; 61
     eca:	de b7       	in	r29, 0x3e	; 62
     ecc:	89 83       	std	Y+1, r24	; 0x01
	OCR0_REG = Copy_u8CtcValue;
     ece:	ec e5       	ldi	r30, 0x5C	; 92
     ed0:	f0 e0       	ldi	r31, 0x00	; 0
     ed2:	89 81       	ldd	r24, Y+1	; 0x01
     ed4:	80 83       	st	Z, r24
}
     ed6:	0f 90       	pop	r0
     ed8:	cf 91       	pop	r28
     eda:	df 91       	pop	r29
     edc:	08 95       	ret

00000ede <Timer0_vidStartTimer>:

void Timer0_vidStartTimer(void){
     ede:	df 93       	push	r29
     ee0:	cf 93       	push	r28
     ee2:	cd b7       	in	r28, 0x3d	; 61
     ee4:	de b7       	in	r29, 0x3e	; 62
	TCCR0_REG &= TIMER0_CLK_CLR_MSK;
     ee6:	a3 e5       	ldi	r26, 0x53	; 83
     ee8:	b0 e0       	ldi	r27, 0x00	; 0
     eea:	e3 e5       	ldi	r30, 0x53	; 83
     eec:	f0 e0       	ldi	r31, 0x00	; 0
     eee:	80 81       	ld	r24, Z
     ef0:	88 7f       	andi	r24, 0xF8	; 248
     ef2:	8c 93       	st	X, r24
	TCCR0_REG |= TIMER0_CLK_SLCT;
     ef4:	a3 e5       	ldi	r26, 0x53	; 83
     ef6:	b0 e0       	ldi	r27, 0x00	; 0
     ef8:	e3 e5       	ldi	r30, 0x53	; 83
     efa:	f0 e0       	ldi	r31, 0x00	; 0
     efc:	90 81       	ld	r25, Z
     efe:	80 91 94 01 	lds	r24, 0x0194
     f02:	89 2b       	or	r24, r25
     f04:	8c 93       	st	X, r24
}
     f06:	cf 91       	pop	r28
     f08:	df 91       	pop	r29
     f0a:	08 95       	ret

00000f0c <Timer0_vidStopTimer>:

void Timer0_vidStopTimer(void){
     f0c:	df 93       	push	r29
     f0e:	cf 93       	push	r28
     f10:	cd b7       	in	r28, 0x3d	; 61
     f12:	de b7       	in	r29, 0x3e	; 62
	TCCR0_REG &= TIMER0_CLK_CLR_MSK;
     f14:	a3 e5       	ldi	r26, 0x53	; 83
     f16:	b0 e0       	ldi	r27, 0x00	; 0
     f18:	e3 e5       	ldi	r30, 0x53	; 83
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	80 81       	ld	r24, Z
     f1e:	88 7f       	andi	r24, 0xF8	; 248
     f20:	8c 93       	st	X, r24
}
     f22:	cf 91       	pop	r28
     f24:	df 91       	pop	r29
     f26:	08 95       	ret

00000f28 <Timer0_vidTovfIrqEnable>:

void Timer0_vidTovfIrqEnable(void){
     f28:	df 93       	push	r29
     f2a:	cf 93       	push	r28
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK_REG, 0);
     f30:	a9 e5       	ldi	r26, 0x59	; 89
     f32:	b0 e0       	ldi	r27, 0x00	; 0
     f34:	e9 e5       	ldi	r30, 0x59	; 89
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	81 60       	ori	r24, 0x01	; 1
     f3c:	8c 93       	st	X, r24
}
     f3e:	cf 91       	pop	r28
     f40:	df 91       	pop	r29
     f42:	08 95       	ret

00000f44 <Timer0_vidTovfIrqDisable>:

void Timer0_vidTovfIrqDisable(void){
     f44:	df 93       	push	r29
     f46:	cf 93       	push	r28
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK_REG, 0);
     f4c:	a9 e5       	ldi	r26, 0x59	; 89
     f4e:	b0 e0       	ldi	r27, 0x00	; 0
     f50:	e9 e5       	ldi	r30, 0x59	; 89
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	80 81       	ld	r24, Z
     f56:	8e 7f       	andi	r24, 0xFE	; 254
     f58:	8c 93       	st	X, r24
}
     f5a:	cf 91       	pop	r28
     f5c:	df 91       	pop	r29
     f5e:	08 95       	ret

00000f60 <Timer0_vidCtcIrqEnable>:

void Timer0_vidCtcIrqEnable(void){
     f60:	df 93       	push	r29
     f62:	cf 93       	push	r28
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK_REG, 1);
     f68:	a9 e5       	ldi	r26, 0x59	; 89
     f6a:	b0 e0       	ldi	r27, 0x00	; 0
     f6c:	e9 e5       	ldi	r30, 0x59	; 89
     f6e:	f0 e0       	ldi	r31, 0x00	; 0
     f70:	80 81       	ld	r24, Z
     f72:	82 60       	ori	r24, 0x02	; 2
     f74:	8c 93       	st	X, r24
}
     f76:	cf 91       	pop	r28
     f78:	df 91       	pop	r29
     f7a:	08 95       	ret

00000f7c <Timer0_vidCtcIrqDisable>:

void Timer0_vidCtcIrqDisable(void){
     f7c:	df 93       	push	r29
     f7e:	cf 93       	push	r28
     f80:	cd b7       	in	r28, 0x3d	; 61
     f82:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK_REG, 1);
     f84:	a9 e5       	ldi	r26, 0x59	; 89
     f86:	b0 e0       	ldi	r27, 0x00	; 0
     f88:	e9 e5       	ldi	r30, 0x59	; 89
     f8a:	f0 e0       	ldi	r31, 0x00	; 0
     f8c:	80 81       	ld	r24, Z
     f8e:	8d 7f       	andi	r24, 0xFD	; 253
     f90:	8c 93       	st	X, r24
}
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	08 95       	ret

00000f98 <Timer0_vidSet_Tovf_Call_Back>:
	}
}
*/

//To set the call back function of the Normal mode.
void Timer0_vidSet_Tovf_Call_Back(void (*fptr)(void)){
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <Timer0_vidSet_Tovf_Call_Back+0x6>
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
     fa2:	9a 83       	std	Y+2, r25	; 0x02
     fa4:	89 83       	std	Y+1, r24	; 0x01
	if(fptr != NULL){
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	9a 81       	ldd	r25, Y+2	; 0x02
     faa:	00 97       	sbiw	r24, 0x00	; 0
     fac:	31 f0       	breq	.+12     	; 0xfba <Timer0_vidSet_Tovf_Call_Back+0x22>
		Timer0_Tovf_cbk_Fptr = fptr;
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	90 93 9d 01 	sts	0x019D, r25
     fb6:	80 93 9c 01 	sts	0x019C, r24
	}
}
     fba:	0f 90       	pop	r0
     fbc:	0f 90       	pop	r0
     fbe:	cf 91       	pop	r28
     fc0:	df 91       	pop	r29
     fc2:	08 95       	ret

00000fc4 <Timer0_vidSet_CTC_Call_Back>:

//To set the call back function of the CTC mode.
void Timer0_vidSet_CTC_Call_Back(void (*fptr)(void)){
     fc4:	df 93       	push	r29
     fc6:	cf 93       	push	r28
     fc8:	00 d0       	rcall	.+0      	; 0xfca <Timer0_vidSet_CTC_Call_Back+0x6>
     fca:	cd b7       	in	r28, 0x3d	; 61
     fcc:	de b7       	in	r29, 0x3e	; 62
     fce:	9a 83       	std	Y+2, r25	; 0x02
     fd0:	89 83       	std	Y+1, r24	; 0x01
	if(fptr != NULL){
     fd2:	89 81       	ldd	r24, Y+1	; 0x01
     fd4:	9a 81       	ldd	r25, Y+2	; 0x02
     fd6:	00 97       	sbiw	r24, 0x00	; 0
     fd8:	31 f0       	breq	.+12     	; 0xfe6 <Timer0_vidSet_CTC_Call_Back+0x22>
		Timer0_Ctc_cbk_Fptr = fptr;
     fda:	89 81       	ldd	r24, Y+1	; 0x01
     fdc:	9a 81       	ldd	r25, Y+2	; 0x02
     fde:	90 93 9f 01 	sts	0x019F, r25
     fe2:	80 93 9e 01 	sts	0x019E, r24
	}
}
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	cf 91       	pop	r28
     fec:	df 91       	pop	r29
     fee:	08 95       	ret

00000ff0 <Timer0_vidSetPwmDutyCycle>:

void Timer0_vidSetPwmDutyCycle(u8 Copy_u8DutyCycle){
     ff0:	df 93       	push	r29
     ff2:	cf 93       	push	r28
     ff4:	00 d0       	rcall	.+0      	; 0xff6 <Timer0_vidSetPwmDutyCycle+0x6>
     ff6:	cd b7       	in	r28, 0x3d	; 61
     ff8:	de b7       	in	r29, 0x3e	; 62
     ffa:	8a 83       	std	Y+2, r24	; 0x02
	u8 DutyTicks;
	DutyTicks = 256 * ((f32)Copy_u8DutyCycle / 100);
     ffc:	8a 81       	ldd	r24, Y+2	; 0x02
     ffe:	88 2f       	mov	r24, r24
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	a0 e0       	ldi	r26, 0x00	; 0
    1004:	b0 e0       	ldi	r27, 0x00	; 0
    1006:	bc 01       	movw	r22, r24
    1008:	cd 01       	movw	r24, r26
    100a:	0e 94 49 04 	call	0x892	; 0x892 <__floatunsisf>
    100e:	dc 01       	movw	r26, r24
    1010:	cb 01       	movw	r24, r22
    1012:	bc 01       	movw	r22, r24
    1014:	cd 01       	movw	r24, r26
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	48 ec       	ldi	r20, 0xC8	; 200
    101c:	52 e4       	ldi	r21, 0x42	; 66
    101e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1022:	dc 01       	movw	r26, r24
    1024:	cb 01       	movw	r24, r22
    1026:	bc 01       	movw	r22, r24
    1028:	cd 01       	movw	r24, r26
    102a:	20 e0       	ldi	r18, 0x00	; 0
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	40 e8       	ldi	r20, 0x80	; 128
    1030:	53 e4       	ldi	r21, 0x43	; 67
    1032:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1036:	dc 01       	movw	r26, r24
    1038:	cb 01       	movw	r24, r22
    103a:	bc 01       	movw	r22, r24
    103c:	cd 01       	movw	r24, r26
    103e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1042:	dc 01       	movw	r26, r24
    1044:	cb 01       	movw	r24, r22
    1046:	89 83       	std	Y+1, r24	; 0x01
#if TIMER0_COMPARE_OUTPUT_MODE == INVERTED_MODE
	OCR0_REG = DutyTicks;
    1048:	ec e5       	ldi	r30, 0x5C	; 92
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	89 81       	ldd	r24, Y+1	; 0x01
    104e:	80 83       	st	Z, r24
#elif TIMER0_COMPARE_OUTPUT_MODE == NON_INVERTED_MODE
	OCR0_REG = 255-DutyTicks;
#endif
}
    1050:	0f 90       	pop	r0
    1052:	0f 90       	pop	r0
    1054:	cf 91       	pop	r28
    1056:	df 91       	pop	r29
    1058:	08 95       	ret

0000105a <MSPI_voidSpiMasterInit>:
 @Brief     :
 @Parameter :
 @Return    :
 */
void MSPI_voidSpiMasterInit(void)
{
    105a:	df 93       	push	r29
    105c:	cf 93       	push	r28
    105e:	0f 92       	push	r0
    1060:	cd b7       	in	r28, 0x3d	; 61
    1062:	de b7       	in	r29, 0x3e	; 62
	u8 temp_SPCR = 0;
    1064:	19 82       	std	Y+1, r1	; 0x01

	// Set MOSI pin direction output
	DIO_u8setPinDir(DIO_PORT_B,DIO_PIN_4,DIO_OUTPUT);
    1066:	81 e0       	ldi	r24, 0x01	; 1
    1068:	64 e0       	ldi	r22, 0x04	; 4
    106a:	41 e0       	ldi	r20, 0x01	; 1
    106c:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <DIO_u8setPinDir>
	DIO_u8setPinDir(DIO_PORT_B,DIO_PIN_5,DIO_OUTPUT);
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	65 e0       	ldi	r22, 0x05	; 5
    1074:	41 e0       	ldi	r20, 0x01	; 1
    1076:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <DIO_u8setPinDir>
	DIO_u8setPinDir(DIO_PORT_B,DIO_PIN_6,DIO_INPUT);
    107a:	81 e0       	ldi	r24, 0x01	; 1
    107c:	66 e0       	ldi	r22, 0x06	; 6
    107e:	40 e0       	ldi	r20, 0x00	; 0
    1080:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <DIO_u8setPinDir>
	DIO_u8setPinVal(DIO_PORT_B,DIO_PIN_6,DIO_HIGH);
    1084:	81 e0       	ldi	r24, 0x01	; 1
    1086:	66 e0       	ldi	r22, 0x06	; 6
    1088:	41 e0       	ldi	r20, 0x01	; 1
    108a:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
	DIO_u8setPinDir(DIO_PORT_B,DIO_PIN_7,DIO_OUTPUT);
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	67 e0       	ldi	r22, 0x07	; 7
    1092:	41 e0       	ldi	r20, 0x01	; 1
    1094:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <DIO_u8setPinDir>
//	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN7, DIO_LOW);

	// enable SPI
	SET_BIT(temp_SPCR, 6);
    1098:	89 81       	ldd	r24, Y+1	; 0x01
    109a:	80 64       	ori	r24, 0x40	; 64
    109c:	89 83       	std	Y+1, r24	; 0x01

	// data order >>>> transmit MSB first
	CLR_BIT(temp_SPCR, 5);
    109e:	89 81       	ldd	r24, Y+1	; 0x01
    10a0:	8f 7d       	andi	r24, 0xDF	; 223
    10a2:	89 83       	std	Y+1, r24	; 0x01

	// configure SS pin as output and choose master spi mode
	//DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN4, DIO_OUTPUT);
	//DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_HIGH);
	SET_BIT(temp_SPCR, 4);
    10a4:	89 81       	ldd	r24, Y+1	; 0x01
    10a6:	80 61       	ori	r24, 0x10	; 16
    10a8:	89 83       	std	Y+1, r24	; 0x01


	// clock polarity >>> leading rising edge
	CLR_BIT(temp_SPCR, 3);
    10aa:	89 81       	ldd	r24, Y+1	; 0x01
    10ac:	87 7f       	andi	r24, 0xF7	; 247
    10ae:	89 83       	std	Y+1, r24	; 0x01

	// clock phase >>>> sampling at rising edge
	CLR_BIT(temp_SPCR, 2);
    10b0:	89 81       	ldd	r24, Y+1	; 0x01
    10b2:	8b 7f       	andi	r24, 0xFB	; 251
    10b4:	89 83       	std	Y+1, r24	; 0x01

	// clock oscillator >> F_CPU / 8
	SET_BIT(temp_SPCR, 0);
    10b6:	89 81       	ldd	r24, Y+1	; 0x01
    10b8:	81 60       	ori	r24, 0x01	; 1
    10ba:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(temp_SPCR, 1);
    10bc:	89 81       	ldd	r24, Y+1	; 0x01
    10be:	8d 7f       	andi	r24, 0xFD	; 253
    10c0:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(SPSR, 0);
    10c2:	ae e2       	ldi	r26, 0x2E	; 46
    10c4:	b0 e0       	ldi	r27, 0x00	; 0
    10c6:	ee e2       	ldi	r30, 0x2E	; 46
    10c8:	f0 e0       	ldi	r31, 0x00	; 0
    10ca:	80 81       	ld	r24, Z
    10cc:	81 60       	ori	r24, 0x01	; 1
    10ce:	8c 93       	st	X, r24

	SPCR = temp_SPCR;
    10d0:	ed e2       	ldi	r30, 0x2D	; 45
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	89 81       	ldd	r24, Y+1	; 0x01
    10d6:	80 83       	st	Z, r24
}
    10d8:	0f 90       	pop	r0
    10da:	cf 91       	pop	r28
    10dc:	df 91       	pop	r29
    10de:	08 95       	ret

000010e0 <MSPI_voidSetPreSca>:
 @Brief     :
 @Parameter :
 @Return    :
 */
void MSPI_voidSetPreSca(u8 Copy_u8Presca_value)
{
    10e0:	df 93       	push	r29
    10e2:	cf 93       	push	r28
    10e4:	00 d0       	rcall	.+0      	; 0x10e6 <MSPI_voidSetPreSca+0x6>
    10e6:	0f 92       	push	r0
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8Presca_value)
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	28 2f       	mov	r18, r24
    10f2:	30 e0       	ldi	r19, 0x00	; 0
    10f4:	3b 83       	std	Y+3, r19	; 0x03
    10f6:	2a 83       	std	Y+2, r18	; 0x02
    10f8:	8a 81       	ldd	r24, Y+2	; 0x02
    10fa:	9b 81       	ldd	r25, Y+3	; 0x03
    10fc:	83 30       	cpi	r24, 0x03	; 3
    10fe:	91 05       	cpc	r25, r1
    1100:	09 f4       	brne	.+2      	; 0x1104 <MSPI_voidSetPreSca+0x24>
    1102:	6a c0       	rjmp	.+212    	; 0x11d8 <MSPI_voidSetPreSca+0xf8>
    1104:	2a 81       	ldd	r18, Y+2	; 0x02
    1106:	3b 81       	ldd	r19, Y+3	; 0x03
    1108:	24 30       	cpi	r18, 0x04	; 4
    110a:	31 05       	cpc	r19, r1
    110c:	84 f4       	brge	.+32     	; 0x112e <MSPI_voidSetPreSca+0x4e>
    110e:	8a 81       	ldd	r24, Y+2	; 0x02
    1110:	9b 81       	ldd	r25, Y+3	; 0x03
    1112:	81 30       	cpi	r24, 0x01	; 1
    1114:	91 05       	cpc	r25, r1
    1116:	a1 f1       	breq	.+104    	; 0x1180 <MSPI_voidSetPreSca+0xa0>
    1118:	2a 81       	ldd	r18, Y+2	; 0x02
    111a:	3b 81       	ldd	r19, Y+3	; 0x03
    111c:	22 30       	cpi	r18, 0x02	; 2
    111e:	31 05       	cpc	r19, r1
    1120:	0c f0       	brlt	.+2      	; 0x1124 <MSPI_voidSetPreSca+0x44>
    1122:	44 c0       	rjmp	.+136    	; 0x11ac <MSPI_voidSetPreSca+0xcc>
    1124:	8a 81       	ldd	r24, Y+2	; 0x02
    1126:	9b 81       	ldd	r25, Y+3	; 0x03
    1128:	00 97       	sbiw	r24, 0x00	; 0
    112a:	a1 f0       	breq	.+40     	; 0x1154 <MSPI_voidSetPreSca+0x74>
    112c:	ad c0       	rjmp	.+346    	; 0x1288 <MSPI_voidSetPreSca+0x1a8>
    112e:	2a 81       	ldd	r18, Y+2	; 0x02
    1130:	3b 81       	ldd	r19, Y+3	; 0x03
    1132:	25 30       	cpi	r18, 0x05	; 5
    1134:	31 05       	cpc	r19, r1
    1136:	09 f4       	brne	.+2      	; 0x113a <MSPI_voidSetPreSca+0x5a>
    1138:	7b c0       	rjmp	.+246    	; 0x1230 <MSPI_voidSetPreSca+0x150>
    113a:	8a 81       	ldd	r24, Y+2	; 0x02
    113c:	9b 81       	ldd	r25, Y+3	; 0x03
    113e:	85 30       	cpi	r24, 0x05	; 5
    1140:	91 05       	cpc	r25, r1
    1142:	0c f4       	brge	.+2      	; 0x1146 <MSPI_voidSetPreSca+0x66>
    1144:	5f c0       	rjmp	.+190    	; 0x1204 <MSPI_voidSetPreSca+0x124>
    1146:	2a 81       	ldd	r18, Y+2	; 0x02
    1148:	3b 81       	ldd	r19, Y+3	; 0x03
    114a:	26 30       	cpi	r18, 0x06	; 6
    114c:	31 05       	cpc	r19, r1
    114e:	09 f4       	brne	.+2      	; 0x1152 <MSPI_voidSetPreSca+0x72>
    1150:	85 c0       	rjmp	.+266    	; 0x125c <MSPI_voidSetPreSca+0x17c>
    1152:	9a c0       	rjmp	.+308    	; 0x1288 <MSPI_voidSetPreSca+0x1a8>
	{
		/************************ ***/
		case 0:
			CLR_BIT(SPCR, 0);
    1154:	ad e2       	ldi	r26, 0x2D	; 45
    1156:	b0 e0       	ldi	r27, 0x00	; 0
    1158:	ed e2       	ldi	r30, 0x2D	; 45
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	80 81       	ld	r24, Z
    115e:	8e 7f       	andi	r24, 0xFE	; 254
    1160:	8c 93       	st	X, r24
			CLR_BIT(SPCR, 1);
    1162:	ad e2       	ldi	r26, 0x2D	; 45
    1164:	b0 e0       	ldi	r27, 0x00	; 0
    1166:	ed e2       	ldi	r30, 0x2D	; 45
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	80 81       	ld	r24, Z
    116c:	8d 7f       	andi	r24, 0xFD	; 253
    116e:	8c 93       	st	X, r24
			CLR_BIT(SPSR, 0);
    1170:	ae e2       	ldi	r26, 0x2E	; 46
    1172:	b0 e0       	ldi	r27, 0x00	; 0
    1174:	ee e2       	ldi	r30, 0x2E	; 46
    1176:	f0 e0       	ldi	r31, 0x00	; 0
    1178:	80 81       	ld	r24, Z
    117a:	8e 7f       	andi	r24, 0xFE	; 254
    117c:	8c 93       	st	X, r24
    117e:	99 c0       	rjmp	.+306    	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 1:
			SET_BIT(SPCR, 0);
    1180:	ad e2       	ldi	r26, 0x2D	; 45
    1182:	b0 e0       	ldi	r27, 0x00	; 0
    1184:	ed e2       	ldi	r30, 0x2D	; 45
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	81 60       	ori	r24, 0x01	; 1
    118c:	8c 93       	st	X, r24
			CLR_BIT(SPCR, 1);
    118e:	ad e2       	ldi	r26, 0x2D	; 45
    1190:	b0 e0       	ldi	r27, 0x00	; 0
    1192:	ed e2       	ldi	r30, 0x2D	; 45
    1194:	f0 e0       	ldi	r31, 0x00	; 0
    1196:	80 81       	ld	r24, Z
    1198:	8d 7f       	andi	r24, 0xFD	; 253
    119a:	8c 93       	st	X, r24
			CLR_BIT(SPSR, 0);
    119c:	ae e2       	ldi	r26, 0x2E	; 46
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	ee e2       	ldi	r30, 0x2E	; 46
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	8e 7f       	andi	r24, 0xFE	; 254
    11a8:	8c 93       	st	X, r24
    11aa:	83 c0       	rjmp	.+262    	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 2:
			CLR_BIT(SPCR, 0);
    11ac:	ad e2       	ldi	r26, 0x2D	; 45
    11ae:	b0 e0       	ldi	r27, 0x00	; 0
    11b0:	ed e2       	ldi	r30, 0x2D	; 45
    11b2:	f0 e0       	ldi	r31, 0x00	; 0
    11b4:	80 81       	ld	r24, Z
    11b6:	8e 7f       	andi	r24, 0xFE	; 254
    11b8:	8c 93       	st	X, r24
			SET_BIT(SPCR, 1);
    11ba:	ad e2       	ldi	r26, 0x2D	; 45
    11bc:	b0 e0       	ldi	r27, 0x00	; 0
    11be:	ed e2       	ldi	r30, 0x2D	; 45
    11c0:	f0 e0       	ldi	r31, 0x00	; 0
    11c2:	80 81       	ld	r24, Z
    11c4:	82 60       	ori	r24, 0x02	; 2
    11c6:	8c 93       	st	X, r24
			CLR_BIT(SPSR, 0);
    11c8:	ae e2       	ldi	r26, 0x2E	; 46
    11ca:	b0 e0       	ldi	r27, 0x00	; 0
    11cc:	ee e2       	ldi	r30, 0x2E	; 46
    11ce:	f0 e0       	ldi	r31, 0x00	; 0
    11d0:	80 81       	ld	r24, Z
    11d2:	8e 7f       	andi	r24, 0xFE	; 254
    11d4:	8c 93       	st	X, r24
    11d6:	6d c0       	rjmp	.+218    	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 3:
			SET_BIT(SPCR, 0);
    11d8:	ad e2       	ldi	r26, 0x2D	; 45
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	ed e2       	ldi	r30, 0x2D	; 45
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	81 60       	ori	r24, 0x01	; 1
    11e4:	8c 93       	st	X, r24
			SET_BIT(SPCR, 1);
    11e6:	ad e2       	ldi	r26, 0x2D	; 45
    11e8:	b0 e0       	ldi	r27, 0x00	; 0
    11ea:	ed e2       	ldi	r30, 0x2D	; 45
    11ec:	f0 e0       	ldi	r31, 0x00	; 0
    11ee:	80 81       	ld	r24, Z
    11f0:	82 60       	ori	r24, 0x02	; 2
    11f2:	8c 93       	st	X, r24
			CLR_BIT(SPSR, 0);
    11f4:	ae e2       	ldi	r26, 0x2E	; 46
    11f6:	b0 e0       	ldi	r27, 0x00	; 0
    11f8:	ee e2       	ldi	r30, 0x2E	; 46
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	80 81       	ld	r24, Z
    11fe:	8e 7f       	andi	r24, 0xFE	; 254
    1200:	8c 93       	st	X, r24
    1202:	57 c0       	rjmp	.+174    	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 4:
			CLR_BIT(SPCR, 0);
    1204:	ad e2       	ldi	r26, 0x2D	; 45
    1206:	b0 e0       	ldi	r27, 0x00	; 0
    1208:	ed e2       	ldi	r30, 0x2D	; 45
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	80 81       	ld	r24, Z
    120e:	8e 7f       	andi	r24, 0xFE	; 254
    1210:	8c 93       	st	X, r24
			CLR_BIT(SPCR, 1);
    1212:	ad e2       	ldi	r26, 0x2D	; 45
    1214:	b0 e0       	ldi	r27, 0x00	; 0
    1216:	ed e2       	ldi	r30, 0x2D	; 45
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	80 81       	ld	r24, Z
    121c:	8d 7f       	andi	r24, 0xFD	; 253
    121e:	8c 93       	st	X, r24
			SET_BIT(SPSR, 0);
    1220:	ae e2       	ldi	r26, 0x2E	; 46
    1222:	b0 e0       	ldi	r27, 0x00	; 0
    1224:	ee e2       	ldi	r30, 0x2E	; 46
    1226:	f0 e0       	ldi	r31, 0x00	; 0
    1228:	80 81       	ld	r24, Z
    122a:	81 60       	ori	r24, 0x01	; 1
    122c:	8c 93       	st	X, r24
    122e:	41 c0       	rjmp	.+130    	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 5:
			SET_BIT(SPCR, 0);
    1230:	ad e2       	ldi	r26, 0x2D	; 45
    1232:	b0 e0       	ldi	r27, 0x00	; 0
    1234:	ed e2       	ldi	r30, 0x2D	; 45
    1236:	f0 e0       	ldi	r31, 0x00	; 0
    1238:	80 81       	ld	r24, Z
    123a:	81 60       	ori	r24, 0x01	; 1
    123c:	8c 93       	st	X, r24
			CLR_BIT(SPCR, 1);
    123e:	ad e2       	ldi	r26, 0x2D	; 45
    1240:	b0 e0       	ldi	r27, 0x00	; 0
    1242:	ed e2       	ldi	r30, 0x2D	; 45
    1244:	f0 e0       	ldi	r31, 0x00	; 0
    1246:	80 81       	ld	r24, Z
    1248:	8d 7f       	andi	r24, 0xFD	; 253
    124a:	8c 93       	st	X, r24
			SET_BIT(SPSR, 0);
    124c:	ae e2       	ldi	r26, 0x2E	; 46
    124e:	b0 e0       	ldi	r27, 0x00	; 0
    1250:	ee e2       	ldi	r30, 0x2E	; 46
    1252:	f0 e0       	ldi	r31, 0x00	; 0
    1254:	80 81       	ld	r24, Z
    1256:	81 60       	ori	r24, 0x01	; 1
    1258:	8c 93       	st	X, r24
    125a:	2b c0       	rjmp	.+86     	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		case 6:
			CLR_BIT(SPCR, 0);
    125c:	ad e2       	ldi	r26, 0x2D	; 45
    125e:	b0 e0       	ldi	r27, 0x00	; 0
    1260:	ed e2       	ldi	r30, 0x2D	; 45
    1262:	f0 e0       	ldi	r31, 0x00	; 0
    1264:	80 81       	ld	r24, Z
    1266:	8e 7f       	andi	r24, 0xFE	; 254
    1268:	8c 93       	st	X, r24
			SET_BIT(SPCR, 1);
    126a:	ad e2       	ldi	r26, 0x2D	; 45
    126c:	b0 e0       	ldi	r27, 0x00	; 0
    126e:	ed e2       	ldi	r30, 0x2D	; 45
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	80 81       	ld	r24, Z
    1274:	82 60       	ori	r24, 0x02	; 2
    1276:	8c 93       	st	X, r24
			SET_BIT(SPSR, 0);
    1278:	ae e2       	ldi	r26, 0x2E	; 46
    127a:	b0 e0       	ldi	r27, 0x00	; 0
    127c:	ee e2       	ldi	r30, 0x2E	; 46
    127e:	f0 e0       	ldi	r31, 0x00	; 0
    1280:	80 81       	ld	r24, Z
    1282:	81 60       	ori	r24, 0x01	; 1
    1284:	8c 93       	st	X, r24
    1286:	15 c0       	rjmp	.+42     	; 0x12b2 <MSPI_voidSetPreSca+0x1d2>
		break;
		/************************ ***/
		default :
			CLR_BIT(SPCR, 0);
    1288:	ad e2       	ldi	r26, 0x2D	; 45
    128a:	b0 e0       	ldi	r27, 0x00	; 0
    128c:	ed e2       	ldi	r30, 0x2D	; 45
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	8e 7f       	andi	r24, 0xFE	; 254
    1294:	8c 93       	st	X, r24
			CLR_BIT(SPCR, 1);
    1296:	ad e2       	ldi	r26, 0x2D	; 45
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	ed e2       	ldi	r30, 0x2D	; 45
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	8d 7f       	andi	r24, 0xFD	; 253
    12a2:	8c 93       	st	X, r24
			CLR_BIT(SPSR, 0);
    12a4:	ae e2       	ldi	r26, 0x2E	; 46
    12a6:	b0 e0       	ldi	r27, 0x00	; 0
    12a8:	ee e2       	ldi	r30, 0x2E	; 46
    12aa:	f0 e0       	ldi	r31, 0x00	; 0
    12ac:	80 81       	ld	r24, Z
    12ae:	8e 7f       	andi	r24, 0xFE	; 254
    12b0:	8c 93       	st	X, r24

		break;
	}
}
    12b2:	0f 90       	pop	r0
    12b4:	0f 90       	pop	r0
    12b6:	0f 90       	pop	r0
    12b8:	cf 91       	pop	r28
    12ba:	df 91       	pop	r29
    12bc:	08 95       	ret

000012be <MSPI_VidChipSelect>:
 @Brief     :
 @Parameter :
 @Return    :
 */
void MSPI_VidChipSelect(u8 state)
{
    12be:	df 93       	push	r29
    12c0:	cf 93       	push	r28
    12c2:	0f 92       	push	r0
    12c4:	cd b7       	in	r28, 0x3d	; 61
    12c6:	de b7       	in	r29, 0x3e	; 62
    12c8:	89 83       	std	Y+1, r24	; 0x01
	if(state == 1)
    12ca:	89 81       	ldd	r24, Y+1	; 0x01
    12cc:	81 30       	cpi	r24, 0x01	; 1
    12ce:	31 f4       	brne	.+12     	; 0x12dc <MSPI_VidChipSelect+0x1e>
	{
		//MCAL_DIO_voidSETBIT(PB,PB4,LOW);
		DIO_u8setPinVal(DIO_PORT_B,DIO_PIN_4,DIO_LOW);
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	64 e0       	ldi	r22, 0x04	; 4
    12d4:	40 e0       	ldi	r20, 0x00	; 0
    12d6:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
    12da:	05 c0       	rjmp	.+10     	; 0x12e6 <MSPI_VidChipSelect+0x28>
	}
	else
	{
		DIO_u8setPinVal(DIO_PORT_B,DIO_PIN_4,DIO_HIGH);
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	64 e0       	ldi	r22, 0x04	; 4
    12e0:	41 e0       	ldi	r20, 0x01	; 1
    12e2:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
	}
}
    12e6:	0f 90       	pop	r0
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	08 95       	ret

000012ee <MSPI_U8MasterTransmit>:
 @Brief     :
 @Parameter :
 @Return    :
 */
u8 MSPI_U8MasterTransmit(u8 Copy_u8SpiMessage)
{
    12ee:	df 93       	push	r29
    12f0:	cf 93       	push	r28
    12f2:	00 d0       	rcall	.+0      	; 0x12f4 <MSPI_U8MasterTransmit+0x6>
    12f4:	cd b7       	in	r28, 0x3d	; 61
    12f6:	de b7       	in	r29, 0x3e	; 62
    12f8:	8a 83       	std	Y+2, r24	; 0x02
	u8 dataRead=0;
    12fa:	19 82       	std	Y+1, r1	; 0x01
	SPDR = Copy_u8SpiMessage;
    12fc:	ef e2       	ldi	r30, 0x2F	; 47
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	8a 81       	ldd	r24, Y+2	; 0x02
    1302:	80 83       	st	Z, r24
	while(GET_BIT(SPSR, 7)==0);
    1304:	ee e2       	ldi	r30, 0x2E	; 46
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	80 81       	ld	r24, Z
    130a:	88 23       	and	r24, r24
    130c:	dc f7       	brge	.-10     	; 0x1304 <MSPI_U8MasterTransmit+0x16>
	dataRead = SPDR;
    130e:	ef e2       	ldi	r30, 0x2F	; 47
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	80 81       	ld	r24, Z
    1314:	89 83       	std	Y+1, r24	; 0x01
	return dataRead;
    1316:	89 81       	ldd	r24, Y+1	; 0x01
}
    1318:	0f 90       	pop	r0
    131a:	0f 90       	pop	r0
    131c:	cf 91       	pop	r28
    131e:	df 91       	pop	r29
    1320:	08 95       	ret

00001322 <EXTI_u8SetSource>:

static void (*INT0_Cbf_ptr)(void) = NULL;
static void (*INT1_Cbf_ptr)(void) = NULL;

//this function sets the interrupt source, it takes the external interrupt number and event;
u8 EXTI_u8SetSource(u8 Copy_u8INTx, u8 Copy_u8Source){
    1322:	df 93       	push	r29
    1324:	cf 93       	push	r28
    1326:	cd b7       	in	r28, 0x3d	; 61
    1328:	de b7       	in	r29, 0x3e	; 62
    132a:	2b 97       	sbiw	r28, 0x0b	; 11
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	de bf       	out	0x3e, r29	; 62
    1332:	0f be       	out	0x3f, r0	; 63
    1334:	cd bf       	out	0x3d, r28	; 61
    1336:	8a 83       	std	Y+2, r24	; 0x02
    1338:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Status = 0;
    133a:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8INTx){
    133c:	8a 81       	ldd	r24, Y+2	; 0x02
    133e:	28 2f       	mov	r18, r24
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	3b 87       	std	Y+11, r19	; 0x0b
    1344:	2a 87       	std	Y+10, r18	; 0x0a
    1346:	8a 85       	ldd	r24, Y+10	; 0x0a
    1348:	9b 85       	ldd	r25, Y+11	; 0x0b
    134a:	81 30       	cpi	r24, 0x01	; 1
    134c:	91 05       	cpc	r25, r1
    134e:	09 f4       	brne	.+2      	; 0x1352 <EXTI_u8SetSource+0x30>
    1350:	77 c0       	rjmp	.+238    	; 0x1440 <EXTI_u8SetSource+0x11e>
    1352:	2a 85       	ldd	r18, Y+10	; 0x0a
    1354:	3b 85       	ldd	r19, Y+11	; 0x0b
    1356:	22 30       	cpi	r18, 0x02	; 2
    1358:	31 05       	cpc	r19, r1
    135a:	09 f4       	brne	.+2      	; 0x135e <EXTI_u8SetSource+0x3c>
    135c:	dd c0       	rjmp	.+442    	; 0x1518 <EXTI_u8SetSource+0x1f6>
    135e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1360:	9b 85       	ldd	r25, Y+11	; 0x0b
    1362:	00 97       	sbiw	r24, 0x00	; 0
    1364:	09 f0       	breq	.+2      	; 0x1368 <EXTI_u8SetSource+0x46>
    1366:	09 c1       	rjmp	.+530    	; 0x157a <EXTI_u8SetSource+0x258>
	case EXTI_INT_0:
		CLR_BIT(EXTI_DDRD_REG, EXTI_PIN_2);  // make pd2 => input
    1368:	a1 e3       	ldi	r26, 0x31	; 49
    136a:	b0 e0       	ldi	r27, 0x00	; 0
    136c:	e1 e3       	ldi	r30, 0x31	; 49
    136e:	f0 e0       	ldi	r31, 0x00	; 0
    1370:	80 81       	ld	r24, Z
    1372:	8b 7f       	andi	r24, 0xFB	; 251
    1374:	8c 93       	st	X, r24
		SET_BIT(EXTI_PORTD_REG, EXTI_PIN_2);  //pull_up
    1376:	a2 e3       	ldi	r26, 0x32	; 50
    1378:	b0 e0       	ldi	r27, 0x00	; 0
    137a:	e2 e3       	ldi	r30, 0x32	; 50
    137c:	f0 e0       	ldi	r31, 0x00	; 0
    137e:	80 81       	ld	r24, Z
    1380:	84 60       	ori	r24, 0x04	; 4
    1382:	8c 93       	st	X, r24
		switch(Copy_u8Source){
    1384:	8b 81       	ldd	r24, Y+3	; 0x03
    1386:	28 2f       	mov	r18, r24
    1388:	30 e0       	ldi	r19, 0x00	; 0
    138a:	39 87       	std	Y+9, r19	; 0x09
    138c:	28 87       	std	Y+8, r18	; 0x08
    138e:	88 85       	ldd	r24, Y+8	; 0x08
    1390:	99 85       	ldd	r25, Y+9	; 0x09
    1392:	81 30       	cpi	r24, 0x01	; 1
    1394:	91 05       	cpc	r25, r1
    1396:	21 f1       	breq	.+72     	; 0x13e0 <EXTI_u8SetSource+0xbe>
    1398:	28 85       	ldd	r18, Y+8	; 0x08
    139a:	39 85       	ldd	r19, Y+9	; 0x09
    139c:	22 30       	cpi	r18, 0x02	; 2
    139e:	31 05       	cpc	r19, r1
    13a0:	2c f4       	brge	.+10     	; 0x13ac <EXTI_u8SetSource+0x8a>
    13a2:	88 85       	ldd	r24, Y+8	; 0x08
    13a4:	99 85       	ldd	r25, Y+9	; 0x09
    13a6:	00 97       	sbiw	r24, 0x00	; 0
    13a8:	61 f0       	breq	.+24     	; 0x13c2 <EXTI_u8SetSource+0xa0>
    13aa:	47 c0       	rjmp	.+142    	; 0x143a <EXTI_u8SetSource+0x118>
    13ac:	28 85       	ldd	r18, Y+8	; 0x08
    13ae:	39 85       	ldd	r19, Y+9	; 0x09
    13b0:	22 30       	cpi	r18, 0x02	; 2
    13b2:	31 05       	cpc	r19, r1
    13b4:	21 f1       	breq	.+72     	; 0x13fe <EXTI_u8SetSource+0xdc>
    13b6:	88 85       	ldd	r24, Y+8	; 0x08
    13b8:	99 85       	ldd	r25, Y+9	; 0x09
    13ba:	83 30       	cpi	r24, 0x03	; 3
    13bc:	91 05       	cpc	r25, r1
    13be:	71 f1       	breq	.+92     	; 0x141c <EXTI_u8SetSource+0xfa>
    13c0:	3c c0       	rjmp	.+120    	; 0x143a <EXTI_u8SetSource+0x118>
		case EXTI_LOW_LEVEL:
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_0);
    13c2:	a5 e5       	ldi	r26, 0x55	; 85
    13c4:	b0 e0       	ldi	r27, 0x00	; 0
    13c6:	e5 e5       	ldi	r30, 0x55	; 85
    13c8:	f0 e0       	ldi	r31, 0x00	; 0
    13ca:	80 81       	ld	r24, Z
    13cc:	8e 7f       	andi	r24, 0xFE	; 254
    13ce:	8c 93       	st	X, r24
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_1);
    13d0:	a5 e5       	ldi	r26, 0x55	; 85
    13d2:	b0 e0       	ldi	r27, 0x00	; 0
    13d4:	e5 e5       	ldi	r30, 0x55	; 85
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	80 81       	ld	r24, Z
    13da:	8d 7f       	andi	r24, 0xFD	; 253
    13dc:	8c 93       	st	X, r24
    13de:	cf c0       	rjmp	.+414    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_ANY_CHANGE:
			SET_BIT(EXTI_MCUCR_REG,  EXTI_PIN_0);
    13e0:	a5 e5       	ldi	r26, 0x55	; 85
    13e2:	b0 e0       	ldi	r27, 0x00	; 0
    13e4:	e5 e5       	ldi	r30, 0x55	; 85
    13e6:	f0 e0       	ldi	r31, 0x00	; 0
    13e8:	80 81       	ld	r24, Z
    13ea:	81 60       	ori	r24, 0x01	; 1
    13ec:	8c 93       	st	X, r24
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_1);
    13ee:	a5 e5       	ldi	r26, 0x55	; 85
    13f0:	b0 e0       	ldi	r27, 0x00	; 0
    13f2:	e5 e5       	ldi	r30, 0x55	; 85
    13f4:	f0 e0       	ldi	r31, 0x00	; 0
    13f6:	80 81       	ld	r24, Z
    13f8:	8d 7f       	andi	r24, 0xFD	; 253
    13fa:	8c 93       	st	X, r24
    13fc:	c0 c0       	rjmp	.+384    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_FALLING_EDGE:
			CLR_BIT(EXTI_MCUCR_REG,  EXTI_PIN_0);
    13fe:	a5 e5       	ldi	r26, 0x55	; 85
    1400:	b0 e0       	ldi	r27, 0x00	; 0
    1402:	e5 e5       	ldi	r30, 0x55	; 85
    1404:	f0 e0       	ldi	r31, 0x00	; 0
    1406:	80 81       	ld	r24, Z
    1408:	8e 7f       	andi	r24, 0xFE	; 254
    140a:	8c 93       	st	X, r24
			SET_BIT(EXTI_MCUCR_REG, EXTI_PIN_1);
    140c:	a5 e5       	ldi	r26, 0x55	; 85
    140e:	b0 e0       	ldi	r27, 0x00	; 0
    1410:	e5 e5       	ldi	r30, 0x55	; 85
    1412:	f0 e0       	ldi	r31, 0x00	; 0
    1414:	80 81       	ld	r24, Z
    1416:	82 60       	ori	r24, 0x02	; 2
    1418:	8c 93       	st	X, r24
    141a:	b1 c0       	rjmp	.+354    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_RISING_EDGE:
			SET_BIT(EXTI_MCUCR_REG,  EXTI_PIN_0);
    141c:	a5 e5       	ldi	r26, 0x55	; 85
    141e:	b0 e0       	ldi	r27, 0x00	; 0
    1420:	e5 e5       	ldi	r30, 0x55	; 85
    1422:	f0 e0       	ldi	r31, 0x00	; 0
    1424:	80 81       	ld	r24, Z
    1426:	81 60       	ori	r24, 0x01	; 1
    1428:	8c 93       	st	X, r24
			SET_BIT(EXTI_MCUCR_REG, EXTI_PIN_1);
    142a:	a5 e5       	ldi	r26, 0x55	; 85
    142c:	b0 e0       	ldi	r27, 0x00	; 0
    142e:	e5 e5       	ldi	r30, 0x55	; 85
    1430:	f0 e0       	ldi	r31, 0x00	; 0
    1432:	80 81       	ld	r24, Z
    1434:	82 60       	ori	r24, 0x02	; 2
    1436:	8c 93       	st	X, r24
    1438:	a2 c0       	rjmp	.+324    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		default:Local_u8Status = 1;
    143a:	81 e0       	ldi	r24, 0x01	; 1
    143c:	89 83       	std	Y+1, r24	; 0x01
    143e:	9f c0       	rjmp	.+318    	; 0x157e <EXTI_u8SetSource+0x25c>
		}
		break;

	case EXTI_INT_1:
		CLR_BIT(EXTI_DDRD_REG, EXTI_PIN_3);  // make pd2 => input
    1440:	a1 e3       	ldi	r26, 0x31	; 49
    1442:	b0 e0       	ldi	r27, 0x00	; 0
    1444:	e1 e3       	ldi	r30, 0x31	; 49
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	80 81       	ld	r24, Z
    144a:	87 7f       	andi	r24, 0xF7	; 247
    144c:	8c 93       	st	X, r24
		SET_BIT(EXTI_PORTD_REG, EXTI_PIN_3);  //pull_up
    144e:	a2 e3       	ldi	r26, 0x32	; 50
    1450:	b0 e0       	ldi	r27, 0x00	; 0
    1452:	e2 e3       	ldi	r30, 0x32	; 50
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	80 81       	ld	r24, Z
    1458:	88 60       	ori	r24, 0x08	; 8
    145a:	8c 93       	st	X, r24
		switch(Copy_u8Source){
    145c:	8b 81       	ldd	r24, Y+3	; 0x03
    145e:	28 2f       	mov	r18, r24
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	3f 83       	std	Y+7, r19	; 0x07
    1464:	2e 83       	std	Y+6, r18	; 0x06
    1466:	8e 81       	ldd	r24, Y+6	; 0x06
    1468:	9f 81       	ldd	r25, Y+7	; 0x07
    146a:	81 30       	cpi	r24, 0x01	; 1
    146c:	91 05       	cpc	r25, r1
    146e:	21 f1       	breq	.+72     	; 0x14b8 <EXTI_u8SetSource+0x196>
    1470:	2e 81       	ldd	r18, Y+6	; 0x06
    1472:	3f 81       	ldd	r19, Y+7	; 0x07
    1474:	22 30       	cpi	r18, 0x02	; 2
    1476:	31 05       	cpc	r19, r1
    1478:	2c f4       	brge	.+10     	; 0x1484 <EXTI_u8SetSource+0x162>
    147a:	8e 81       	ldd	r24, Y+6	; 0x06
    147c:	9f 81       	ldd	r25, Y+7	; 0x07
    147e:	00 97       	sbiw	r24, 0x00	; 0
    1480:	61 f0       	breq	.+24     	; 0x149a <EXTI_u8SetSource+0x178>
    1482:	47 c0       	rjmp	.+142    	; 0x1512 <EXTI_u8SetSource+0x1f0>
    1484:	2e 81       	ldd	r18, Y+6	; 0x06
    1486:	3f 81       	ldd	r19, Y+7	; 0x07
    1488:	22 30       	cpi	r18, 0x02	; 2
    148a:	31 05       	cpc	r19, r1
    148c:	21 f1       	breq	.+72     	; 0x14d6 <EXTI_u8SetSource+0x1b4>
    148e:	8e 81       	ldd	r24, Y+6	; 0x06
    1490:	9f 81       	ldd	r25, Y+7	; 0x07
    1492:	83 30       	cpi	r24, 0x03	; 3
    1494:	91 05       	cpc	r25, r1
    1496:	71 f1       	breq	.+92     	; 0x14f4 <EXTI_u8SetSource+0x1d2>
    1498:	3c c0       	rjmp	.+120    	; 0x1512 <EXTI_u8SetSource+0x1f0>
		case EXTI_LOW_LEVEL:
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_2);
    149a:	a5 e5       	ldi	r26, 0x55	; 85
    149c:	b0 e0       	ldi	r27, 0x00	; 0
    149e:	e5 e5       	ldi	r30, 0x55	; 85
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	80 81       	ld	r24, Z
    14a4:	8b 7f       	andi	r24, 0xFB	; 251
    14a6:	8c 93       	st	X, r24
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_3);
    14a8:	a5 e5       	ldi	r26, 0x55	; 85
    14aa:	b0 e0       	ldi	r27, 0x00	; 0
    14ac:	e5 e5       	ldi	r30, 0x55	; 85
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	80 81       	ld	r24, Z
    14b2:	87 7f       	andi	r24, 0xF7	; 247
    14b4:	8c 93       	st	X, r24
    14b6:	63 c0       	rjmp	.+198    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_ANY_CHANGE:
			SET_BIT(EXTI_MCUCR_REG,  EXTI_PIN_2);
    14b8:	a5 e5       	ldi	r26, 0x55	; 85
    14ba:	b0 e0       	ldi	r27, 0x00	; 0
    14bc:	e5 e5       	ldi	r30, 0x55	; 85
    14be:	f0 e0       	ldi	r31, 0x00	; 0
    14c0:	80 81       	ld	r24, Z
    14c2:	84 60       	ori	r24, 0x04	; 4
    14c4:	8c 93       	st	X, r24
			CLR_BIT(EXTI_MCUCR_REG, EXTI_PIN_3);
    14c6:	a5 e5       	ldi	r26, 0x55	; 85
    14c8:	b0 e0       	ldi	r27, 0x00	; 0
    14ca:	e5 e5       	ldi	r30, 0x55	; 85
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	80 81       	ld	r24, Z
    14d0:	87 7f       	andi	r24, 0xF7	; 247
    14d2:	8c 93       	st	X, r24
    14d4:	54 c0       	rjmp	.+168    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_FALLING_EDGE:
			CLR_BIT(EXTI_MCUCR_REG,  EXTI_PIN_2);
    14d6:	a5 e5       	ldi	r26, 0x55	; 85
    14d8:	b0 e0       	ldi	r27, 0x00	; 0
    14da:	e5 e5       	ldi	r30, 0x55	; 85
    14dc:	f0 e0       	ldi	r31, 0x00	; 0
    14de:	80 81       	ld	r24, Z
    14e0:	8b 7f       	andi	r24, 0xFB	; 251
    14e2:	8c 93       	st	X, r24
			SET_BIT(EXTI_MCUCR_REG, EXTI_PIN_3);
    14e4:	a5 e5       	ldi	r26, 0x55	; 85
    14e6:	b0 e0       	ldi	r27, 0x00	; 0
    14e8:	e5 e5       	ldi	r30, 0x55	; 85
    14ea:	f0 e0       	ldi	r31, 0x00	; 0
    14ec:	80 81       	ld	r24, Z
    14ee:	88 60       	ori	r24, 0x08	; 8
    14f0:	8c 93       	st	X, r24
    14f2:	45 c0       	rjmp	.+138    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_RISING_EDGE:
			SET_BIT(EXTI_MCUCR_REG,  EXTI_PIN_2);
    14f4:	a5 e5       	ldi	r26, 0x55	; 85
    14f6:	b0 e0       	ldi	r27, 0x00	; 0
    14f8:	e5 e5       	ldi	r30, 0x55	; 85
    14fa:	f0 e0       	ldi	r31, 0x00	; 0
    14fc:	80 81       	ld	r24, Z
    14fe:	84 60       	ori	r24, 0x04	; 4
    1500:	8c 93       	st	X, r24
			SET_BIT(EXTI_MCUCR_REG, EXTI_PIN_3);
    1502:	a5 e5       	ldi	r26, 0x55	; 85
    1504:	b0 e0       	ldi	r27, 0x00	; 0
    1506:	e5 e5       	ldi	r30, 0x55	; 85
    1508:	f0 e0       	ldi	r31, 0x00	; 0
    150a:	80 81       	ld	r24, Z
    150c:	88 60       	ori	r24, 0x08	; 8
    150e:	8c 93       	st	X, r24
    1510:	36 c0       	rjmp	.+108    	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		default:Local_u8Status = 1;
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	89 83       	std	Y+1, r24	; 0x01
    1516:	33 c0       	rjmp	.+102    	; 0x157e <EXTI_u8SetSource+0x25c>
		}
		break;

	case EXTI_INT_2:
		CLR_BIT(EXTI_DDRB_REG, EXTI_PIN_2);  // make pd2 => input
    1518:	a7 e3       	ldi	r26, 0x37	; 55
    151a:	b0 e0       	ldi	r27, 0x00	; 0
    151c:	e7 e3       	ldi	r30, 0x37	; 55
    151e:	f0 e0       	ldi	r31, 0x00	; 0
    1520:	80 81       	ld	r24, Z
    1522:	8b 7f       	andi	r24, 0xFB	; 251
    1524:	8c 93       	st	X, r24
		SET_BIT(EXTI_PORTB_REG, EXTI_PIN_2);  //pull_up
    1526:	a8 e3       	ldi	r26, 0x38	; 56
    1528:	b0 e0       	ldi	r27, 0x00	; 0
    152a:	e8 e3       	ldi	r30, 0x38	; 56
    152c:	f0 e0       	ldi	r31, 0x00	; 0
    152e:	80 81       	ld	r24, Z
    1530:	84 60       	ori	r24, 0x04	; 4
    1532:	8c 93       	st	X, r24
		switch(Copy_u8Source){
    1534:	8b 81       	ldd	r24, Y+3	; 0x03
    1536:	28 2f       	mov	r18, r24
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	3d 83       	std	Y+5, r19	; 0x05
    153c:	2c 83       	std	Y+4, r18	; 0x04
    153e:	8c 81       	ldd	r24, Y+4	; 0x04
    1540:	9d 81       	ldd	r25, Y+5	; 0x05
    1542:	82 30       	cpi	r24, 0x02	; 2
    1544:	91 05       	cpc	r25, r1
    1546:	31 f0       	breq	.+12     	; 0x1554 <EXTI_u8SetSource+0x232>
    1548:	2c 81       	ldd	r18, Y+4	; 0x04
    154a:	3d 81       	ldd	r19, Y+5	; 0x05
    154c:	23 30       	cpi	r18, 0x03	; 3
    154e:	31 05       	cpc	r19, r1
    1550:	49 f0       	breq	.+18     	; 0x1564 <EXTI_u8SetSource+0x242>
    1552:	10 c0       	rjmp	.+32     	; 0x1574 <EXTI_u8SetSource+0x252>
		case EXTI_FALLING_EDGE:
			CLR_BIT(EXTI_MCUCSR_REG,  EXTI_PIN_6);
    1554:	a4 e5       	ldi	r26, 0x54	; 84
    1556:	b0 e0       	ldi	r27, 0x00	; 0
    1558:	e4 e5       	ldi	r30, 0x54	; 84
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	80 81       	ld	r24, Z
    155e:	8f 7b       	andi	r24, 0xBF	; 191
    1560:	8c 93       	st	X, r24
    1562:	0d c0       	rjmp	.+26     	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		case EXTI_RISING_EDGE:
			SET_BIT(EXTI_MCUCSR_REG, EXTI_PIN_6);
    1564:	a4 e5       	ldi	r26, 0x54	; 84
    1566:	b0 e0       	ldi	r27, 0x00	; 0
    1568:	e4 e5       	ldi	r30, 0x54	; 84
    156a:	f0 e0       	ldi	r31, 0x00	; 0
    156c:	80 81       	ld	r24, Z
    156e:	80 64       	ori	r24, 0x40	; 64
    1570:	8c 93       	st	X, r24
    1572:	05 c0       	rjmp	.+10     	; 0x157e <EXTI_u8SetSource+0x25c>
			break;
		default:Local_u8Status = 1;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	89 83       	std	Y+1, r24	; 0x01
    1578:	02 c0       	rjmp	.+4      	; 0x157e <EXTI_u8SetSource+0x25c>
		}
		break;
		default: Local_u8Status = 1;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	89 83       	std	Y+1, r24	; 0x01
				SET_BIT(MCUCSR, PIN_6);
				break;
			default: Local_u8Status = 1;
			}
		}*/
	return Local_u8Status;
    157e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1580:	2b 96       	adiw	r28, 0x0b	; 11
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	de bf       	out	0x3e, r29	; 62
    1588:	0f be       	out	0x3f, r0	; 63
    158a:	cd bf       	out	0x3d, r28	; 61
    158c:	cf 91       	pop	r28
    158e:	df 91       	pop	r29
    1590:	08 95       	ret

00001592 <EXTI_u8EnablePIE>:

/*
	this function used to enable the PIE (set the corresponding bit in GICR to 1),
	it takes the external interrupt number;
 */
u8 EXTI_u8EnablePIE(u8 Copy_u8INTx){
    1592:	df 93       	push	r29
    1594:	cf 93       	push	r28
    1596:	00 d0       	rcall	.+0      	; 0x1598 <EXTI_u8EnablePIE+0x6>
    1598:	00 d0       	rcall	.+0      	; 0x159a <EXTI_u8EnablePIE+0x8>
    159a:	cd b7       	in	r28, 0x3d	; 61
    159c:	de b7       	in	r29, 0x3e	; 62
    159e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Status = 0;
    15a0:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8INTx){
    15a2:	8a 81       	ldd	r24, Y+2	; 0x02
    15a4:	28 2f       	mov	r18, r24
    15a6:	30 e0       	ldi	r19, 0x00	; 0
    15a8:	3c 83       	std	Y+4, r19	; 0x04
    15aa:	2b 83       	std	Y+3, r18	; 0x03
    15ac:	8b 81       	ldd	r24, Y+3	; 0x03
    15ae:	9c 81       	ldd	r25, Y+4	; 0x04
    15b0:	81 30       	cpi	r24, 0x01	; 1
    15b2:	91 05       	cpc	r25, r1
    15b4:	89 f0       	breq	.+34     	; 0x15d8 <EXTI_u8EnablePIE+0x46>
    15b6:	2b 81       	ldd	r18, Y+3	; 0x03
    15b8:	3c 81       	ldd	r19, Y+4	; 0x04
    15ba:	22 30       	cpi	r18, 0x02	; 2
    15bc:	31 05       	cpc	r19, r1
    15be:	a1 f0       	breq	.+40     	; 0x15e8 <EXTI_u8EnablePIE+0x56>
    15c0:	8b 81       	ldd	r24, Y+3	; 0x03
    15c2:	9c 81       	ldd	r25, Y+4	; 0x04
    15c4:	00 97       	sbiw	r24, 0x00	; 0
    15c6:	c1 f4       	brne	.+48     	; 0x15f8 <EXTI_u8EnablePIE+0x66>
	case EXTI_INT_0:
		SET_BIT(EXTI_GICR_REG, EXTI_PIN_6);
    15c8:	ab e5       	ldi	r26, 0x5B	; 91
    15ca:	b0 e0       	ldi	r27, 0x00	; 0
    15cc:	eb e5       	ldi	r30, 0x5B	; 91
    15ce:	f0 e0       	ldi	r31, 0x00	; 0
    15d0:	80 81       	ld	r24, Z
    15d2:	80 64       	ori	r24, 0x40	; 64
    15d4:	8c 93       	st	X, r24
    15d6:	12 c0       	rjmp	.+36     	; 0x15fc <EXTI_u8EnablePIE+0x6a>
		break;
	case EXTI_INT_1:
		SET_BIT(EXTI_GICR_REG, EXTI_PIN_7);
    15d8:	ab e5       	ldi	r26, 0x5B	; 91
    15da:	b0 e0       	ldi	r27, 0x00	; 0
    15dc:	eb e5       	ldi	r30, 0x5B	; 91
    15de:	f0 e0       	ldi	r31, 0x00	; 0
    15e0:	80 81       	ld	r24, Z
    15e2:	80 68       	ori	r24, 0x80	; 128
    15e4:	8c 93       	st	X, r24
    15e6:	0a c0       	rjmp	.+20     	; 0x15fc <EXTI_u8EnablePIE+0x6a>
		break;
	case EXTI_INT_2:
		SET_BIT(EXTI_GICR_REG, EXTI_PIN_5);
    15e8:	ab e5       	ldi	r26, 0x5B	; 91
    15ea:	b0 e0       	ldi	r27, 0x00	; 0
    15ec:	eb e5       	ldi	r30, 0x5B	; 91
    15ee:	f0 e0       	ldi	r31, 0x00	; 0
    15f0:	80 81       	ld	r24, Z
    15f2:	80 62       	ori	r24, 0x20	; 32
    15f4:	8c 93       	st	X, r24
    15f6:	02 c0       	rjmp	.+4      	; 0x15fc <EXTI_u8EnablePIE+0x6a>
		break;
	default: Local_u8Status = 1;
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8Status;
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    15fe:	0f 90       	pop	r0
    1600:	0f 90       	pop	r0
    1602:	0f 90       	pop	r0
    1604:	0f 90       	pop	r0
    1606:	cf 91       	pop	r28
    1608:	df 91       	pop	r29
    160a:	08 95       	ret

0000160c <EXTI_u8DisablePIE>:

/*
	this function used to enable the PIE (set the corresponding bit in GICR to 1),
	it takes the external interrupt number;
 */
u8 EXTI_u8DisablePIE(u8 Copy_u8INTx){
    160c:	df 93       	push	r29
    160e:	cf 93       	push	r28
    1610:	00 d0       	rcall	.+0      	; 0x1612 <EXTI_u8DisablePIE+0x6>
    1612:	00 d0       	rcall	.+0      	; 0x1614 <EXTI_u8DisablePIE+0x8>
    1614:	cd b7       	in	r28, 0x3d	; 61
    1616:	de b7       	in	r29, 0x3e	; 62
    1618:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Status = 0;
    161a:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8INTx){
    161c:	8a 81       	ldd	r24, Y+2	; 0x02
    161e:	28 2f       	mov	r18, r24
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	3c 83       	std	Y+4, r19	; 0x04
    1624:	2b 83       	std	Y+3, r18	; 0x03
    1626:	8b 81       	ldd	r24, Y+3	; 0x03
    1628:	9c 81       	ldd	r25, Y+4	; 0x04
    162a:	81 30       	cpi	r24, 0x01	; 1
    162c:	91 05       	cpc	r25, r1
    162e:	89 f0       	breq	.+34     	; 0x1652 <EXTI_u8DisablePIE+0x46>
    1630:	2b 81       	ldd	r18, Y+3	; 0x03
    1632:	3c 81       	ldd	r19, Y+4	; 0x04
    1634:	22 30       	cpi	r18, 0x02	; 2
    1636:	31 05       	cpc	r19, r1
    1638:	a1 f0       	breq	.+40     	; 0x1662 <EXTI_u8DisablePIE+0x56>
    163a:	8b 81       	ldd	r24, Y+3	; 0x03
    163c:	9c 81       	ldd	r25, Y+4	; 0x04
    163e:	00 97       	sbiw	r24, 0x00	; 0
    1640:	c1 f4       	brne	.+48     	; 0x1672 <EXTI_u8DisablePIE+0x66>
	case EXTI_INT_0:
		CLR_BIT(EXTI_GICR_REG, EXTI_PIN_6);
    1642:	ab e5       	ldi	r26, 0x5B	; 91
    1644:	b0 e0       	ldi	r27, 0x00	; 0
    1646:	eb e5       	ldi	r30, 0x5B	; 91
    1648:	f0 e0       	ldi	r31, 0x00	; 0
    164a:	80 81       	ld	r24, Z
    164c:	8f 7b       	andi	r24, 0xBF	; 191
    164e:	8c 93       	st	X, r24
    1650:	12 c0       	rjmp	.+36     	; 0x1676 <EXTI_u8DisablePIE+0x6a>
		break;
	case EXTI_INT_1:
		CLR_BIT(EXTI_GICR_REG, EXTI_PIN_7);
    1652:	ab e5       	ldi	r26, 0x5B	; 91
    1654:	b0 e0       	ldi	r27, 0x00	; 0
    1656:	eb e5       	ldi	r30, 0x5B	; 91
    1658:	f0 e0       	ldi	r31, 0x00	; 0
    165a:	80 81       	ld	r24, Z
    165c:	8f 77       	andi	r24, 0x7F	; 127
    165e:	8c 93       	st	X, r24
    1660:	0a c0       	rjmp	.+20     	; 0x1676 <EXTI_u8DisablePIE+0x6a>
		break;
	case EXTI_INT_2:
		CLR_BIT(EXTI_GICR_REG, EXTI_PIN_5);
    1662:	ab e5       	ldi	r26, 0x5B	; 91
    1664:	b0 e0       	ldi	r27, 0x00	; 0
    1666:	eb e5       	ldi	r30, 0x5B	; 91
    1668:	f0 e0       	ldi	r31, 0x00	; 0
    166a:	80 81       	ld	r24, Z
    166c:	8f 7d       	andi	r24, 0xDF	; 223
    166e:	8c 93       	st	X, r24
    1670:	02 c0       	rjmp	.+4      	; 0x1676 <EXTI_u8DisablePIE+0x6a>
		break;
	default: Local_u8Status = 1;
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8Status;
    1676:	89 81       	ldd	r24, Y+1	; 0x01
}
    1678:	0f 90       	pop	r0
    167a:	0f 90       	pop	r0
    167c:	0f 90       	pop	r0
    167e:	0f 90       	pop	r0
    1680:	cf 91       	pop	r28
    1682:	df 91       	pop	r29
    1684:	08 95       	ret

00001686 <EXTI_voidEnableGIE>:

//this function used to enable the GIE (set the I_bit in SREG to 1)
void EXTI_voidEnableGIE(){
    1686:	df 93       	push	r29
    1688:	cf 93       	push	r28
    168a:	cd b7       	in	r28, 0x3d	; 61
    168c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(EXTI_SREG_REG, EXTI_PIN_7);
    168e:	af e5       	ldi	r26, 0x5F	; 95
    1690:	b0 e0       	ldi	r27, 0x00	; 0
    1692:	ef e5       	ldi	r30, 0x5F	; 95
    1694:	f0 e0       	ldi	r31, 0x00	; 0
    1696:	80 81       	ld	r24, Z
    1698:	80 68       	ori	r24, 0x80	; 128
    169a:	8c 93       	st	X, r24
}
    169c:	cf 91       	pop	r28
    169e:	df 91       	pop	r29
    16a0:	08 95       	ret

000016a2 <EXTI_voidDisableGIE>:

//this function used to disable the GIE (set the I_bit in SREG to 0)
void EXTI_voidDisableGIE(){
    16a2:	df 93       	push	r29
    16a4:	cf 93       	push	r28
    16a6:	cd b7       	in	r28, 0x3d	; 61
    16a8:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(EXTI_SREG_REG, EXTI_PIN_7);
    16aa:	af e5       	ldi	r26, 0x5F	; 95
    16ac:	b0 e0       	ldi	r27, 0x00	; 0
    16ae:	ef e5       	ldi	r30, 0x5F	; 95
    16b0:	f0 e0       	ldi	r31, 0x00	; 0
    16b2:	80 81       	ld	r24, Z
    16b4:	8f 77       	andi	r24, 0x7F	; 127
    16b6:	8c 93       	st	X, r24
}
    16b8:	cf 91       	pop	r28
    16ba:	df 91       	pop	r29
    16bc:	08 95       	ret

000016be <EXTI_voidSet_INT0_Cbf>:

//This function used to set INT0 call back function.
void EXTI_voidSet_INT0_Cbf(void (*fptr)(void)){
    16be:	df 93       	push	r29
    16c0:	cf 93       	push	r28
    16c2:	00 d0       	rcall	.+0      	; 0x16c4 <EXTI_voidSet_INT0_Cbf+0x6>
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	9a 83       	std	Y+2, r25	; 0x02
    16ca:	89 83       	std	Y+1, r24	; 0x01
	if(fptr != NULL){
    16cc:	89 81       	ldd	r24, Y+1	; 0x01
    16ce:	9a 81       	ldd	r25, Y+2	; 0x02
    16d0:	00 97       	sbiw	r24, 0x00	; 0
    16d2:	31 f0       	breq	.+12     	; 0x16e0 <EXTI_voidSet_INT0_Cbf+0x22>
		INT0_Cbf_ptr = fptr;
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	9a 81       	ldd	r25, Y+2	; 0x02
    16d8:	90 93 a1 01 	sts	0x01A1, r25
    16dc:	80 93 a0 01 	sts	0x01A0, r24
	}
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	cf 91       	pop	r28
    16e6:	df 91       	pop	r29
    16e8:	08 95       	ret

000016ea <EXTI_voidSet_INT1_Cbf>:

//This function used to set INT1 call back function.
void EXTI_voidSet_INT1_Cbf(void (*fptr)(void))
{
    16ea:	df 93       	push	r29
    16ec:	cf 93       	push	r28
    16ee:	00 d0       	rcall	.+0      	; 0x16f0 <EXTI_voidSet_INT1_Cbf+0x6>
    16f0:	cd b7       	in	r28, 0x3d	; 61
    16f2:	de b7       	in	r29, 0x3e	; 62
    16f4:	9a 83       	std	Y+2, r25	; 0x02
    16f6:	89 83       	std	Y+1, r24	; 0x01
	if(fptr != NULL)
    16f8:	89 81       	ldd	r24, Y+1	; 0x01
    16fa:	9a 81       	ldd	r25, Y+2	; 0x02
    16fc:	00 97       	sbiw	r24, 0x00	; 0
    16fe:	31 f0       	breq	.+12     	; 0x170c <EXTI_voidSet_INT1_Cbf+0x22>
	{
		INT1_Cbf_ptr = fptr;
    1700:	89 81       	ldd	r24, Y+1	; 0x01
    1702:	9a 81       	ldd	r25, Y+2	; 0x02
    1704:	90 93 a3 01 	sts	0x01A3, r25
    1708:	80 93 a2 01 	sts	0x01A2, r24
	}
}
    170c:	0f 90       	pop	r0
    170e:	0f 90       	pop	r0
    1710:	cf 91       	pop	r28
    1712:	df 91       	pop	r29
    1714:	08 95       	ret

00001716 <__vector_1>:

ISR(INT0_vect){
    1716:	1f 92       	push	r1
    1718:	0f 92       	push	r0
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	0f 92       	push	r0
    171e:	11 24       	eor	r1, r1
    1720:	2f 93       	push	r18
    1722:	3f 93       	push	r19
    1724:	4f 93       	push	r20
    1726:	5f 93       	push	r21
    1728:	6f 93       	push	r22
    172a:	7f 93       	push	r23
    172c:	8f 93       	push	r24
    172e:	9f 93       	push	r25
    1730:	af 93       	push	r26
    1732:	bf 93       	push	r27
    1734:	ef 93       	push	r30
    1736:	ff 93       	push	r31
    1738:	df 93       	push	r29
    173a:	cf 93       	push	r28
    173c:	cd b7       	in	r28, 0x3d	; 61
    173e:	de b7       	in	r29, 0x3e	; 62
	if(INT0_Cbf_ptr != NULL){
    1740:	80 91 a0 01 	lds	r24, 0x01A0
    1744:	90 91 a1 01 	lds	r25, 0x01A1
    1748:	00 97       	sbiw	r24, 0x00	; 0
    174a:	29 f0       	breq	.+10     	; 0x1756 <__vector_1+0x40>
		INT0_Cbf_ptr();
    174c:	e0 91 a0 01 	lds	r30, 0x01A0
    1750:	f0 91 a1 01 	lds	r31, 0x01A1
    1754:	09 95       	icall
	}
}
    1756:	cf 91       	pop	r28
    1758:	df 91       	pop	r29
    175a:	ff 91       	pop	r31
    175c:	ef 91       	pop	r30
    175e:	bf 91       	pop	r27
    1760:	af 91       	pop	r26
    1762:	9f 91       	pop	r25
    1764:	8f 91       	pop	r24
    1766:	7f 91       	pop	r23
    1768:	6f 91       	pop	r22
    176a:	5f 91       	pop	r21
    176c:	4f 91       	pop	r20
    176e:	3f 91       	pop	r19
    1770:	2f 91       	pop	r18
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63
    1776:	0f 90       	pop	r0
    1778:	1f 90       	pop	r1
    177a:	18 95       	reti

0000177c <__vector_2>:

ISR(INT1_vect){
    177c:	1f 92       	push	r1
    177e:	0f 92       	push	r0
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	0f 92       	push	r0
    1784:	11 24       	eor	r1, r1
    1786:	2f 93       	push	r18
    1788:	3f 93       	push	r19
    178a:	4f 93       	push	r20
    178c:	5f 93       	push	r21
    178e:	6f 93       	push	r22
    1790:	7f 93       	push	r23
    1792:	8f 93       	push	r24
    1794:	9f 93       	push	r25
    1796:	af 93       	push	r26
    1798:	bf 93       	push	r27
    179a:	ef 93       	push	r30
    179c:	ff 93       	push	r31
    179e:	df 93       	push	r29
    17a0:	cf 93       	push	r28
    17a2:	cd b7       	in	r28, 0x3d	; 61
    17a4:	de b7       	in	r29, 0x3e	; 62
	if(INT1_Cbf_ptr != NULL)
    17a6:	80 91 a2 01 	lds	r24, 0x01A2
    17aa:	90 91 a3 01 	lds	r25, 0x01A3
    17ae:	00 97       	sbiw	r24, 0x00	; 0
    17b0:	29 f0       	breq	.+10     	; 0x17bc <__vector_2+0x40>
	{
		INT1_Cbf_ptr();
    17b2:	e0 91 a2 01 	lds	r30, 0x01A2
    17b6:	f0 91 a3 01 	lds	r31, 0x01A3
    17ba:	09 95       	icall
	}
}
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	ff 91       	pop	r31
    17c2:	ef 91       	pop	r30
    17c4:	bf 91       	pop	r27
    17c6:	af 91       	pop	r26
    17c8:	9f 91       	pop	r25
    17ca:	8f 91       	pop	r24
    17cc:	7f 91       	pop	r23
    17ce:	6f 91       	pop	r22
    17d0:	5f 91       	pop	r21
    17d2:	4f 91       	pop	r20
    17d4:	3f 91       	pop	r19
    17d6:	2f 91       	pop	r18
    17d8:	0f 90       	pop	r0
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	0f 90       	pop	r0
    17de:	1f 90       	pop	r1
    17e0:	18 95       	reti

000017e2 <DIO_u8setPortDir>:
#include"DIO_init.h"


//PORT Functions
//set PORT direction
u8 DIO_u8setPortDir(u8 Copy_u8port, u8 Copy_u8dir){
    17e2:	df 93       	push	r29
    17e4:	cf 93       	push	r28
    17e6:	00 d0       	rcall	.+0      	; 0x17e8 <DIO_u8setPortDir+0x6>
    17e8:	00 d0       	rcall	.+0      	; 0x17ea <DIO_u8setPortDir+0x8>
    17ea:	0f 92       	push	r0
    17ec:	cd b7       	in	r28, 0x3d	; 61
    17ee:	de b7       	in	r29, 0x3e	; 62
    17f0:	8a 83       	std	Y+2, r24	; 0x02
    17f2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8statues = 0;
    17f4:	19 82       	std	Y+1, r1	; 0x01
	switch (Copy_u8port){
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	28 2f       	mov	r18, r24
    17fa:	30 e0       	ldi	r19, 0x00	; 0
    17fc:	3d 83       	std	Y+5, r19	; 0x05
    17fe:	2c 83       	std	Y+4, r18	; 0x04
    1800:	8c 81       	ldd	r24, Y+4	; 0x04
    1802:	9d 81       	ldd	r25, Y+5	; 0x05
    1804:	81 30       	cpi	r24, 0x01	; 1
    1806:	91 05       	cpc	r25, r1
    1808:	d1 f0       	breq	.+52     	; 0x183e <DIO_u8setPortDir+0x5c>
    180a:	2c 81       	ldd	r18, Y+4	; 0x04
    180c:	3d 81       	ldd	r19, Y+5	; 0x05
    180e:	22 30       	cpi	r18, 0x02	; 2
    1810:	31 05       	cpc	r19, r1
    1812:	2c f4       	brge	.+10     	; 0x181e <DIO_u8setPortDir+0x3c>
    1814:	8c 81       	ldd	r24, Y+4	; 0x04
    1816:	9d 81       	ldd	r25, Y+5	; 0x05
    1818:	00 97       	sbiw	r24, 0x00	; 0
    181a:	61 f0       	breq	.+24     	; 0x1834 <DIO_u8setPortDir+0x52>
    181c:	1f c0       	rjmp	.+62     	; 0x185c <DIO_u8setPortDir+0x7a>
    181e:	2c 81       	ldd	r18, Y+4	; 0x04
    1820:	3d 81       	ldd	r19, Y+5	; 0x05
    1822:	22 30       	cpi	r18, 0x02	; 2
    1824:	31 05       	cpc	r19, r1
    1826:	81 f0       	breq	.+32     	; 0x1848 <DIO_u8setPortDir+0x66>
    1828:	8c 81       	ldd	r24, Y+4	; 0x04
    182a:	9d 81       	ldd	r25, Y+5	; 0x05
    182c:	83 30       	cpi	r24, 0x03	; 3
    182e:	91 05       	cpc	r25, r1
    1830:	81 f0       	breq	.+32     	; 0x1852 <DIO_u8setPortDir+0x70>
    1832:	14 c0       	rjmp	.+40     	; 0x185c <DIO_u8setPortDir+0x7a>
	case DIO_PORT_A:	DDRA_REG = Copy_u8dir;  break;
    1834:	ea e3       	ldi	r30, 0x3A	; 58
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	8b 81       	ldd	r24, Y+3	; 0x03
    183a:	80 83       	st	Z, r24
    183c:	11 c0       	rjmp	.+34     	; 0x1860 <DIO_u8setPortDir+0x7e>
	case DIO_PORT_B:	DDRB_REG = Copy_u8dir;  break;
    183e:	e7 e3       	ldi	r30, 0x37	; 55
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	8b 81       	ldd	r24, Y+3	; 0x03
    1844:	80 83       	st	Z, r24
    1846:	0c c0       	rjmp	.+24     	; 0x1860 <DIO_u8setPortDir+0x7e>
	case DIO_PORT_C:	DDRC_REG = Copy_u8dir;  break;
    1848:	e4 e3       	ldi	r30, 0x34	; 52
    184a:	f0 e0       	ldi	r31, 0x00	; 0
    184c:	8b 81       	ldd	r24, Y+3	; 0x03
    184e:	80 83       	st	Z, r24
    1850:	07 c0       	rjmp	.+14     	; 0x1860 <DIO_u8setPortDir+0x7e>
	case DIO_PORT_D:	DDRD_REG = Copy_u8dir;  break;
    1852:	e1 e3       	ldi	r30, 0x31	; 49
    1854:	f0 e0       	ldi	r31, 0x00	; 0
    1856:	8b 81       	ldd	r24, Y+3	; 0x03
    1858:	80 83       	st	Z, r24
    185a:	02 c0       	rjmp	.+4      	; 0x1860 <DIO_u8setPortDir+0x7e>

	default: Local_u8statues = 1;
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8statues;
    1860:	89 81       	ldd	r24, Y+1	; 0x01
}
    1862:	0f 90       	pop	r0
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	0f 90       	pop	r0
    186c:	cf 91       	pop	r28
    186e:	df 91       	pop	r29
    1870:	08 95       	ret

00001872 <DIO_u8setPortVal>:

//set PORT value
u8 DIO_u8setPortVal(u8 Copy_u8port, u8 Copy_u8val)
{
    1872:	df 93       	push	r29
    1874:	cf 93       	push	r28
    1876:	00 d0       	rcall	.+0      	; 0x1878 <DIO_u8setPortVal+0x6>
    1878:	00 d0       	rcall	.+0      	; 0x187a <DIO_u8setPortVal+0x8>
    187a:	0f 92       	push	r0
    187c:	cd b7       	in	r28, 0x3d	; 61
    187e:	de b7       	in	r29, 0x3e	; 62
    1880:	8a 83       	std	Y+2, r24	; 0x02
    1882:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8statues = 0;
    1884:	19 82       	std	Y+1, r1	; 0x01
	switch (Copy_u8port){
    1886:	8a 81       	ldd	r24, Y+2	; 0x02
    1888:	28 2f       	mov	r18, r24
    188a:	30 e0       	ldi	r19, 0x00	; 0
    188c:	3d 83       	std	Y+5, r19	; 0x05
    188e:	2c 83       	std	Y+4, r18	; 0x04
    1890:	8c 81       	ldd	r24, Y+4	; 0x04
    1892:	9d 81       	ldd	r25, Y+5	; 0x05
    1894:	81 30       	cpi	r24, 0x01	; 1
    1896:	91 05       	cpc	r25, r1
    1898:	d1 f0       	breq	.+52     	; 0x18ce <DIO_u8setPortVal+0x5c>
    189a:	2c 81       	ldd	r18, Y+4	; 0x04
    189c:	3d 81       	ldd	r19, Y+5	; 0x05
    189e:	22 30       	cpi	r18, 0x02	; 2
    18a0:	31 05       	cpc	r19, r1
    18a2:	2c f4       	brge	.+10     	; 0x18ae <DIO_u8setPortVal+0x3c>
    18a4:	8c 81       	ldd	r24, Y+4	; 0x04
    18a6:	9d 81       	ldd	r25, Y+5	; 0x05
    18a8:	00 97       	sbiw	r24, 0x00	; 0
    18aa:	61 f0       	breq	.+24     	; 0x18c4 <DIO_u8setPortVal+0x52>
    18ac:	1f c0       	rjmp	.+62     	; 0x18ec <DIO_u8setPortVal+0x7a>
    18ae:	2c 81       	ldd	r18, Y+4	; 0x04
    18b0:	3d 81       	ldd	r19, Y+5	; 0x05
    18b2:	22 30       	cpi	r18, 0x02	; 2
    18b4:	31 05       	cpc	r19, r1
    18b6:	81 f0       	breq	.+32     	; 0x18d8 <DIO_u8setPortVal+0x66>
    18b8:	8c 81       	ldd	r24, Y+4	; 0x04
    18ba:	9d 81       	ldd	r25, Y+5	; 0x05
    18bc:	83 30       	cpi	r24, 0x03	; 3
    18be:	91 05       	cpc	r25, r1
    18c0:	81 f0       	breq	.+32     	; 0x18e2 <DIO_u8setPortVal+0x70>
    18c2:	14 c0       	rjmp	.+40     	; 0x18ec <DIO_u8setPortVal+0x7a>
	case DIO_PORT_A:	PORTA_REG = Copy_u8val;  break;
    18c4:	eb e3       	ldi	r30, 0x3B	; 59
    18c6:	f0 e0       	ldi	r31, 0x00	; 0
    18c8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ca:	80 83       	st	Z, r24
    18cc:	11 c0       	rjmp	.+34     	; 0x18f0 <DIO_u8setPortVal+0x7e>
	case DIO_PORT_B:	PORTB_REG = Copy_u8val;  break;
    18ce:	e8 e3       	ldi	r30, 0x38	; 56
    18d0:	f0 e0       	ldi	r31, 0x00	; 0
    18d2:	8b 81       	ldd	r24, Y+3	; 0x03
    18d4:	80 83       	st	Z, r24
    18d6:	0c c0       	rjmp	.+24     	; 0x18f0 <DIO_u8setPortVal+0x7e>
	case DIO_PORT_C:	PORTC_REG = Copy_u8val;  break;
    18d8:	e5 e3       	ldi	r30, 0x35	; 53
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	8b 81       	ldd	r24, Y+3	; 0x03
    18de:	80 83       	st	Z, r24
    18e0:	07 c0       	rjmp	.+14     	; 0x18f0 <DIO_u8setPortVal+0x7e>
	case DIO_PORT_D:	PORTD_REG = Copy_u8val;  break;
    18e2:	e2 e3       	ldi	r30, 0x32	; 50
    18e4:	f0 e0       	ldi	r31, 0x00	; 0
    18e6:	8b 81       	ldd	r24, Y+3	; 0x03
    18e8:	80 83       	st	Z, r24
    18ea:	02 c0       	rjmp	.+4      	; 0x18f0 <DIO_u8setPortVal+0x7e>
	default: Local_u8statues = 1;
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8statues;
    18f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    18f2:	0f 90       	pop	r0
    18f4:	0f 90       	pop	r0
    18f6:	0f 90       	pop	r0
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	cf 91       	pop	r28
    18fe:	df 91       	pop	r29
    1900:	08 95       	ret

00001902 <DIO_u8getPortVal>:
//get PORT value
u8 DIO_u8getPortVal(u8 Copy_u8port, u8 *Copy_u8valuePtr){
    1902:	df 93       	push	r29
    1904:	cf 93       	push	r28
    1906:	00 d0       	rcall	.+0      	; 0x1908 <DIO_u8getPortVal+0x6>
    1908:	00 d0       	rcall	.+0      	; 0x190a <DIO_u8getPortVal+0x8>
    190a:	00 d0       	rcall	.+0      	; 0x190c <DIO_u8getPortVal+0xa>
    190c:	cd b7       	in	r28, 0x3d	; 61
    190e:	de b7       	in	r29, 0x3e	; 62
    1910:	8a 83       	std	Y+2, r24	; 0x02
    1912:	7c 83       	std	Y+4, r23	; 0x04
    1914:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8statues = 0;
    1916:	19 82       	std	Y+1, r1	; 0x01
	switch (Copy_u8port){
    1918:	8a 81       	ldd	r24, Y+2	; 0x02
    191a:	28 2f       	mov	r18, r24
    191c:	30 e0       	ldi	r19, 0x00	; 0
    191e:	3e 83       	std	Y+6, r19	; 0x06
    1920:	2d 83       	std	Y+5, r18	; 0x05
    1922:	8d 81       	ldd	r24, Y+5	; 0x05
    1924:	9e 81       	ldd	r25, Y+6	; 0x06
    1926:	81 30       	cpi	r24, 0x01	; 1
    1928:	91 05       	cpc	r25, r1
    192a:	e1 f0       	breq	.+56     	; 0x1964 <DIO_u8getPortVal+0x62>
    192c:	2d 81       	ldd	r18, Y+5	; 0x05
    192e:	3e 81       	ldd	r19, Y+6	; 0x06
    1930:	22 30       	cpi	r18, 0x02	; 2
    1932:	31 05       	cpc	r19, r1
    1934:	2c f4       	brge	.+10     	; 0x1940 <DIO_u8getPortVal+0x3e>
    1936:	8d 81       	ldd	r24, Y+5	; 0x05
    1938:	9e 81       	ldd	r25, Y+6	; 0x06
    193a:	00 97       	sbiw	r24, 0x00	; 0
    193c:	61 f0       	breq	.+24     	; 0x1956 <DIO_u8getPortVal+0x54>
    193e:	27 c0       	rjmp	.+78     	; 0x198e <DIO_u8getPortVal+0x8c>
    1940:	2d 81       	ldd	r18, Y+5	; 0x05
    1942:	3e 81       	ldd	r19, Y+6	; 0x06
    1944:	22 30       	cpi	r18, 0x02	; 2
    1946:	31 05       	cpc	r19, r1
    1948:	a1 f0       	breq	.+40     	; 0x1972 <DIO_u8getPortVal+0x70>
    194a:	8d 81       	ldd	r24, Y+5	; 0x05
    194c:	9e 81       	ldd	r25, Y+6	; 0x06
    194e:	83 30       	cpi	r24, 0x03	; 3
    1950:	91 05       	cpc	r25, r1
    1952:	b1 f0       	breq	.+44     	; 0x1980 <DIO_u8getPortVal+0x7e>
    1954:	1c c0       	rjmp	.+56     	; 0x198e <DIO_u8getPortVal+0x8c>
	case DIO_PORT_A:	*Copy_u8valuePtr = PINA_REG;  break;
    1956:	e9 e3       	ldi	r30, 0x39	; 57
    1958:	f0 e0       	ldi	r31, 0x00	; 0
    195a:	80 81       	ld	r24, Z
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	80 83       	st	Z, r24
    1962:	17 c0       	rjmp	.+46     	; 0x1992 <DIO_u8getPortVal+0x90>
	case DIO_PORT_B:	*Copy_u8valuePtr = PINB_REG;  break;
    1964:	e6 e3       	ldi	r30, 0x36	; 54
    1966:	f0 e0       	ldi	r31, 0x00	; 0
    1968:	80 81       	ld	r24, Z
    196a:	eb 81       	ldd	r30, Y+3	; 0x03
    196c:	fc 81       	ldd	r31, Y+4	; 0x04
    196e:	80 83       	st	Z, r24
    1970:	10 c0       	rjmp	.+32     	; 0x1992 <DIO_u8getPortVal+0x90>
	case DIO_PORT_C:	*Copy_u8valuePtr = PINC_REG;  break;
    1972:	e3 e3       	ldi	r30, 0x33	; 51
    1974:	f0 e0       	ldi	r31, 0x00	; 0
    1976:	80 81       	ld	r24, Z
    1978:	eb 81       	ldd	r30, Y+3	; 0x03
    197a:	fc 81       	ldd	r31, Y+4	; 0x04
    197c:	80 83       	st	Z, r24
    197e:	09 c0       	rjmp	.+18     	; 0x1992 <DIO_u8getPortVal+0x90>
	case DIO_PORT_D:	*Copy_u8valuePtr = PIND_REG;  break;
    1980:	e0 e3       	ldi	r30, 0x30	; 48
    1982:	f0 e0       	ldi	r31, 0x00	; 0
    1984:	80 81       	ld	r24, Z
    1986:	eb 81       	ldd	r30, Y+3	; 0x03
    1988:	fc 81       	ldd	r31, Y+4	; 0x04
    198a:	80 83       	st	Z, r24
    198c:	02 c0       	rjmp	.+4      	; 0x1992 <DIO_u8getPortVal+0x90>

	default: Local_u8statues = 1;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8statues;
    1992:	89 81       	ldd	r24, Y+1	; 0x01
}
    1994:	26 96       	adiw	r28, 0x06	; 6
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	de bf       	out	0x3e, r29	; 62
    199c:	0f be       	out	0x3f, r0	; 63
    199e:	cd bf       	out	0x3d, r28	; 61
    19a0:	cf 91       	pop	r28
    19a2:	df 91       	pop	r29
    19a4:	08 95       	ret

000019a6 <DIO_u8setPinDir>:

//PIN Functions
//set PIN direction
u8 DIO_u8setPinDir(u8 Copy_u8port, u8 Copy_u8pin, u8 Copy_u8dir){
    19a6:	df 93       	push	r29
    19a8:	cf 93       	push	r28
    19aa:	cd b7       	in	r28, 0x3d	; 61
    19ac:	de b7       	in	r29, 0x3e	; 62
    19ae:	28 97       	sbiw	r28, 0x08	; 8
    19b0:	0f b6       	in	r0, 0x3f	; 63
    19b2:	f8 94       	cli
    19b4:	de bf       	out	0x3e, r29	; 62
    19b6:	0f be       	out	0x3f, r0	; 63
    19b8:	cd bf       	out	0x3d, r28	; 61
    19ba:	8a 83       	std	Y+2, r24	; 0x02
    19bc:	6b 83       	std	Y+3, r22	; 0x03
    19be:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8statues = 0;
    19c0:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8pin >= 0 && Copy_u8pin <= 7){
    19c2:	8b 81       	ldd	r24, Y+3	; 0x03
    19c4:	88 30       	cpi	r24, 0x08	; 8
    19c6:	08 f0       	brcs	.+2      	; 0x19ca <DIO_u8setPinDir+0x24>
    19c8:	f4 c0       	rjmp	.+488    	; 0x1bb2 <DIO_u8setPinDir+0x20c>
		if(Copy_u8dir == DIO_INPUT){
    19ca:	8c 81       	ldd	r24, Y+4	; 0x04
    19cc:	88 23       	and	r24, r24
    19ce:	09 f0       	breq	.+2      	; 0x19d2 <DIO_u8setPinDir+0x2c>
    19d0:	77 c0       	rjmp	.+238    	; 0x1ac0 <DIO_u8setPinDir+0x11a>
			switch(Copy_u8port){
    19d2:	8a 81       	ldd	r24, Y+2	; 0x02
    19d4:	28 2f       	mov	r18, r24
    19d6:	30 e0       	ldi	r19, 0x00	; 0
    19d8:	38 87       	std	Y+8, r19	; 0x08
    19da:	2f 83       	std	Y+7, r18	; 0x07
    19dc:	8f 81       	ldd	r24, Y+7	; 0x07
    19de:	98 85       	ldd	r25, Y+8	; 0x08
    19e0:	81 30       	cpi	r24, 0x01	; 1
    19e2:	91 05       	cpc	r25, r1
    19e4:	59 f1       	breq	.+86     	; 0x1a3c <DIO_u8setPinDir+0x96>
    19e6:	2f 81       	ldd	r18, Y+7	; 0x07
    19e8:	38 85       	ldd	r19, Y+8	; 0x08
    19ea:	22 30       	cpi	r18, 0x02	; 2
    19ec:	31 05       	cpc	r19, r1
    19ee:	2c f4       	brge	.+10     	; 0x19fa <DIO_u8setPinDir+0x54>
    19f0:	8f 81       	ldd	r24, Y+7	; 0x07
    19f2:	98 85       	ldd	r25, Y+8	; 0x08
    19f4:	00 97       	sbiw	r24, 0x00	; 0
    19f6:	69 f0       	breq	.+26     	; 0x1a12 <DIO_u8setPinDir+0x6c>
    19f8:	60 c0       	rjmp	.+192    	; 0x1aba <DIO_u8setPinDir+0x114>
    19fa:	2f 81       	ldd	r18, Y+7	; 0x07
    19fc:	38 85       	ldd	r19, Y+8	; 0x08
    19fe:	22 30       	cpi	r18, 0x02	; 2
    1a00:	31 05       	cpc	r19, r1
    1a02:	89 f1       	breq	.+98     	; 0x1a66 <DIO_u8setPinDir+0xc0>
    1a04:	8f 81       	ldd	r24, Y+7	; 0x07
    1a06:	98 85       	ldd	r25, Y+8	; 0x08
    1a08:	83 30       	cpi	r24, 0x03	; 3
    1a0a:	91 05       	cpc	r25, r1
    1a0c:	09 f4       	brne	.+2      	; 0x1a10 <DIO_u8setPinDir+0x6a>
    1a0e:	40 c0       	rjmp	.+128    	; 0x1a90 <DIO_u8setPinDir+0xea>
    1a10:	54 c0       	rjmp	.+168    	; 0x1aba <DIO_u8setPinDir+0x114>
			case DIO_PORT_A:	CLR_BIT(DDRA_REG, Copy_u8pin);  break;
    1a12:	aa e3       	ldi	r26, 0x3A	; 58
    1a14:	b0 e0       	ldi	r27, 0x00	; 0
    1a16:	ea e3       	ldi	r30, 0x3A	; 58
    1a18:	f0 e0       	ldi	r31, 0x00	; 0
    1a1a:	80 81       	ld	r24, Z
    1a1c:	48 2f       	mov	r20, r24
    1a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a20:	28 2f       	mov	r18, r24
    1a22:	30 e0       	ldi	r19, 0x00	; 0
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	02 2e       	mov	r0, r18
    1a2a:	02 c0       	rjmp	.+4      	; 0x1a30 <DIO_u8setPinDir+0x8a>
    1a2c:	88 0f       	add	r24, r24
    1a2e:	99 1f       	adc	r25, r25
    1a30:	0a 94       	dec	r0
    1a32:	e2 f7       	brpl	.-8      	; 0x1a2c <DIO_u8setPinDir+0x86>
    1a34:	80 95       	com	r24
    1a36:	84 23       	and	r24, r20
    1a38:	8c 93       	st	X, r24
    1a3a:	bd c0       	rjmp	.+378    	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_B:	CLR_BIT(DDRB_REG, Copy_u8pin);  break;
    1a3c:	a7 e3       	ldi	r26, 0x37	; 55
    1a3e:	b0 e0       	ldi	r27, 0x00	; 0
    1a40:	e7 e3       	ldi	r30, 0x37	; 55
    1a42:	f0 e0       	ldi	r31, 0x00	; 0
    1a44:	80 81       	ld	r24, Z
    1a46:	48 2f       	mov	r20, r24
    1a48:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4a:	28 2f       	mov	r18, r24
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	02 2e       	mov	r0, r18
    1a54:	02 c0       	rjmp	.+4      	; 0x1a5a <DIO_u8setPinDir+0xb4>
    1a56:	88 0f       	add	r24, r24
    1a58:	99 1f       	adc	r25, r25
    1a5a:	0a 94       	dec	r0
    1a5c:	e2 f7       	brpl	.-8      	; 0x1a56 <DIO_u8setPinDir+0xb0>
    1a5e:	80 95       	com	r24
    1a60:	84 23       	and	r24, r20
    1a62:	8c 93       	st	X, r24
    1a64:	a8 c0       	rjmp	.+336    	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_C:	CLR_BIT(DDRC_REG, Copy_u8pin);  break;
    1a66:	a4 e3       	ldi	r26, 0x34	; 52
    1a68:	b0 e0       	ldi	r27, 0x00	; 0
    1a6a:	e4 e3       	ldi	r30, 0x34	; 52
    1a6c:	f0 e0       	ldi	r31, 0x00	; 0
    1a6e:	80 81       	ld	r24, Z
    1a70:	48 2f       	mov	r20, r24
    1a72:	8b 81       	ldd	r24, Y+3	; 0x03
    1a74:	28 2f       	mov	r18, r24
    1a76:	30 e0       	ldi	r19, 0x00	; 0
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	02 2e       	mov	r0, r18
    1a7e:	02 c0       	rjmp	.+4      	; 0x1a84 <DIO_u8setPinDir+0xde>
    1a80:	88 0f       	add	r24, r24
    1a82:	99 1f       	adc	r25, r25
    1a84:	0a 94       	dec	r0
    1a86:	e2 f7       	brpl	.-8      	; 0x1a80 <DIO_u8setPinDir+0xda>
    1a88:	80 95       	com	r24
    1a8a:	84 23       	and	r24, r20
    1a8c:	8c 93       	st	X, r24
    1a8e:	93 c0       	rjmp	.+294    	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_D:	CLR_BIT(DDRD_REG, Copy_u8pin);  break;
    1a90:	a1 e3       	ldi	r26, 0x31	; 49
    1a92:	b0 e0       	ldi	r27, 0x00	; 0
    1a94:	e1 e3       	ldi	r30, 0x31	; 49
    1a96:	f0 e0       	ldi	r31, 0x00	; 0
    1a98:	80 81       	ld	r24, Z
    1a9a:	48 2f       	mov	r20, r24
    1a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a9e:	28 2f       	mov	r18, r24
    1aa0:	30 e0       	ldi	r19, 0x00	; 0
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	02 2e       	mov	r0, r18
    1aa8:	02 c0       	rjmp	.+4      	; 0x1aae <DIO_u8setPinDir+0x108>
    1aaa:	88 0f       	add	r24, r24
    1aac:	99 1f       	adc	r25, r25
    1aae:	0a 94       	dec	r0
    1ab0:	e2 f7       	brpl	.-8      	; 0x1aaa <DIO_u8setPinDir+0x104>
    1ab2:	80 95       	com	r24
    1ab4:	84 23       	and	r24, r20
    1ab6:	8c 93       	st	X, r24
    1ab8:	7e c0       	rjmp	.+252    	; 0x1bb6 <DIO_u8setPinDir+0x210>

			default: Local_u8statues = 1;
    1aba:	81 e0       	ldi	r24, 0x01	; 1
    1abc:	89 83       	std	Y+1, r24	; 0x01
    1abe:	7b c0       	rjmp	.+246    	; 0x1bb6 <DIO_u8setPinDir+0x210>
			}
		}else if(Copy_u8dir == DIO_OUTPUT){
    1ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac2:	81 30       	cpi	r24, 0x01	; 1
    1ac4:	09 f0       	breq	.+2      	; 0x1ac8 <DIO_u8setPinDir+0x122>
    1ac6:	72 c0       	rjmp	.+228    	; 0x1bac <DIO_u8setPinDir+0x206>
			switch(Copy_u8port){
    1ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    1aca:	28 2f       	mov	r18, r24
    1acc:	30 e0       	ldi	r19, 0x00	; 0
    1ace:	3e 83       	std	Y+6, r19	; 0x06
    1ad0:	2d 83       	std	Y+5, r18	; 0x05
    1ad2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ad4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ad6:	81 30       	cpi	r24, 0x01	; 1
    1ad8:	91 05       	cpc	r25, r1
    1ada:	49 f1       	breq	.+82     	; 0x1b2e <DIO_u8setPinDir+0x188>
    1adc:	2d 81       	ldd	r18, Y+5	; 0x05
    1ade:	3e 81       	ldd	r19, Y+6	; 0x06
    1ae0:	22 30       	cpi	r18, 0x02	; 2
    1ae2:	31 05       	cpc	r19, r1
    1ae4:	2c f4       	brge	.+10     	; 0x1af0 <DIO_u8setPinDir+0x14a>
    1ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <DIO_u8setPinDir+0x160>
    1aee:	5b c0       	rjmp	.+182    	; 0x1ba6 <DIO_u8setPinDir+0x200>
    1af0:	2d 81       	ldd	r18, Y+5	; 0x05
    1af2:	3e 81       	ldd	r19, Y+6	; 0x06
    1af4:	22 30       	cpi	r18, 0x02	; 2
    1af6:	31 05       	cpc	r19, r1
    1af8:	71 f1       	breq	.+92     	; 0x1b56 <DIO_u8setPinDir+0x1b0>
    1afa:	8d 81       	ldd	r24, Y+5	; 0x05
    1afc:	9e 81       	ldd	r25, Y+6	; 0x06
    1afe:	83 30       	cpi	r24, 0x03	; 3
    1b00:	91 05       	cpc	r25, r1
    1b02:	e9 f1       	breq	.+122    	; 0x1b7e <DIO_u8setPinDir+0x1d8>
    1b04:	50 c0       	rjmp	.+160    	; 0x1ba6 <DIO_u8setPinDir+0x200>
			case DIO_PORT_A:	SET_BIT(DDRA_REG, Copy_u8pin);  break;
    1b06:	aa e3       	ldi	r26, 0x3A	; 58
    1b08:	b0 e0       	ldi	r27, 0x00	; 0
    1b0a:	ea e3       	ldi	r30, 0x3A	; 58
    1b0c:	f0 e0       	ldi	r31, 0x00	; 0
    1b0e:	80 81       	ld	r24, Z
    1b10:	48 2f       	mov	r20, r24
    1b12:	8b 81       	ldd	r24, Y+3	; 0x03
    1b14:	28 2f       	mov	r18, r24
    1b16:	30 e0       	ldi	r19, 0x00	; 0
    1b18:	81 e0       	ldi	r24, 0x01	; 1
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	02 2e       	mov	r0, r18
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <DIO_u8setPinDir+0x17e>
    1b20:	88 0f       	add	r24, r24
    1b22:	99 1f       	adc	r25, r25
    1b24:	0a 94       	dec	r0
    1b26:	e2 f7       	brpl	.-8      	; 0x1b20 <DIO_u8setPinDir+0x17a>
    1b28:	84 2b       	or	r24, r20
    1b2a:	8c 93       	st	X, r24
    1b2c:	44 c0       	rjmp	.+136    	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_B:	SET_BIT(DDRB_REG, Copy_u8pin);  break;
    1b2e:	a7 e3       	ldi	r26, 0x37	; 55
    1b30:	b0 e0       	ldi	r27, 0x00	; 0
    1b32:	e7 e3       	ldi	r30, 0x37	; 55
    1b34:	f0 e0       	ldi	r31, 0x00	; 0
    1b36:	80 81       	ld	r24, Z
    1b38:	48 2f       	mov	r20, r24
    1b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3c:	28 2f       	mov	r18, r24
    1b3e:	30 e0       	ldi	r19, 0x00	; 0
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	02 2e       	mov	r0, r18
    1b46:	02 c0       	rjmp	.+4      	; 0x1b4c <DIO_u8setPinDir+0x1a6>
    1b48:	88 0f       	add	r24, r24
    1b4a:	99 1f       	adc	r25, r25
    1b4c:	0a 94       	dec	r0
    1b4e:	e2 f7       	brpl	.-8      	; 0x1b48 <DIO_u8setPinDir+0x1a2>
    1b50:	84 2b       	or	r24, r20
    1b52:	8c 93       	st	X, r24
    1b54:	30 c0       	rjmp	.+96     	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_C:	SET_BIT(DDRC_REG, Copy_u8pin);  break;
    1b56:	a4 e3       	ldi	r26, 0x34	; 52
    1b58:	b0 e0       	ldi	r27, 0x00	; 0
    1b5a:	e4 e3       	ldi	r30, 0x34	; 52
    1b5c:	f0 e0       	ldi	r31, 0x00	; 0
    1b5e:	80 81       	ld	r24, Z
    1b60:	48 2f       	mov	r20, r24
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	28 2f       	mov	r18, r24
    1b66:	30 e0       	ldi	r19, 0x00	; 0
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	02 2e       	mov	r0, r18
    1b6e:	02 c0       	rjmp	.+4      	; 0x1b74 <DIO_u8setPinDir+0x1ce>
    1b70:	88 0f       	add	r24, r24
    1b72:	99 1f       	adc	r25, r25
    1b74:	0a 94       	dec	r0
    1b76:	e2 f7       	brpl	.-8      	; 0x1b70 <DIO_u8setPinDir+0x1ca>
    1b78:	84 2b       	or	r24, r20
    1b7a:	8c 93       	st	X, r24
    1b7c:	1c c0       	rjmp	.+56     	; 0x1bb6 <DIO_u8setPinDir+0x210>
			case DIO_PORT_D:	SET_BIT(DDRD_REG, Copy_u8pin);  break;
    1b7e:	a1 e3       	ldi	r26, 0x31	; 49
    1b80:	b0 e0       	ldi	r27, 0x00	; 0
    1b82:	e1 e3       	ldi	r30, 0x31	; 49
    1b84:	f0 e0       	ldi	r31, 0x00	; 0
    1b86:	80 81       	ld	r24, Z
    1b88:	48 2f       	mov	r20, r24
    1b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b8c:	28 2f       	mov	r18, r24
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	02 2e       	mov	r0, r18
    1b96:	02 c0       	rjmp	.+4      	; 0x1b9c <DIO_u8setPinDir+0x1f6>
    1b98:	88 0f       	add	r24, r24
    1b9a:	99 1f       	adc	r25, r25
    1b9c:	0a 94       	dec	r0
    1b9e:	e2 f7       	brpl	.-8      	; 0x1b98 <DIO_u8setPinDir+0x1f2>
    1ba0:	84 2b       	or	r24, r20
    1ba2:	8c 93       	st	X, r24
    1ba4:	08 c0       	rjmp	.+16     	; 0x1bb6 <DIO_u8setPinDir+0x210>

			default: Local_u8statues = 1;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	89 83       	std	Y+1, r24	; 0x01
    1baa:	05 c0       	rjmp	.+10     	; 0x1bb6 <DIO_u8setPinDir+0x210>
			}
		}else{
			Local_u8statues=1;
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	89 83       	std	Y+1, r24	; 0x01
    1bb0:	02 c0       	rjmp	.+4      	; 0x1bb6 <DIO_u8setPinDir+0x210>
		}

	}else{
		Local_u8statues=1;
    1bb2:	81 e0       	ldi	r24, 0x01	; 1
    1bb4:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8statues;
    1bb6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1bb8:	28 96       	adiw	r28, 0x08	; 8
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	cd bf       	out	0x3d, r28	; 61
    1bc4:	cf 91       	pop	r28
    1bc6:	df 91       	pop	r29
    1bc8:	08 95       	ret

00001bca <DIO_u8setPinVal>:
//set PIN value
u8 DIO_u8setPinVal(u8 Copy_u8port, u8 Copy_u8pin, u8 Copy_u8val){
    1bca:	df 93       	push	r29
    1bcc:	cf 93       	push	r28
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	28 97       	sbiw	r28, 0x08	; 8
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	de bf       	out	0x3e, r29	; 62
    1bda:	0f be       	out	0x3f, r0	; 63
    1bdc:	cd bf       	out	0x3d, r28	; 61
    1bde:	8a 83       	std	Y+2, r24	; 0x02
    1be0:	6b 83       	std	Y+3, r22	; 0x03
    1be2:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8statues = 0;
    1be4:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8pin >= 0 && Copy_u8pin <=7){
    1be6:	8b 81       	ldd	r24, Y+3	; 0x03
    1be8:	88 30       	cpi	r24, 0x08	; 8
    1bea:	08 f0       	brcs	.+2      	; 0x1bee <DIO_u8setPinVal+0x24>
    1bec:	f4 c0       	rjmp	.+488    	; 0x1dd6 <DIO_u8setPinVal+0x20c>
		if(Copy_u8val == DIO_HIGH){
    1bee:	8c 81       	ldd	r24, Y+4	; 0x04
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	09 f0       	breq	.+2      	; 0x1bf6 <DIO_u8setPinVal+0x2c>
    1bf4:	72 c0       	rjmp	.+228    	; 0x1cda <DIO_u8setPinVal+0x110>
			switch(Copy_u8port){
    1bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf8:	28 2f       	mov	r18, r24
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	38 87       	std	Y+8, r19	; 0x08
    1bfe:	2f 83       	std	Y+7, r18	; 0x07
    1c00:	8f 81       	ldd	r24, Y+7	; 0x07
    1c02:	98 85       	ldd	r25, Y+8	; 0x08
    1c04:	81 30       	cpi	r24, 0x01	; 1
    1c06:	91 05       	cpc	r25, r1
    1c08:	49 f1       	breq	.+82     	; 0x1c5c <DIO_u8setPinVal+0x92>
    1c0a:	2f 81       	ldd	r18, Y+7	; 0x07
    1c0c:	38 85       	ldd	r19, Y+8	; 0x08
    1c0e:	22 30       	cpi	r18, 0x02	; 2
    1c10:	31 05       	cpc	r19, r1
    1c12:	2c f4       	brge	.+10     	; 0x1c1e <DIO_u8setPinVal+0x54>
    1c14:	8f 81       	ldd	r24, Y+7	; 0x07
    1c16:	98 85       	ldd	r25, Y+8	; 0x08
    1c18:	00 97       	sbiw	r24, 0x00	; 0
    1c1a:	61 f0       	breq	.+24     	; 0x1c34 <DIO_u8setPinVal+0x6a>
    1c1c:	5b c0       	rjmp	.+182    	; 0x1cd4 <DIO_u8setPinVal+0x10a>
    1c1e:	2f 81       	ldd	r18, Y+7	; 0x07
    1c20:	38 85       	ldd	r19, Y+8	; 0x08
    1c22:	22 30       	cpi	r18, 0x02	; 2
    1c24:	31 05       	cpc	r19, r1
    1c26:	71 f1       	breq	.+92     	; 0x1c84 <DIO_u8setPinVal+0xba>
    1c28:	8f 81       	ldd	r24, Y+7	; 0x07
    1c2a:	98 85       	ldd	r25, Y+8	; 0x08
    1c2c:	83 30       	cpi	r24, 0x03	; 3
    1c2e:	91 05       	cpc	r25, r1
    1c30:	e9 f1       	breq	.+122    	; 0x1cac <DIO_u8setPinVal+0xe2>
    1c32:	50 c0       	rjmp	.+160    	; 0x1cd4 <DIO_u8setPinVal+0x10a>
			case DIO_PORT_A:	SET_BIT(PORTA_REG, Copy_u8pin);  break;
    1c34:	ab e3       	ldi	r26, 0x3B	; 59
    1c36:	b0 e0       	ldi	r27, 0x00	; 0
    1c38:	eb e3       	ldi	r30, 0x3B	; 59
    1c3a:	f0 e0       	ldi	r31, 0x00	; 0
    1c3c:	80 81       	ld	r24, Z
    1c3e:	48 2f       	mov	r20, r24
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	28 2f       	mov	r18, r24
    1c44:	30 e0       	ldi	r19, 0x00	; 0
    1c46:	81 e0       	ldi	r24, 0x01	; 1
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	02 2e       	mov	r0, r18
    1c4c:	02 c0       	rjmp	.+4      	; 0x1c52 <DIO_u8setPinVal+0x88>
    1c4e:	88 0f       	add	r24, r24
    1c50:	99 1f       	adc	r25, r25
    1c52:	0a 94       	dec	r0
    1c54:	e2 f7       	brpl	.-8      	; 0x1c4e <DIO_u8setPinVal+0x84>
    1c56:	84 2b       	or	r24, r20
    1c58:	8c 93       	st	X, r24
    1c5a:	bf c0       	rjmp	.+382    	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_B:	SET_BIT(PORTB_REG, Copy_u8pin);  break;
    1c5c:	a8 e3       	ldi	r26, 0x38	; 56
    1c5e:	b0 e0       	ldi	r27, 0x00	; 0
    1c60:	e8 e3       	ldi	r30, 0x38	; 56
    1c62:	f0 e0       	ldi	r31, 0x00	; 0
    1c64:	80 81       	ld	r24, Z
    1c66:	48 2f       	mov	r20, r24
    1c68:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6a:	28 2f       	mov	r18, r24
    1c6c:	30 e0       	ldi	r19, 0x00	; 0
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	02 2e       	mov	r0, r18
    1c74:	02 c0       	rjmp	.+4      	; 0x1c7a <DIO_u8setPinVal+0xb0>
    1c76:	88 0f       	add	r24, r24
    1c78:	99 1f       	adc	r25, r25
    1c7a:	0a 94       	dec	r0
    1c7c:	e2 f7       	brpl	.-8      	; 0x1c76 <DIO_u8setPinVal+0xac>
    1c7e:	84 2b       	or	r24, r20
    1c80:	8c 93       	st	X, r24
    1c82:	ab c0       	rjmp	.+342    	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_C:	SET_BIT(PORTC_REG, Copy_u8pin);  break;
    1c84:	a5 e3       	ldi	r26, 0x35	; 53
    1c86:	b0 e0       	ldi	r27, 0x00	; 0
    1c88:	e5 e3       	ldi	r30, 0x35	; 53
    1c8a:	f0 e0       	ldi	r31, 0x00	; 0
    1c8c:	80 81       	ld	r24, Z
    1c8e:	48 2f       	mov	r20, r24
    1c90:	8b 81       	ldd	r24, Y+3	; 0x03
    1c92:	28 2f       	mov	r18, r24
    1c94:	30 e0       	ldi	r19, 0x00	; 0
    1c96:	81 e0       	ldi	r24, 0x01	; 1
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	02 2e       	mov	r0, r18
    1c9c:	02 c0       	rjmp	.+4      	; 0x1ca2 <DIO_u8setPinVal+0xd8>
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	0a 94       	dec	r0
    1ca4:	e2 f7       	brpl	.-8      	; 0x1c9e <DIO_u8setPinVal+0xd4>
    1ca6:	84 2b       	or	r24, r20
    1ca8:	8c 93       	st	X, r24
    1caa:	97 c0       	rjmp	.+302    	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_D:	SET_BIT(PORTD_REG, Copy_u8pin);  break;
    1cac:	a2 e3       	ldi	r26, 0x32	; 50
    1cae:	b0 e0       	ldi	r27, 0x00	; 0
    1cb0:	e2 e3       	ldi	r30, 0x32	; 50
    1cb2:	f0 e0       	ldi	r31, 0x00	; 0
    1cb4:	80 81       	ld	r24, Z
    1cb6:	48 2f       	mov	r20, r24
    1cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cba:	28 2f       	mov	r18, r24
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	02 2e       	mov	r0, r18
    1cc4:	02 c0       	rjmp	.+4      	; 0x1cca <DIO_u8setPinVal+0x100>
    1cc6:	88 0f       	add	r24, r24
    1cc8:	99 1f       	adc	r25, r25
    1cca:	0a 94       	dec	r0
    1ccc:	e2 f7       	brpl	.-8      	; 0x1cc6 <DIO_u8setPinVal+0xfc>
    1cce:	84 2b       	or	r24, r20
    1cd0:	8c 93       	st	X, r24
    1cd2:	83 c0       	rjmp	.+262    	; 0x1dda <DIO_u8setPinVal+0x210>

			default: Local_u8statues = 1;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	89 83       	std	Y+1, r24	; 0x01
    1cd8:	80 c0       	rjmp	.+256    	; 0x1dda <DIO_u8setPinVal+0x210>
			}
		}else if(Copy_u8val == DIO_LOW){
    1cda:	8c 81       	ldd	r24, Y+4	; 0x04
    1cdc:	88 23       	and	r24, r24
    1cde:	09 f0       	breq	.+2      	; 0x1ce2 <DIO_u8setPinVal+0x118>
    1ce0:	77 c0       	rjmp	.+238    	; 0x1dd0 <DIO_u8setPinVal+0x206>
			switch(Copy_u8port){
    1ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce4:	28 2f       	mov	r18, r24
    1ce6:	30 e0       	ldi	r19, 0x00	; 0
    1ce8:	3e 83       	std	Y+6, r19	; 0x06
    1cea:	2d 83       	std	Y+5, r18	; 0x05
    1cec:	8d 81       	ldd	r24, Y+5	; 0x05
    1cee:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf0:	81 30       	cpi	r24, 0x01	; 1
    1cf2:	91 05       	cpc	r25, r1
    1cf4:	59 f1       	breq	.+86     	; 0x1d4c <DIO_u8setPinVal+0x182>
    1cf6:	2d 81       	ldd	r18, Y+5	; 0x05
    1cf8:	3e 81       	ldd	r19, Y+6	; 0x06
    1cfa:	22 30       	cpi	r18, 0x02	; 2
    1cfc:	31 05       	cpc	r19, r1
    1cfe:	2c f4       	brge	.+10     	; 0x1d0a <DIO_u8setPinVal+0x140>
    1d00:	8d 81       	ldd	r24, Y+5	; 0x05
    1d02:	9e 81       	ldd	r25, Y+6	; 0x06
    1d04:	00 97       	sbiw	r24, 0x00	; 0
    1d06:	69 f0       	breq	.+26     	; 0x1d22 <DIO_u8setPinVal+0x158>
    1d08:	60 c0       	rjmp	.+192    	; 0x1dca <DIO_u8setPinVal+0x200>
    1d0a:	2d 81       	ldd	r18, Y+5	; 0x05
    1d0c:	3e 81       	ldd	r19, Y+6	; 0x06
    1d0e:	22 30       	cpi	r18, 0x02	; 2
    1d10:	31 05       	cpc	r19, r1
    1d12:	89 f1       	breq	.+98     	; 0x1d76 <DIO_u8setPinVal+0x1ac>
    1d14:	8d 81       	ldd	r24, Y+5	; 0x05
    1d16:	9e 81       	ldd	r25, Y+6	; 0x06
    1d18:	83 30       	cpi	r24, 0x03	; 3
    1d1a:	91 05       	cpc	r25, r1
    1d1c:	09 f4       	brne	.+2      	; 0x1d20 <DIO_u8setPinVal+0x156>
    1d1e:	40 c0       	rjmp	.+128    	; 0x1da0 <DIO_u8setPinVal+0x1d6>
    1d20:	54 c0       	rjmp	.+168    	; 0x1dca <DIO_u8setPinVal+0x200>
			case DIO_PORT_A:	CLR_BIT(PORTA_REG, Copy_u8pin);  break;
    1d22:	ab e3       	ldi	r26, 0x3B	; 59
    1d24:	b0 e0       	ldi	r27, 0x00	; 0
    1d26:	eb e3       	ldi	r30, 0x3B	; 59
    1d28:	f0 e0       	ldi	r31, 0x00	; 0
    1d2a:	80 81       	ld	r24, Z
    1d2c:	48 2f       	mov	r20, r24
    1d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d30:	28 2f       	mov	r18, r24
    1d32:	30 e0       	ldi	r19, 0x00	; 0
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	02 2e       	mov	r0, r18
    1d3a:	02 c0       	rjmp	.+4      	; 0x1d40 <DIO_u8setPinVal+0x176>
    1d3c:	88 0f       	add	r24, r24
    1d3e:	99 1f       	adc	r25, r25
    1d40:	0a 94       	dec	r0
    1d42:	e2 f7       	brpl	.-8      	; 0x1d3c <DIO_u8setPinVal+0x172>
    1d44:	80 95       	com	r24
    1d46:	84 23       	and	r24, r20
    1d48:	8c 93       	st	X, r24
    1d4a:	47 c0       	rjmp	.+142    	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_B:	CLR_BIT(PORTB_REG, Copy_u8pin);  break;
    1d4c:	a8 e3       	ldi	r26, 0x38	; 56
    1d4e:	b0 e0       	ldi	r27, 0x00	; 0
    1d50:	e8 e3       	ldi	r30, 0x38	; 56
    1d52:	f0 e0       	ldi	r31, 0x00	; 0
    1d54:	80 81       	ld	r24, Z
    1d56:	48 2f       	mov	r20, r24
    1d58:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5a:	28 2f       	mov	r18, r24
    1d5c:	30 e0       	ldi	r19, 0x00	; 0
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	02 2e       	mov	r0, r18
    1d64:	02 c0       	rjmp	.+4      	; 0x1d6a <DIO_u8setPinVal+0x1a0>
    1d66:	88 0f       	add	r24, r24
    1d68:	99 1f       	adc	r25, r25
    1d6a:	0a 94       	dec	r0
    1d6c:	e2 f7       	brpl	.-8      	; 0x1d66 <DIO_u8setPinVal+0x19c>
    1d6e:	80 95       	com	r24
    1d70:	84 23       	and	r24, r20
    1d72:	8c 93       	st	X, r24
    1d74:	32 c0       	rjmp	.+100    	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_C:	CLR_BIT(PORTC_REG, Copy_u8pin);  break;
    1d76:	a5 e3       	ldi	r26, 0x35	; 53
    1d78:	b0 e0       	ldi	r27, 0x00	; 0
    1d7a:	e5 e3       	ldi	r30, 0x35	; 53
    1d7c:	f0 e0       	ldi	r31, 0x00	; 0
    1d7e:	80 81       	ld	r24, Z
    1d80:	48 2f       	mov	r20, r24
    1d82:	8b 81       	ldd	r24, Y+3	; 0x03
    1d84:	28 2f       	mov	r18, r24
    1d86:	30 e0       	ldi	r19, 0x00	; 0
    1d88:	81 e0       	ldi	r24, 0x01	; 1
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	02 2e       	mov	r0, r18
    1d8e:	02 c0       	rjmp	.+4      	; 0x1d94 <DIO_u8setPinVal+0x1ca>
    1d90:	88 0f       	add	r24, r24
    1d92:	99 1f       	adc	r25, r25
    1d94:	0a 94       	dec	r0
    1d96:	e2 f7       	brpl	.-8      	; 0x1d90 <DIO_u8setPinVal+0x1c6>
    1d98:	80 95       	com	r24
    1d9a:	84 23       	and	r24, r20
    1d9c:	8c 93       	st	X, r24
    1d9e:	1d c0       	rjmp	.+58     	; 0x1dda <DIO_u8setPinVal+0x210>
			case DIO_PORT_D:	CLR_BIT(PORTD_REG, Copy_u8pin);  break;
    1da0:	a2 e3       	ldi	r26, 0x32	; 50
    1da2:	b0 e0       	ldi	r27, 0x00	; 0
    1da4:	e2 e3       	ldi	r30, 0x32	; 50
    1da6:	f0 e0       	ldi	r31, 0x00	; 0
    1da8:	80 81       	ld	r24, Z
    1daa:	48 2f       	mov	r20, r24
    1dac:	8b 81       	ldd	r24, Y+3	; 0x03
    1dae:	28 2f       	mov	r18, r24
    1db0:	30 e0       	ldi	r19, 0x00	; 0
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	02 2e       	mov	r0, r18
    1db8:	02 c0       	rjmp	.+4      	; 0x1dbe <DIO_u8setPinVal+0x1f4>
    1dba:	88 0f       	add	r24, r24
    1dbc:	99 1f       	adc	r25, r25
    1dbe:	0a 94       	dec	r0
    1dc0:	e2 f7       	brpl	.-8      	; 0x1dba <DIO_u8setPinVal+0x1f0>
    1dc2:	80 95       	com	r24
    1dc4:	84 23       	and	r24, r20
    1dc6:	8c 93       	st	X, r24
    1dc8:	08 c0       	rjmp	.+16     	; 0x1dda <DIO_u8setPinVal+0x210>

			default: Local_u8statues = 1;
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	89 83       	std	Y+1, r24	; 0x01
    1dce:	05 c0       	rjmp	.+10     	; 0x1dda <DIO_u8setPinVal+0x210>
			}
		}else{
			Local_u8statues=1;
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	89 83       	std	Y+1, r24	; 0x01
    1dd4:	02 c0       	rjmp	.+4      	; 0x1dda <DIO_u8setPinVal+0x210>
		}
	}else{
		Local_u8statues=1;
    1dd6:	81 e0       	ldi	r24, 0x01	; 1
    1dd8:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8statues;
    1dda:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ddc:	28 96       	adiw	r28, 0x08	; 8
    1dde:	0f b6       	in	r0, 0x3f	; 63
    1de0:	f8 94       	cli
    1de2:	de bf       	out	0x3e, r29	; 62
    1de4:	0f be       	out	0x3f, r0	; 63
    1de6:	cd bf       	out	0x3d, r28	; 61
    1de8:	cf 91       	pop	r28
    1dea:	df 91       	pop	r29
    1dec:	08 95       	ret

00001dee <DIO_u8getPinVal>:

//get PIN value
u8 DIO_u8getPinVal(u8 Copy_u8port, u8 Copy_u8pin, u8 *Copy_u8valuePtr){
    1dee:	df 93       	push	r29
    1df0:	cf 93       	push	r28
    1df2:	cd b7       	in	r28, 0x3d	; 61
    1df4:	de b7       	in	r29, 0x3e	; 62
    1df6:	27 97       	sbiw	r28, 0x07	; 7
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	de bf       	out	0x3e, r29	; 62
    1dfe:	0f be       	out	0x3f, r0	; 63
    1e00:	cd bf       	out	0x3d, r28	; 61
    1e02:	8a 83       	std	Y+2, r24	; 0x02
    1e04:	6b 83       	std	Y+3, r22	; 0x03
    1e06:	5d 83       	std	Y+5, r21	; 0x05
    1e08:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8statues = 0;
    1e0a:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8pin >= 0 && Copy_u8pin <=7){
    1e0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e0e:	88 30       	cpi	r24, 0x08	; 8
    1e10:	08 f0       	brcs	.+2      	; 0x1e14 <DIO_u8getPinVal+0x26>
    1e12:	74 c0       	rjmp	.+232    	; 0x1efc <DIO_u8getPinVal+0x10e>
		switch(Copy_u8port){
    1e14:	8a 81       	ldd	r24, Y+2	; 0x02
    1e16:	28 2f       	mov	r18, r24
    1e18:	30 e0       	ldi	r19, 0x00	; 0
    1e1a:	3f 83       	std	Y+7, r19	; 0x07
    1e1c:	2e 83       	std	Y+6, r18	; 0x06
    1e1e:	4e 81       	ldd	r20, Y+6	; 0x06
    1e20:	5f 81       	ldd	r21, Y+7	; 0x07
    1e22:	41 30       	cpi	r20, 0x01	; 1
    1e24:	51 05       	cpc	r21, r1
    1e26:	59 f1       	breq	.+86     	; 0x1e7e <DIO_u8getPinVal+0x90>
    1e28:	8e 81       	ldd	r24, Y+6	; 0x06
    1e2a:	9f 81       	ldd	r25, Y+7	; 0x07
    1e2c:	82 30       	cpi	r24, 0x02	; 2
    1e2e:	91 05       	cpc	r25, r1
    1e30:	34 f4       	brge	.+12     	; 0x1e3e <DIO_u8getPinVal+0x50>
    1e32:	2e 81       	ldd	r18, Y+6	; 0x06
    1e34:	3f 81       	ldd	r19, Y+7	; 0x07
    1e36:	21 15       	cp	r18, r1
    1e38:	31 05       	cpc	r19, r1
    1e3a:	69 f0       	breq	.+26     	; 0x1e56 <DIO_u8getPinVal+0x68>
    1e3c:	5c c0       	rjmp	.+184    	; 0x1ef6 <DIO_u8getPinVal+0x108>
    1e3e:	4e 81       	ldd	r20, Y+6	; 0x06
    1e40:	5f 81       	ldd	r21, Y+7	; 0x07
    1e42:	42 30       	cpi	r20, 0x02	; 2
    1e44:	51 05       	cpc	r21, r1
    1e46:	79 f1       	breq	.+94     	; 0x1ea6 <DIO_u8getPinVal+0xb8>
    1e48:	8e 81       	ldd	r24, Y+6	; 0x06
    1e4a:	9f 81       	ldd	r25, Y+7	; 0x07
    1e4c:	83 30       	cpi	r24, 0x03	; 3
    1e4e:	91 05       	cpc	r25, r1
    1e50:	09 f4       	brne	.+2      	; 0x1e54 <DIO_u8getPinVal+0x66>
    1e52:	3d c0       	rjmp	.+122    	; 0x1ece <DIO_u8getPinVal+0xe0>
    1e54:	50 c0       	rjmp	.+160    	; 0x1ef6 <DIO_u8getPinVal+0x108>
		case DIO_PORT_A: *Copy_u8valuePtr = GET_BIT(PINA_REG, Copy_u8pin); break;
    1e56:	e9 e3       	ldi	r30, 0x39	; 57
    1e58:	f0 e0       	ldi	r31, 0x00	; 0
    1e5a:	80 81       	ld	r24, Z
    1e5c:	28 2f       	mov	r18, r24
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	8b 81       	ldd	r24, Y+3	; 0x03
    1e62:	88 2f       	mov	r24, r24
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	a9 01       	movw	r20, r18
    1e68:	02 c0       	rjmp	.+4      	; 0x1e6e <DIO_u8getPinVal+0x80>
    1e6a:	55 95       	asr	r21
    1e6c:	47 95       	ror	r20
    1e6e:	8a 95       	dec	r24
    1e70:	e2 f7       	brpl	.-8      	; 0x1e6a <DIO_u8getPinVal+0x7c>
    1e72:	ca 01       	movw	r24, r20
    1e74:	81 70       	andi	r24, 0x01	; 1
    1e76:	ec 81       	ldd	r30, Y+4	; 0x04
    1e78:	fd 81       	ldd	r31, Y+5	; 0x05
    1e7a:	80 83       	st	Z, r24
    1e7c:	41 c0       	rjmp	.+130    	; 0x1f00 <DIO_u8getPinVal+0x112>
		case DIO_PORT_B: *Copy_u8valuePtr = GET_BIT(PINB_REG, Copy_u8pin); break;
    1e7e:	e6 e3       	ldi	r30, 0x36	; 54
    1e80:	f0 e0       	ldi	r31, 0x00	; 0
    1e82:	80 81       	ld	r24, Z
    1e84:	28 2f       	mov	r18, r24
    1e86:	30 e0       	ldi	r19, 0x00	; 0
    1e88:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8a:	88 2f       	mov	r24, r24
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	a9 01       	movw	r20, r18
    1e90:	02 c0       	rjmp	.+4      	; 0x1e96 <DIO_u8getPinVal+0xa8>
    1e92:	55 95       	asr	r21
    1e94:	47 95       	ror	r20
    1e96:	8a 95       	dec	r24
    1e98:	e2 f7       	brpl	.-8      	; 0x1e92 <DIO_u8getPinVal+0xa4>
    1e9a:	ca 01       	movw	r24, r20
    1e9c:	81 70       	andi	r24, 0x01	; 1
    1e9e:	ec 81       	ldd	r30, Y+4	; 0x04
    1ea0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ea2:	80 83       	st	Z, r24
    1ea4:	2d c0       	rjmp	.+90     	; 0x1f00 <DIO_u8getPinVal+0x112>
		case DIO_PORT_C: *Copy_u8valuePtr = GET_BIT(PINC_REG, Copy_u8pin); break;
    1ea6:	e3 e3       	ldi	r30, 0x33	; 51
    1ea8:	f0 e0       	ldi	r31, 0x00	; 0
    1eaa:	80 81       	ld	r24, Z
    1eac:	28 2f       	mov	r18, r24
    1eae:	30 e0       	ldi	r19, 0x00	; 0
    1eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb2:	88 2f       	mov	r24, r24
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	a9 01       	movw	r20, r18
    1eb8:	02 c0       	rjmp	.+4      	; 0x1ebe <DIO_u8getPinVal+0xd0>
    1eba:	55 95       	asr	r21
    1ebc:	47 95       	ror	r20
    1ebe:	8a 95       	dec	r24
    1ec0:	e2 f7       	brpl	.-8      	; 0x1eba <DIO_u8getPinVal+0xcc>
    1ec2:	ca 01       	movw	r24, r20
    1ec4:	81 70       	andi	r24, 0x01	; 1
    1ec6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ec8:	fd 81       	ldd	r31, Y+5	; 0x05
    1eca:	80 83       	st	Z, r24
    1ecc:	19 c0       	rjmp	.+50     	; 0x1f00 <DIO_u8getPinVal+0x112>
		case DIO_PORT_D: *Copy_u8valuePtr = GET_BIT(PIND_REG, Copy_u8pin); break;
    1ece:	e0 e3       	ldi	r30, 0x30	; 48
    1ed0:	f0 e0       	ldi	r31, 0x00	; 0
    1ed2:	80 81       	ld	r24, Z
    1ed4:	28 2f       	mov	r18, r24
    1ed6:	30 e0       	ldi	r19, 0x00	; 0
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	88 2f       	mov	r24, r24
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	a9 01       	movw	r20, r18
    1ee0:	02 c0       	rjmp	.+4      	; 0x1ee6 <DIO_u8getPinVal+0xf8>
    1ee2:	55 95       	asr	r21
    1ee4:	47 95       	ror	r20
    1ee6:	8a 95       	dec	r24
    1ee8:	e2 f7       	brpl	.-8      	; 0x1ee2 <DIO_u8getPinVal+0xf4>
    1eea:	ca 01       	movw	r24, r20
    1eec:	81 70       	andi	r24, 0x01	; 1
    1eee:	ec 81       	ldd	r30, Y+4	; 0x04
    1ef0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ef2:	80 83       	st	Z, r24
    1ef4:	05 c0       	rjmp	.+10     	; 0x1f00 <DIO_u8getPinVal+0x112>

		default: Local_u8statues = 1;
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	89 83       	std	Y+1, r24	; 0x01
    1efa:	02 c0       	rjmp	.+4      	; 0x1f00 <DIO_u8getPinVal+0x112>
		}
	}else{
		Local_u8statues=1;
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8statues;
    1f00:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f02:	27 96       	adiw	r28, 0x07	; 7
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	cf 91       	pop	r28
    1f10:	df 91       	pop	r29
    1f12:	08 95       	ret

00001f14 <HMCP2515_voidWriteReg>:
 **************** Common Function Start  **********************/

/*********** Write Section Start ****************/

void HMCP2515_voidWriteReg(u8 Copy_u8RegAddress ,u8 Copy_u8Data)
{
    1f14:	df 93       	push	r29
    1f16:	cf 93       	push	r28
    1f18:	00 d0       	rcall	.+0      	; 0x1f1a <HMCP2515_voidWriteReg+0x6>
    1f1a:	cd b7       	in	r28, 0x3d	; 61
    1f1c:	de b7       	in	r29, 0x3e	; 62
    1f1e:	89 83       	std	Y+1, r24	; 0x01
    1f20:	6a 83       	std	Y+2, r22	; 0x02

	MSPI_VidChipSelect(1);
    1f22:	81 e0       	ldi	r24, 0x01	; 1
    1f24:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
	MSPI_U8MasterTransmit(MCP2515_WRITE_INST);
    1f28:	82 e0       	ldi	r24, 0x02	; 2
    1f2a:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8RegAddress );
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
    1f30:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8Data);
    1f34:	8a 81       	ldd	r24, Y+2	; 0x02
    1f36:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_VidChipSelect(0);
    1f3a:	80 e0       	ldi	r24, 0x00	; 0
    1f3c:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
}
    1f40:	0f 90       	pop	r0
    1f42:	0f 90       	pop	r0
    1f44:	cf 91       	pop	r28
    1f46:	df 91       	pop	r29
    1f48:	08 95       	ret

00001f4a <HMCP2515_U8ReadReg>:
/*********** Write Section End ****************/

/*********** Read Section Start ****************/
u8 HMCP2515_U8ReadReg(u8 Copy_u8RegAddress)
{
    1f4a:	df 93       	push	r29
    1f4c:	cf 93       	push	r28
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <HMCP2515_U8ReadReg+0x6>
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
    1f54:	8a 83       	std	Y+2, r24	; 0x02
    u8 localValue2;
	MSPI_VidChipSelect(1);
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
	MSPI_U8MasterTransmit(MCP2515_READ_INST);
    1f5c:	83 e0       	ldi	r24, 0x03	; 3
    1f5e:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8RegAddress);
    1f62:	8a 81       	ldd	r24, Y+2	; 0x02
    1f64:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	localValue2 = MSPI_U8MasterTransmit(0);
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
    1f6e:	89 83       	std	Y+1, r24	; 0x01
	MSPI_VidChipSelect(0);
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
    return localValue2;
    1f76:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f78:	0f 90       	pop	r0
    1f7a:	0f 90       	pop	r0
    1f7c:	cf 91       	pop	r28
    1f7e:	df 91       	pop	r29
    1f80:	08 95       	ret

00001f82 <HMCP2515_voidResetInst>:
/*********** Read Section End ****************/

/*********** Reset Section Start ****************/
void HMCP2515_voidResetInst(void)
{
    1f82:	df 93       	push	r29
    1f84:	cf 93       	push	r28
    1f86:	cd b7       	in	r28, 0x3d	; 61
    1f88:	de b7       	in	r29, 0x3e	; 62
	MSPI_VidChipSelect(1);
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
	MSPI_U8MasterTransmit(MCP2515_RESET_INST);
    1f90:	80 ec       	ldi	r24, 0xC0	; 192
    1f92:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_VidChipSelect(0);
    1f96:	80 e0       	ldi	r24, 0x00	; 0
    1f98:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
}
    1f9c:	cf 91       	pop	r28
    1f9e:	df 91       	pop	r29
    1fa0:	08 95       	ret

00001fa2 <HMCP2515_voidBitModify>:
/*********** Reset Instruction End ****************/

/*********** Bit Modify Section Start ****************/
void  HMCP2515_voidBitModify(u8 Copy_RegAddress ,u8 Copy_u8Mask,u8 Copy_U8Data )
{
    1fa2:	df 93       	push	r29
    1fa4:	cf 93       	push	r28
    1fa6:	00 d0       	rcall	.+0      	; 0x1fa8 <HMCP2515_voidBitModify+0x6>
    1fa8:	0f 92       	push	r0
    1faa:	cd b7       	in	r28, 0x3d	; 61
    1fac:	de b7       	in	r29, 0x3e	; 62
    1fae:	89 83       	std	Y+1, r24	; 0x01
    1fb0:	6a 83       	std	Y+2, r22	; 0x02
    1fb2:	4b 83       	std	Y+3, r20	; 0x03

	MSPI_VidChipSelect(1);
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
	MSPI_U8MasterTransmit(MCP2515_BITMODIFY_INST );
    1fba:	85 e0       	ldi	r24, 0x05	; 5
    1fbc:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_RegAddress);
    1fc0:	89 81       	ldd	r24, Y+1	; 0x01
    1fc2:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8Mask);
    1fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc8:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_U8Data);
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_VidChipSelect(0);
    1fd2:	80 e0       	ldi	r24, 0x00	; 0
    1fd4:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>

}
    1fd8:	0f 90       	pop	r0
    1fda:	0f 90       	pop	r0
    1fdc:	0f 90       	pop	r0
    1fde:	cf 91       	pop	r28
    1fe0:	df 91       	pop	r29
    1fe2:	08 95       	ret

00001fe4 <HMCP2515_voidSetBitTiming>:
/*********** Bit Modify Section End ****************/

/*********** Bit Timing Section Start ****************/
void HMCP2515_voidSetBitTiming(u8 Copy_U8CNFVAL1 ,u8 Copy_U8CNFVAL2 ,u8 Copy_U8CNFVAL3)
{
    1fe4:	df 93       	push	r29
    1fe6:	cf 93       	push	r28
    1fe8:	00 d0       	rcall	.+0      	; 0x1fea <HMCP2515_voidSetBitTiming+0x6>
    1fea:	0f 92       	push	r0
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
    1ff0:	89 83       	std	Y+1, r24	; 0x01
    1ff2:	6a 83       	std	Y+2, r22	; 0x02
    1ff4:	4b 83       	std	Y+3, r20	; 0x03
     * 1 TQ for Synch bit
     * 6 TQ for Phase segment 2
     * 2 TQ For Propagation Segment
     * 7 TQ For Phase segment 1
     */
	HMCP2515_voidWriteReg(CNF1,Copy_U8CNFVAL1);
    1ff6:	8a e2       	ldi	r24, 0x2A	; 42
    1ff8:	69 81       	ldd	r22, Y+1	; 0x01
    1ffa:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
	HMCP2515_voidWriteReg(CNF2,Copy_U8CNFVAL2);
    1ffe:	89 e2       	ldi	r24, 0x29	; 41
    2000:	6a 81       	ldd	r22, Y+2	; 0x02
    2002:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
	HMCP2515_voidWriteReg(CNF3,Copy_U8CNFVAL3);
    2006:	88 e2       	ldi	r24, 0x28	; 40
    2008:	6b 81       	ldd	r22, Y+3	; 0x03
    200a:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
}
    200e:	0f 90       	pop	r0
    2010:	0f 90       	pop	r0
    2012:	0f 90       	pop	r0
    2014:	cf 91       	pop	r28
    2016:	df 91       	pop	r29
    2018:	08 95       	ret

0000201a <HMCP2515_voidSetMode>:
/*********** Bit Timing Section End ****************/

/*********** Set Mode Inst Section Start ****************/
void HMCP2515_voidSetMode(u8 Copy_U8Mode)
{
    201a:	df 93       	push	r29
    201c:	cf 93       	push	r28
    201e:	0f 92       	push	r0
    2020:	cd b7       	in	r28, 0x3d	; 61
    2022:	de b7       	in	r29, 0x3e	; 62
    2024:	89 83       	std	Y+1, r24	; 0x01
    HMCP2515_voidBitModify(CANCTRL ,0XE0,(Copy_U8Mode<<5));
    2026:	89 81       	ldd	r24, Y+1	; 0x01
    2028:	98 2f       	mov	r25, r24
    202a:	92 95       	swap	r25
    202c:	99 0f       	add	r25, r25
    202e:	90 7e       	andi	r25, 0xE0	; 224
    2030:	8f e0       	ldi	r24, 0x0F	; 15
    2032:	60 ee       	ldi	r22, 0xE0	; 224
    2034:	49 2f       	mov	r20, r25
    2036:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <HMCP2515_voidBitModify>
	//HMCP2515_voidWriteReg(CANCTRL,(Copy_U8Mode<<5));
    //u8 local1=HMCP2515_U8ReadReg(CANSTAT);
	while((HMCP2515_U8ReadReg(CANSTAT)>>5)!=Copy_U8Mode);
    203a:	8e e0       	ldi	r24, 0x0E	; 14
    203c:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <HMCP2515_U8ReadReg>
    2040:	98 2f       	mov	r25, r24
    2042:	92 95       	swap	r25
    2044:	96 95       	lsr	r25
    2046:	97 70       	andi	r25, 0x07	; 7
    2048:	89 81       	ldd	r24, Y+1	; 0x01
    204a:	98 17       	cp	r25, r24
    204c:	b1 f7       	brne	.-20     	; 0x203a <HMCP2515_voidSetMode+0x20>
		HMCP2515_voidBitModify(CANCTRL ,0XE0,Copy_U8Mode<<5);
		 MCAL_DIO_voidSETBIT(PC,PC0,LOW);

	}*/

}
    204e:	0f 90       	pop	r0
    2050:	cf 91       	pop	r28
    2052:	df 91       	pop	r29
    2054:	08 95       	ret

00002056 <HMCP2515_voidInitTransimiter>:
/*********** Set Mode Inst Section End ****************/

/************* Transmitter initialization Section Start ******************/
void HMCP2515_voidInitTransimiter(void)
{
    2056:	df 93       	push	r29
    2058:	cf 93       	push	r28
    205a:	cd b7       	in	r28, 0x3d	; 61
    205c:	de b7       	in	r29, 0x3e	; 62
	  //MCAL_DIO_voidDirectionPIN(PC,PC0,OUTPUT);
	  MSPI_voidSpiMasterInit();
    205e:	0e 94 2d 08 	call	0x105a	; 0x105a <MSPI_voidSpiMasterInit>
	  HMCP2515_voidResetInst();
    2062:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <HMCP2515_voidResetInst>

	  /* enter conf mode and enable clock */
	  HMCP2515_voidWriteReg(CANCTRL,0x87);
    2066:	8f e0       	ldi	r24, 0x0F	; 15
    2068:	67 e8       	ldi	r22, 0x87	; 135
    206a:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
	   */
	 // HMCP2515_voidSetMode(CONFIG_MODE);

	 // HMCP2515_voidBitModify(CANCTRL ,0X04,0x04);
     // u8 local =HMCP2515_U8ReadReg(CANSTAT);
	 while((HMCP2515_U8ReadReg(CANSTAT)>>5) != CONFIG_MODE);
    206e:	8e e0       	ldi	r24, 0x0E	; 14
    2070:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <HMCP2515_U8ReadReg>
    2074:	82 95       	swap	r24
    2076:	86 95       	lsr	r24
    2078:	87 70       	andi	r24, 0x07	; 7
    207a:	84 30       	cpi	r24, 0x04	; 4
    207c:	c1 f7       	brne	.-16     	; 0x206e <HMCP2515_voidInitTransimiter+0x18>
	/* to run at 250KHz bitrate using 8MHz osc */
	 HMCP2515_voidSetBitTiming(2<<6, (1<<7)|(6<<3)|(1), (0x15));
    207e:	80 e8       	ldi	r24, 0x80	; 128
    2080:	61 eb       	ldi	r22, 0xB1	; 177
    2082:	45 e1       	ldi	r20, 0x15	; 21
    2084:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <HMCP2515_voidSetBitTiming>
	// HMCP2515_voidSetBitTiming(0x80,0xB1,0x05);
  /*  return to normal mode sending ans Recieving*/
	  HMCP2515_voidSetMode(NORMAL_MODE);
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	0e 94 0d 10 	call	0x201a	; 0x201a <HMCP2515_voidSetMode>

}
    208e:	cf 91       	pop	r28
    2090:	df 91       	pop	r29
    2092:	08 95       	ret

00002094 <HMCP2515_VidSendCAN_Msg>:
/************* Transmitter initialization Section End  ******************/

/******************Transmitter Sending Message Start ****************/
void HMCP2515_VidSendCAN_Msg(u8 Copy_u8Address ,u32 Copy_u8MsgID, u8 Copy_u8DataLen_DLC , u8*Copy_u8data)
{
    2094:	df 93       	push	r29
    2096:	cf 93       	push	r28
    2098:	cd b7       	in	r28, 0x3d	; 61
    209a:	de b7       	in	r29, 0x3e	; 62
    209c:	28 97       	sbiw	r28, 0x08	; 8
    209e:	0f b6       	in	r0, 0x3f	; 63
    20a0:	f8 94       	cli
    20a2:	de bf       	out	0x3e, r29	; 62
    20a4:	0f be       	out	0x3f, r0	; 63
    20a6:	cd bf       	out	0x3d, r28	; 61
    20a8:	8b 83       	std	Y+3, r24	; 0x03
    20aa:	7d 83       	std	Y+5, r23	; 0x05
    20ac:	6c 83       	std	Y+4, r22	; 0x04
    20ae:	4e 83       	std	Y+6, r20	; 0x06
    20b0:	38 87       	std	Y+8, r19	; 0x08
    20b2:	2f 83       	std	Y+7, r18	; 0x07
	MSPI_VidChipSelect(1);
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>

	MSPI_U8MasterTransmit(MCP2515_WRITE_INST);
    20ba:	82 e0       	ldi	r24, 0x02	; 2
    20bc:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8Address);
    20c0:	8b 81       	ldd	r24, Y+3	; 0x03
    20c2:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	/* any data can send Highest priority  (Mandatory)*/
	MSPI_U8MasterTransmit(0x03);
    20c6:	83 e0       	ldi	r24, 0x03	; 3
    20c8:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	/* full IDH */
	MSPI_U8MasterTransmit((u8)(Copy_u8MsgID>>3));
    20cc:	8c 81       	ldd	r24, Y+4	; 0x04
    20ce:	9d 81       	ldd	r25, Y+5	; 0x05
    20d0:	96 95       	lsr	r25
    20d2:	87 95       	ror	r24
    20d4:	96 95       	lsr	r25
    20d6:	87 95       	ror	r24
    20d8:	96 95       	lsr	r25
    20da:	87 95       	ror	r24
    20dc:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit((u8)(Copy_u8MsgID<<5));
    20e0:	8c 81       	ldd	r24, Y+4	; 0x04
    20e2:	82 95       	swap	r24
    20e4:	88 0f       	add	r24, r24
    20e6:	80 7e       	andi	r24, 0xE0	; 224
    20e8:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(0);
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(0);
    20f2:	80 e0       	ldi	r24, 0x00	; 0
    20f4:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	/* DLC IS 1000 RTR IS 0 SO WRITE  */
	MSPI_U8MasterTransmit(Copy_u8DataLen_DLC&0x0F);
    20f8:	8e 81       	ldd	r24, Y+6	; 0x06
    20fa:	8f 70       	andi	r24, 0x0F	; 15
    20fc:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	/* send data */
	for(int i =0; i<(Copy_u8DataLen_DLC&0x0F);i++)
    2100:	1a 82       	std	Y+2, r1	; 0x02
    2102:	19 82       	std	Y+1, r1	; 0x01
    2104:	0f c0       	rjmp	.+30     	; 0x2124 <HMCP2515_VidSendCAN_Msg+0x90>
	{
		MSPI_U8MasterTransmit(Copy_u8data[i]);
    2106:	29 81       	ldd	r18, Y+1	; 0x01
    2108:	3a 81       	ldd	r19, Y+2	; 0x02
    210a:	8f 81       	ldd	r24, Y+7	; 0x07
    210c:	98 85       	ldd	r25, Y+8	; 0x08
    210e:	fc 01       	movw	r30, r24
    2110:	e2 0f       	add	r30, r18
    2112:	f3 1f       	adc	r31, r19
    2114:	80 81       	ld	r24, Z
    2116:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(0);
	MSPI_U8MasterTransmit(0);
	/* DLC IS 1000 RTR IS 0 SO WRITE  */
	MSPI_U8MasterTransmit(Copy_u8DataLen_DLC&0x0F);
	/* send data */
	for(int i =0; i<(Copy_u8DataLen_DLC&0x0F);i++)
    211a:	89 81       	ldd	r24, Y+1	; 0x01
    211c:	9a 81       	ldd	r25, Y+2	; 0x02
    211e:	01 96       	adiw	r24, 0x01	; 1
    2120:	9a 83       	std	Y+2, r25	; 0x02
    2122:	89 83       	std	Y+1, r24	; 0x01
    2124:	8e 81       	ldd	r24, Y+6	; 0x06
    2126:	88 2f       	mov	r24, r24
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	9c 01       	movw	r18, r24
    212c:	2f 70       	andi	r18, 0x0F	; 15
    212e:	30 70       	andi	r19, 0x00	; 0
    2130:	89 81       	ldd	r24, Y+1	; 0x01
    2132:	9a 81       	ldd	r25, Y+2	; 0x02
    2134:	82 17       	cp	r24, r18
    2136:	93 07       	cpc	r25, r19
    2138:	34 f3       	brlt	.-52     	; 0x2106 <HMCP2515_VidSendCAN_Msg+0x72>
	{
		MSPI_U8MasterTransmit(Copy_u8data[i]);
	}

	/* good bye for bus */
	MSPI_VidChipSelect(0);
    213a:	80 e0       	ldi	r24, 0x00	; 0
    213c:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>

	/* Request to send data */
	MSPI_VidChipSelect(1);
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>

	MSPI_U8MasterTransmit(MCP2515_MREG2SENDTXB0_INST);
    2146:	81 e8       	ldi	r24, 0x81	; 129
    2148:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>

	MSPI_VidChipSelect(0);
    214c:	80 e0       	ldi	r24, 0x00	; 0
    214e:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>


}
    2152:	28 96       	adiw	r28, 0x08	; 8
    2154:	0f b6       	in	r0, 0x3f	; 63
    2156:	f8 94       	cli
    2158:	de bf       	out	0x3e, r29	; 62
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	cd bf       	out	0x3d, r28	; 61
    215e:	cf 91       	pop	r28
    2160:	df 91       	pop	r29
    2162:	08 95       	ret

00002164 <HMCP2515_voidRollOver>:
*/

/**** Declaration End  *****/

void HMCP2515_voidRollOver(u8 Copy_u8BUKT)
	{
    2164:	df 93       	push	r29
    2166:	cf 93       	push	r28
    2168:	0f 92       	push	r0
    216a:	cd b7       	in	r28, 0x3d	; 61
    216c:	de b7       	in	r29, 0x3e	; 62
    216e:	89 83       	std	Y+1, r24	; 0x01
		HMCP2515_voidBitModify(RXB0CTRL , 1<<Copy_u8BUKT, 1<<Copy_u8BUKT );
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	28 2f       	mov	r18, r24
    2174:	30 e0       	ldi	r19, 0x00	; 0
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	02 c0       	rjmp	.+4      	; 0x2180 <HMCP2515_voidRollOver+0x1c>
    217c:	88 0f       	add	r24, r24
    217e:	99 1f       	adc	r25, r25
    2180:	2a 95       	dec	r18
    2182:	e2 f7       	brpl	.-8      	; 0x217c <HMCP2515_voidRollOver+0x18>
    2184:	48 2f       	mov	r20, r24
    2186:	89 81       	ldd	r24, Y+1	; 0x01
    2188:	28 2f       	mov	r18, r24
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	02 c0       	rjmp	.+4      	; 0x2196 <HMCP2515_voidRollOver+0x32>
    2192:	88 0f       	add	r24, r24
    2194:	99 1f       	adc	r25, r25
    2196:	2a 95       	dec	r18
    2198:	e2 f7       	brpl	.-8      	; 0x2192 <HMCP2515_voidRollOver+0x2e>
    219a:	98 2f       	mov	r25, r24
    219c:	80 e6       	ldi	r24, 0x60	; 96
    219e:	64 2f       	mov	r22, r20
    21a0:	49 2f       	mov	r20, r25
    21a2:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <HMCP2515_voidBitModify>
	}
    21a6:	0f 90       	pop	r0
    21a8:	cf 91       	pop	r28
    21aa:	df 91       	pop	r29
    21ac:	08 95       	ret

000021ae <HMCP2515_voidSetMask>:

void HMCP2515_voidSetMask(u8 Copy_u8address_mask_Reg ,u32 Copy_u32Mask_Value ,u8 Copy_u8Extended)
{
    21ae:	df 93       	push	r29
    21b0:	cf 93       	push	r28
    21b2:	00 d0       	rcall	.+0      	; 0x21b4 <HMCP2515_voidSetMask+0x6>
    21b4:	00 d0       	rcall	.+0      	; 0x21b6 <HMCP2515_voidSetMask+0x8>
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	89 83       	std	Y+1, r24	; 0x01
    21bc:	7b 83       	std	Y+3, r23	; 0x03
    21be:	6a 83       	std	Y+2, r22	; 0x02
    21c0:	4c 83       	std	Y+4, r20	; 0x04
		  MSPI_VidChipSelect(1);
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
		  MSPI_U8MasterTransmit(MCP2515_WRITE_INST);
    21c8:	82 e0       	ldi	r24, 0x02	; 2
    21ca:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
		  MSPI_U8MasterTransmit(Copy_u8address_mask_Reg);
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	  if(Copy_u8Extended)
    21d4:	8c 81       	ldd	r24, Y+4	; 0x04
    21d6:	88 23       	and	r24, r24
    21d8:	51 f1       	breq	.+84     	; 0x222e <HMCP2515_voidSetMask+0x80>
	  {
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value>>3));
    21da:	8a 81       	ldd	r24, Y+2	; 0x02
    21dc:	9b 81       	ldd	r25, Y+3	; 0x03
    21de:	96 95       	lsr	r25
    21e0:	87 95       	ror	r24
    21e2:	96 95       	lsr	r25
    21e4:	87 95       	ror	r24
    21e6:	96 95       	lsr	r25
    21e8:	87 95       	ror	r24
    21ea:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value<<5));
    21ee:	8a 81       	ldd	r24, Y+2	; 0x02
    21f0:	82 95       	swap	r24
    21f2:	88 0f       	add	r24, r24
    21f4:	80 7e       	andi	r24, 0xE0	; 224
    21f6:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value>>3)|(u8)(Copy_u32Mask_Value>>27));
    21fa:	8a 81       	ldd	r24, Y+2	; 0x02
    21fc:	9b 81       	ldd	r25, Y+3	; 0x03
    21fe:	96 95       	lsr	r25
    2200:	87 95       	ror	r24
    2202:	96 95       	lsr	r25
    2204:	87 95       	ror	r24
    2206:	96 95       	lsr	r25
    2208:	87 95       	ror	r24
    220a:	28 2f       	mov	r18, r24
    220c:	8a 81       	ldd	r24, Y+2	; 0x02
    220e:	9b 81       	ldd	r25, Y+3	; 0x03
    2210:	99 27       	eor	r25, r25
    2212:	88 27       	eor	r24, r24
    2214:	82 2b       	or	r24, r18
    2216:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value>>11));
    221a:	8a 81       	ldd	r24, Y+2	; 0x02
    221c:	9b 81       	ldd	r25, Y+3	; 0x03
    221e:	89 2f       	mov	r24, r25
    2220:	99 27       	eor	r25, r25
    2222:	86 95       	lsr	r24
    2224:	86 95       	lsr	r24
    2226:	86 95       	lsr	r24
    2228:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
    222c:	10 c0       	rjmp	.+32     	; 0x224e <HMCP2515_voidSetMask+0xa0>
	  }
	  else
	  {
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value>>3));
    222e:	8a 81       	ldd	r24, Y+2	; 0x02
    2230:	9b 81       	ldd	r25, Y+3	; 0x03
    2232:	96 95       	lsr	r25
    2234:	87 95       	ror	r24
    2236:	96 95       	lsr	r25
    2238:	87 95       	ror	r24
    223a:	96 95       	lsr	r25
    223c:	87 95       	ror	r24
    223e:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
		  MSPI_U8MasterTransmit((u8)(Copy_u32Mask_Value<<5));
    2242:	8a 81       	ldd	r24, Y+2	; 0x02
    2244:	82 95       	swap	r24
    2246:	88 0f       	add	r24, r24
    2248:	80 7e       	andi	r24, 0xE0	; 224
    224a:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	  }
	    MSPI_VidChipSelect(0);
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
}
    2254:	0f 90       	pop	r0
    2256:	0f 90       	pop	r0
    2258:	0f 90       	pop	r0
    225a:	0f 90       	pop	r0
    225c:	cf 91       	pop	r28
    225e:	df 91       	pop	r29
    2260:	08 95       	ret

00002262 <HMCP2515_voidRecievInit>:

void HMCP2515_voidRecievInit(void)
{
    2262:	df 93       	push	r29
    2264:	cf 93       	push	r28
    2266:	cd b7       	in	r28, 0x3d	; 61
    2268:	de b7       	in	r29, 0x3e	; 62
	MSPI_voidSpiMasterInit();
    226a:	0e 94 2d 08 	call	0x105a	; 0x105a <MSPI_voidSpiMasterInit>
	HMCP2515_voidResetInst();
    226e:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <HMCP2515_voidResetInst>
	/* CONFIG mode and Enable clock */
	HMCP2515_voidWriteReg(CANCTRL,0x87);
    2272:	8f e0       	ldi	r24, 0x0F	; 15
    2274:	67 e8       	ldi	r22, 0x87	; 135
    2276:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
	/*
	 */
	while((HMCP2515_U8ReadReg(CANSTAT)>>5) != CONFIG_MODE){}
    227a:	8e e0       	ldi	r24, 0x0E	; 14
    227c:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <HMCP2515_U8ReadReg>
    2280:	82 95       	swap	r24
    2282:	86 95       	lsr	r24
    2284:	87 70       	andi	r24, 0x07	; 7
    2286:	84 30       	cpi	r24, 0x04	; 4
    2288:	c1 f7       	brne	.-16     	; 0x227a <HMCP2515_voidRecievInit+0x18>
     //8MHZ
	 HMCP2515_voidSetBitTiming(2<<6, (1<<7)|(6<<3)|(1), (0x15));
    228a:	80 e8       	ldi	r24, 0x80	; 128
    228c:	61 eb       	ldi	r22, 0xB1	; 177
    228e:	45 e1       	ldi	r20, 0x15	; 21
    2290:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <HMCP2515_voidSetBitTiming>

	HMCP2515_voidSetMask(RXM0SIDH, 0x00000000, 1);
    2294:	80 e2       	ldi	r24, 0x20	; 32
    2296:	60 e0       	ldi	r22, 0x00	; 0
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	41 e0       	ldi	r20, 0x01	; 1
    229c:	0e 94 d7 10 	call	0x21ae	; 0x21ae <HMCP2515_voidSetMask>
	HMCP2515_voidSetMask(RXM1SIDH, 0x00000000, 1);
    22a0:	84 e2       	ldi	r24, 0x24	; 36
    22a2:	60 e0       	ldi	r22, 0x00	; 0
    22a4:	70 e0       	ldi	r23, 0x00	; 0
    22a6:	41 e0       	ldi	r20, 0x01	; 1
    22a8:	0e 94 d7 10 	call	0x21ae	; 0x21ae <HMCP2515_voidSetMask>

	HMCP2515_voidRollOver(1);
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	0e 94 b2 10 	call	0x2164	; 0x2164 <HMCP2515_voidRollOver>

	HMCP2515_voidBitModify(CANINTE, 1<<0, 1<<RX0IE);
    22b2:	8b e2       	ldi	r24, 0x2B	; 43
    22b4:	61 e0       	ldi	r22, 0x01	; 1
    22b6:	41 e0       	ldi	r20, 0x01	; 1
    22b8:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <HMCP2515_voidBitModify>

	HMCP2515_voidSetMode(NORMAL_MODE);
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	0e 94 0d 10 	call	0x201a	; 0x201a <HMCP2515_voidSetMode>
}
    22c2:	cf 91       	pop	r28
    22c4:	df 91       	pop	r29
    22c6:	08 95       	ret

000022c8 <HMCP2515_voidRecieveMess>:

void HMCP2515_voidRecieveMess(u8 Copy_u8REC_Buff_addres)
{
    22c8:	0f 93       	push	r16
    22ca:	1f 93       	push	r17
    22cc:	df 93       	push	r29
    22ce:	cf 93       	push	r28
    22d0:	00 d0       	rcall	.+0      	; 0x22d2 <HMCP2515_voidRecieveMess+0xa>
    22d2:	cd b7       	in	r28, 0x3d	; 61
    22d4:	de b7       	in	r29, 0x3e	; 62
    22d6:	8a 83       	std	Y+2, r24	; 0x02

	MSPI_VidChipSelect(1);
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>

	MSPI_U8MasterTransmit(MCP2515_READ_INST);
    22de:	83 e0       	ldi	r24, 0x03	; 3
    22e0:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
	MSPI_U8MasterTransmit(Copy_u8REC_Buff_addres);
    22e4:	8a 81       	ldd	r24, Y+2	; 0x02
    22e6:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>

     for (u8 buff_index = 0 ; buff_index < 14; buff_index++)
    22ea:	19 82       	std	Y+1, r1	; 0x01
    22ec:	0d c0       	rjmp	.+26     	; 0x2308 <HMCP2515_voidRecieveMess+0x40>
     {
    	 REC_Message[buff_index]=MSPI_U8MasterTransmit(0);
    22ee:	89 81       	ldd	r24, Y+1	; 0x01
    22f0:	08 2f       	mov	r16, r24
    22f2:	10 e0       	ldi	r17, 0x00	; 0
    22f4:	80 e0       	ldi	r24, 0x00	; 0
    22f6:	0e 94 77 09 	call	0x12ee	; 0x12ee <MSPI_U8MasterTransmit>
    22fa:	f8 01       	movw	r30, r16
    22fc:	e6 53       	subi	r30, 0x36	; 54
    22fe:	f9 4f       	sbci	r31, 0xF9	; 249
    2300:	80 83       	st	Z, r24
	MSPI_VidChipSelect(1);

	MSPI_U8MasterTransmit(MCP2515_READ_INST);
	MSPI_U8MasterTransmit(Copy_u8REC_Buff_addres);

     for (u8 buff_index = 0 ; buff_index < 14; buff_index++)
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	8f 5f       	subi	r24, 0xFF	; 255
    2306:	89 83       	std	Y+1, r24	; 0x01
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	8e 30       	cpi	r24, 0x0E	; 14
    230c:	80 f3       	brcs	.-32     	; 0x22ee <HMCP2515_voidRecieveMess+0x26>
     {
    	 REC_Message[buff_index]=MSPI_U8MasterTransmit(0);
     }

	MSPI_VidChipSelect(0);
    230e:	80 e0       	ldi	r24, 0x00	; 0
    2310:	0e 94 5f 09 	call	0x12be	; 0x12be <MSPI_VidChipSelect>
	/*Clear Flag  */
	HMCP2515_voidWriteReg(CANINTF,0);
    2314:	8c e2       	ldi	r24, 0x2C	; 44
    2316:	60 e0       	ldi	r22, 0x00	; 0
    2318:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <HMCP2515_voidWriteReg>
}
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	cf 91       	pop	r28
    2322:	df 91       	pop	r29
    2324:	1f 91       	pop	r17
    2326:	0f 91       	pop	r16
    2328:	08 95       	ret

0000232a <LED_u8Mapping>:

/*
 *This function takes the led number, and returns the port and pin of that specific led;
 * it also return 1 if the led exist(between 1 and 8), 0 Otherwise;
 */
static u8 LED_u8Mapping(u8 Copy_u8LedNumber, u8 *Copy_u8PortPtr, u8 *Copy_u8PinPtr){
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	cd b7       	in	r28, 0x3d	; 61
    2330:	de b7       	in	r29, 0x3e	; 62
    2332:	28 97       	sbiw	r28, 0x08	; 8
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	de bf       	out	0x3e, r29	; 62
    233a:	0f be       	out	0x3f, r0	; 63
    233c:	cd bf       	out	0x3d, r28	; 61
    233e:	8a 83       	std	Y+2, r24	; 0x02
    2340:	7c 83       	std	Y+4, r23	; 0x04
    2342:	6b 83       	std	Y+3, r22	; 0x03
    2344:	5e 83       	std	Y+6, r21	; 0x06
    2346:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8LedNumberStatus = 1;
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8LedNumber){
    234c:	8a 81       	ldd	r24, Y+2	; 0x02
    234e:	28 2f       	mov	r18, r24
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	38 87       	std	Y+8, r19	; 0x08
    2354:	2f 83       	std	Y+7, r18	; 0x07
    2356:	8f 81       	ldd	r24, Y+7	; 0x07
    2358:	98 85       	ldd	r25, Y+8	; 0x08
    235a:	84 30       	cpi	r24, 0x04	; 4
    235c:	91 05       	cpc	r25, r1
    235e:	09 f4       	brne	.+2      	; 0x2362 <LED_u8Mapping+0x38>
    2360:	41 c0       	rjmp	.+130    	; 0x23e4 <LED_u8Mapping+0xba>
    2362:	2f 81       	ldd	r18, Y+7	; 0x07
    2364:	38 85       	ldd	r19, Y+8	; 0x08
    2366:	25 30       	cpi	r18, 0x05	; 5
    2368:	31 05       	cpc	r19, r1
    236a:	84 f4       	brge	.+32     	; 0x238c <LED_u8Mapping+0x62>
    236c:	8f 81       	ldd	r24, Y+7	; 0x07
    236e:	98 85       	ldd	r25, Y+8	; 0x08
    2370:	82 30       	cpi	r24, 0x02	; 2
    2372:	91 05       	cpc	r25, r1
    2374:	39 f1       	breq	.+78     	; 0x23c4 <LED_u8Mapping+0x9a>
    2376:	2f 81       	ldd	r18, Y+7	; 0x07
    2378:	38 85       	ldd	r19, Y+8	; 0x08
    237a:	23 30       	cpi	r18, 0x03	; 3
    237c:	31 05       	cpc	r19, r1
    237e:	54 f5       	brge	.+84     	; 0x23d4 <LED_u8Mapping+0xaa>
    2380:	8f 81       	ldd	r24, Y+7	; 0x07
    2382:	98 85       	ldd	r25, Y+8	; 0x08
    2384:	81 30       	cpi	r24, 0x01	; 1
    2386:	91 05       	cpc	r25, r1
    2388:	b1 f0       	breq	.+44     	; 0x23b6 <LED_u8Mapping+0x8c>
    238a:	54 c0       	rjmp	.+168    	; 0x2434 <LED_u8Mapping+0x10a>
    238c:	2f 81       	ldd	r18, Y+7	; 0x07
    238e:	38 85       	ldd	r19, Y+8	; 0x08
    2390:	26 30       	cpi	r18, 0x06	; 6
    2392:	31 05       	cpc	r19, r1
    2394:	b9 f1       	breq	.+110    	; 0x2404 <LED_u8Mapping+0xda>
    2396:	8f 81       	ldd	r24, Y+7	; 0x07
    2398:	98 85       	ldd	r25, Y+8	; 0x08
    239a:	86 30       	cpi	r24, 0x06	; 6
    239c:	91 05       	cpc	r25, r1
    239e:	54 f1       	brlt	.+84     	; 0x23f4 <LED_u8Mapping+0xca>
    23a0:	2f 81       	ldd	r18, Y+7	; 0x07
    23a2:	38 85       	ldd	r19, Y+8	; 0x08
    23a4:	27 30       	cpi	r18, 0x07	; 7
    23a6:	31 05       	cpc	r19, r1
    23a8:	a9 f1       	breq	.+106    	; 0x2414 <LED_u8Mapping+0xea>
    23aa:	8f 81       	ldd	r24, Y+7	; 0x07
    23ac:	98 85       	ldd	r25, Y+8	; 0x08
    23ae:	88 30       	cpi	r24, 0x08	; 8
    23b0:	91 05       	cpc	r25, r1
    23b2:	c1 f1       	breq	.+112    	; 0x2424 <LED_u8Mapping+0xfa>
    23b4:	3f c0       	rjmp	.+126    	; 0x2434 <LED_u8Mapping+0x10a>
			case LED_e_1:
				*Copy_u8PortPtr = LED_1_PORT;
    23b6:	eb 81       	ldd	r30, Y+3	; 0x03
    23b8:	fc 81       	ldd	r31, Y+4	; 0x04
    23ba:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_1_PIN;
    23bc:	ed 81       	ldd	r30, Y+5	; 0x05
    23be:	fe 81       	ldd	r31, Y+6	; 0x06
    23c0:	10 82       	st	Z, r1
    23c2:	39 c0       	rjmp	.+114    	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_2:
				*Copy_u8PortPtr = LED_2_PORT;
    23c4:	eb 81       	ldd	r30, Y+3	; 0x03
    23c6:	fc 81       	ldd	r31, Y+4	; 0x04
    23c8:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_2_PIN;
    23ca:	ed 81       	ldd	r30, Y+5	; 0x05
    23cc:	fe 81       	ldd	r31, Y+6	; 0x06
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	80 83       	st	Z, r24
    23d2:	31 c0       	rjmp	.+98     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_3:
				*Copy_u8PortPtr = LED_3_PORT;
    23d4:	eb 81       	ldd	r30, Y+3	; 0x03
    23d6:	fc 81       	ldd	r31, Y+4	; 0x04
    23d8:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_3_PIN;
    23da:	ed 81       	ldd	r30, Y+5	; 0x05
    23dc:	fe 81       	ldd	r31, Y+6	; 0x06
    23de:	82 e0       	ldi	r24, 0x02	; 2
    23e0:	80 83       	st	Z, r24
    23e2:	29 c0       	rjmp	.+82     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_4:
				*Copy_u8PortPtr = LED_4_PORT;
    23e4:	eb 81       	ldd	r30, Y+3	; 0x03
    23e6:	fc 81       	ldd	r31, Y+4	; 0x04
    23e8:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_4_PIN;
    23ea:	ed 81       	ldd	r30, Y+5	; 0x05
    23ec:	fe 81       	ldd	r31, Y+6	; 0x06
    23ee:	83 e0       	ldi	r24, 0x03	; 3
    23f0:	80 83       	st	Z, r24
    23f2:	21 c0       	rjmp	.+66     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_5:
				*Copy_u8PortPtr = LED_5_PORT;
    23f4:	eb 81       	ldd	r30, Y+3	; 0x03
    23f6:	fc 81       	ldd	r31, Y+4	; 0x04
    23f8:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_5_PIN;
    23fa:	ed 81       	ldd	r30, Y+5	; 0x05
    23fc:	fe 81       	ldd	r31, Y+6	; 0x06
    23fe:	84 e0       	ldi	r24, 0x04	; 4
    2400:	80 83       	st	Z, r24
    2402:	19 c0       	rjmp	.+50     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_6:
				*Copy_u8PortPtr = LED_6_PORT;
    2404:	eb 81       	ldd	r30, Y+3	; 0x03
    2406:	fc 81       	ldd	r31, Y+4	; 0x04
    2408:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_6_PIN;
    240a:	ed 81       	ldd	r30, Y+5	; 0x05
    240c:	fe 81       	ldd	r31, Y+6	; 0x06
    240e:	85 e0       	ldi	r24, 0x05	; 5
    2410:	80 83       	st	Z, r24
    2412:	11 c0       	rjmp	.+34     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_7:
				*Copy_u8PortPtr = LED_7_PORT;
    2414:	eb 81       	ldd	r30, Y+3	; 0x03
    2416:	fc 81       	ldd	r31, Y+4	; 0x04
    2418:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_7_PIN;
    241a:	ed 81       	ldd	r30, Y+5	; 0x05
    241c:	fe 81       	ldd	r31, Y+6	; 0x06
    241e:	86 e0       	ldi	r24, 0x06	; 6
    2420:	80 83       	st	Z, r24
    2422:	09 c0       	rjmp	.+18     	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			case LED_e_8:
				*Copy_u8PortPtr = LED_8_PORT;
    2424:	eb 81       	ldd	r30, Y+3	; 0x03
    2426:	fc 81       	ldd	r31, Y+4	; 0x04
    2428:	10 82       	st	Z, r1
				*Copy_u8PinPtr = LED_8_PIN;
    242a:	ed 81       	ldd	r30, Y+5	; 0x05
    242c:	fe 81       	ldd	r31, Y+6	; 0x06
    242e:	87 e0       	ldi	r24, 0x07	; 7
    2430:	80 83       	st	Z, r24
    2432:	01 c0       	rjmp	.+2      	; 0x2436 <LED_u8Mapping+0x10c>
				break;
			default:
				Local_u8LedNumberStatus = 0;
    2434:	19 82       	std	Y+1, r1	; 0x01
		}
	return Local_u8LedNumberStatus;
    2436:	89 81       	ldd	r24, Y+1	; 0x01
}
    2438:	28 96       	adiw	r28, 0x08	; 8
    243a:	0f b6       	in	r0, 0x3f	; 63
    243c:	f8 94       	cli
    243e:	de bf       	out	0x3e, r29	; 62
    2440:	0f be       	out	0x3f, r0	; 63
    2442:	cd bf       	out	0x3d, r28	; 61
    2444:	cf 91       	pop	r28
    2446:	df 91       	pop	r29
    2448:	08 95       	ret

0000244a <LED_vidInit>:
/*This function used to initialize the LEDs,
 * it takes:
 * 			1-the array address of type LED_e (this array contains the LEDs you want to initialize).
 * 			2-and the array size.
*/
void LED_vidInit(LED_e *arr_ptr, u8 Copy_u8LedsNumber){
    244a:	df 93       	push	r29
    244c:	cf 93       	push	r28
    244e:	00 d0       	rcall	.+0      	; 0x2450 <LED_vidInit+0x6>
    2450:	00 d0       	rcall	.+0      	; 0x2452 <LED_vidInit+0x8>
    2452:	cd b7       	in	r28, 0x3d	; 61
    2454:	de b7       	in	r29, 0x3e	; 62
    2456:	9b 83       	std	Y+3, r25	; 0x03
    2458:	8a 83       	std	Y+2, r24	; 0x02
    245a:	6c 83       	std	Y+4, r22	; 0x04
	for(u8 i=0; i < Copy_u8LedsNumber; i++){
    245c:	19 82       	std	Y+1, r1	; 0x01
    245e:	21 c0       	rjmp	.+66     	; 0x24a2 <LED_vidInit+0x58>
		LED_NUMBER_STATUS = LED_u8Mapping(arr_ptr[i], &LED_PORT, &LED_PIN);
    2460:	89 81       	ldd	r24, Y+1	; 0x01
    2462:	28 2f       	mov	r18, r24
    2464:	30 e0       	ldi	r19, 0x00	; 0
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	fc 01       	movw	r30, r24
    246c:	e2 0f       	add	r30, r18
    246e:	f3 1f       	adc	r31, r19
    2470:	80 81       	ld	r24, Z
    2472:	25 ea       	ldi	r18, 0xA5	; 165
    2474:	31 e0       	ldi	r19, 0x01	; 1
    2476:	46 ea       	ldi	r20, 0xA6	; 166
    2478:	51 e0       	ldi	r21, 0x01	; 1
    247a:	b9 01       	movw	r22, r18
    247c:	0e 94 95 11 	call	0x232a	; 0x232a <LED_u8Mapping>
    2480:	80 93 a4 01 	sts	0x01A4, r24
		if(LED_NUMBER_STATUS){
    2484:	80 91 a4 01 	lds	r24, 0x01A4
    2488:	88 23       	and	r24, r24
    248a:	41 f0       	breq	.+16     	; 0x249c <LED_vidInit+0x52>
			DIO_u8setPinDir(LED_PORT, LED_PIN, DIO_OUTPUT);
    248c:	80 91 a5 01 	lds	r24, 0x01A5
    2490:	90 91 a6 01 	lds	r25, 0x01A6
    2494:	69 2f       	mov	r22, r25
    2496:	41 e0       	ldi	r20, 0x01	; 1
    2498:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <DIO_u8setPinDir>
 * it takes:
 * 			1-the array address of type LED_e (this array contains the LEDs you want to initialize).
 * 			2-and the array size.
*/
void LED_vidInit(LED_e *arr_ptr, u8 Copy_u8LedsNumber){
	for(u8 i=0; i < Copy_u8LedsNumber; i++){
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	8f 5f       	subi	r24, 0xFF	; 255
    24a0:	89 83       	std	Y+1, r24	; 0x01
    24a2:	99 81       	ldd	r25, Y+1	; 0x01
    24a4:	8c 81       	ldd	r24, Y+4	; 0x04
    24a6:	98 17       	cp	r25, r24
    24a8:	d8 f2       	brcs	.-74     	; 0x2460 <LED_vidInit+0x16>
		LED_NUMBER_STATUS = LED_u8Mapping(arr_ptr[i], &LED_PORT, &LED_PIN);
		if(LED_NUMBER_STATUS){
			DIO_u8setPinDir(LED_PORT, LED_PIN, DIO_OUTPUT);
		}
	}
}
    24aa:	0f 90       	pop	r0
    24ac:	0f 90       	pop	r0
    24ae:	0f 90       	pop	r0
    24b0:	0f 90       	pop	r0
    24b2:	cf 91       	pop	r28
    24b4:	df 91       	pop	r29
    24b6:	08 95       	ret

000024b8 <LED_vidToggleLed>:

//This function used to toggle the led, it takes the led number;
void LED_vidToggleLed(u8 Copy_u8LedNumber){
    24b8:	df 93       	push	r29
    24ba:	cf 93       	push	r28
    24bc:	00 d0       	rcall	.+0      	; 0x24be <LED_vidToggleLed+0x6>
    24be:	cd b7       	in	r28, 0x3d	; 61
    24c0:	de b7       	in	r29, 0x3e	; 62
    24c2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8LedStatus;

	LED_NUMBER_STATUS = LED_u8Mapping(Copy_u8LedNumber, &LED_PORT, &LED_PIN);
    24c4:	25 ea       	ldi	r18, 0xA5	; 165
    24c6:	31 e0       	ldi	r19, 0x01	; 1
    24c8:	46 ea       	ldi	r20, 0xA6	; 166
    24ca:	51 e0       	ldi	r21, 0x01	; 1
    24cc:	8a 81       	ldd	r24, Y+2	; 0x02
    24ce:	b9 01       	movw	r22, r18
    24d0:	0e 94 95 11 	call	0x232a	; 0x232a <LED_u8Mapping>
    24d4:	80 93 a4 01 	sts	0x01A4, r24
	if(LED_NUMBER_STATUS){
    24d8:	80 91 a4 01 	lds	r24, 0x01A4
    24dc:	88 23       	and	r24, r24
    24de:	f9 f0       	breq	.+62     	; 0x251e <LED_vidToggleLed+0x66>
		DIO_u8getPinVal(LED_PORT, LED_PIN, &Local_u8LedStatus);
    24e0:	80 91 a5 01 	lds	r24, 0x01A5
    24e4:	90 91 a6 01 	lds	r25, 0x01A6
    24e8:	69 2f       	mov	r22, r25
    24ea:	9e 01       	movw	r18, r28
    24ec:	2f 5f       	subi	r18, 0xFF	; 255
    24ee:	3f 4f       	sbci	r19, 0xFF	; 255
    24f0:	a9 01       	movw	r20, r18
    24f2:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_u8getPinVal>
		if(Local_u8LedStatus){
    24f6:	89 81       	ldd	r24, Y+1	; 0x01
    24f8:	88 23       	and	r24, r24
    24fa:	49 f0       	breq	.+18     	; 0x250e <LED_vidToggleLed+0x56>
			DIO_u8setPinVal(LED_PORT, LED_PIN, DIO_LOW);
    24fc:	80 91 a5 01 	lds	r24, 0x01A5
    2500:	90 91 a6 01 	lds	r25, 0x01A6
    2504:	69 2f       	mov	r22, r25
    2506:	40 e0       	ldi	r20, 0x00	; 0
    2508:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
    250c:	08 c0       	rjmp	.+16     	; 0x251e <LED_vidToggleLed+0x66>
		}else{
			DIO_u8setPinVal(LED_PORT, LED_PIN, DIO_HIGH);
    250e:	80 91 a5 01 	lds	r24, 0x01A5
    2512:	90 91 a6 01 	lds	r25, 0x01A6
    2516:	69 2f       	mov	r22, r25
    2518:	41 e0       	ldi	r20, 0x01	; 1
    251a:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
		}
	}

}
    251e:	0f 90       	pop	r0
    2520:	0f 90       	pop	r0
    2522:	cf 91       	pop	r28
    2524:	df 91       	pop	r29
    2526:	08 95       	ret

00002528 <LED_vidTurnOnLed>:

//This function used to turn on the led, it takes the led number;
void LED_vidTurnOnLed(u8 Copy_u8LedNumber){
    2528:	df 93       	push	r29
    252a:	cf 93       	push	r28
    252c:	0f 92       	push	r0
    252e:	cd b7       	in	r28, 0x3d	; 61
    2530:	de b7       	in	r29, 0x3e	; 62
    2532:	89 83       	std	Y+1, r24	; 0x01
	LED_NUMBER_STATUS = LED_u8Mapping(Copy_u8LedNumber, &LED_PORT, &LED_PIN);
	if(LED_NUMBER_STATUS){
		DIO_u8setPinVal(LED_PORT, LED_PIN, HIGH);
	}
#elif LEDS_Configuration == COMMON_ANODE
	LED_NUMBER_STATUS = LED_u8Mapping(Copy_u8LedNumber, &LED_PORT, &LED_PIN);
    2534:	25 ea       	ldi	r18, 0xA5	; 165
    2536:	31 e0       	ldi	r19, 0x01	; 1
    2538:	46 ea       	ldi	r20, 0xA6	; 166
    253a:	51 e0       	ldi	r21, 0x01	; 1
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	b9 01       	movw	r22, r18
    2540:	0e 94 95 11 	call	0x232a	; 0x232a <LED_u8Mapping>
    2544:	80 93 a4 01 	sts	0x01A4, r24
	if(LED_NUMBER_STATUS){
    2548:	80 91 a4 01 	lds	r24, 0x01A4
    254c:	88 23       	and	r24, r24
    254e:	41 f0       	breq	.+16     	; 0x2560 <LED_vidTurnOnLed+0x38>
		DIO_u8setPinVal(LED_PORT, LED_PIN, DIO_LOW);
    2550:	80 91 a5 01 	lds	r24, 0x01A5
    2554:	90 91 a6 01 	lds	r25, 0x01A6
    2558:	69 2f       	mov	r22, r25
    255a:	40 e0       	ldi	r20, 0x00	; 0
    255c:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
	}
#endif
}
    2560:	0f 90       	pop	r0
    2562:	cf 91       	pop	r28
    2564:	df 91       	pop	r29
    2566:	08 95       	ret

00002568 <LED_vidTurnOffLed>:


//This function used to turn off the led, it takes the led number;
void LED_vidTurnOffLed(u8 Copy_u8LedNumber){
    2568:	df 93       	push	r29
    256a:	cf 93       	push	r28
    256c:	0f 92       	push	r0
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
    2572:	89 83       	std	Y+1, r24	; 0x01
	LED_NUMBER_STATUS = LED_u8Mapping(Copy_u8LedNumber, &LED_PORT, &LED_PIN);
	if(LED_NUMBER_STATUS){
		DIO_u8setPinVal(LED_PORT, LED_PIN, LOW);
	}
#elif LEDS_Configuration == COMMON_ANODE
	LED_NUMBER_STATUS = LED_u8Mapping(Copy_u8LedNumber, &LED_PORT, &LED_PIN);
    2574:	25 ea       	ldi	r18, 0xA5	; 165
    2576:	31 e0       	ldi	r19, 0x01	; 1
    2578:	46 ea       	ldi	r20, 0xA6	; 166
    257a:	51 e0       	ldi	r21, 0x01	; 1
    257c:	89 81       	ldd	r24, Y+1	; 0x01
    257e:	b9 01       	movw	r22, r18
    2580:	0e 94 95 11 	call	0x232a	; 0x232a <LED_u8Mapping>
    2584:	80 93 a4 01 	sts	0x01A4, r24
	if(LED_NUMBER_STATUS){
    2588:	80 91 a4 01 	lds	r24, 0x01A4
    258c:	88 23       	and	r24, r24
    258e:	41 f0       	breq	.+16     	; 0x25a0 <LED_vidTurnOffLed+0x38>
		DIO_u8setPinVal(LED_PORT, LED_PIN, DIO_HIGH);
    2590:	80 91 a5 01 	lds	r24, 0x01A5
    2594:	90 91 a6 01 	lds	r25, 0x01A6
    2598:	69 2f       	mov	r22, r25
    259a:	41 e0       	ldi	r20, 0x01	; 1
    259c:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <DIO_u8setPinVal>
	}
#endif
}
    25a0:	0f 90       	pop	r0
    25a2:	cf 91       	pop	r28
    25a4:	df 91       	pop	r29
    25a6:	08 95       	ret

000025a8 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    25a8:	af 92       	push	r10
    25aa:	bf 92       	push	r11
    25ac:	cf 92       	push	r12
    25ae:	df 92       	push	r13
    25b0:	ef 92       	push	r14
    25b2:	ff 92       	push	r15
    25b4:	0f 93       	push	r16
    25b6:	df 93       	push	r29
    25b8:	cf 93       	push	r28
    25ba:	0f 92       	push	r0
    25bc:	cd b7       	in	r28, 0x3d	; 61
    25be:	de b7       	in	r29, 0x3e	; 62
    25c0:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    25c2:	8a e0       	ldi	r24, 0x0A	; 10
    25c4:	62 e0       	ldi	r22, 0x02	; 2
    25c6:	40 e0       	ldi	r20, 0x00	; 0
    25c8:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <xQueueGenericCreate>
    25cc:	90 93 aa 01 	sts	0x01AA, r25
    25d0:	80 93 a9 01 	sts	0x01A9, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    25d4:	88 e5       	ldi	r24, 0x58	; 88
    25d6:	93 e1       	ldi	r25, 0x13	; 19
    25d8:	20 e6       	ldi	r18, 0x60	; 96
    25da:	30 e0       	ldi	r19, 0x00	; 0
    25dc:	e9 ea       	ldi	r30, 0xA9	; 169
    25de:	f1 e0       	ldi	r31, 0x01	; 1
    25e0:	b9 01       	movw	r22, r18
    25e2:	45 e5       	ldi	r20, 0x55	; 85
    25e4:	50 e0       	ldi	r21, 0x00	; 0
    25e6:	9f 01       	movw	r18, r30
    25e8:	09 81       	ldd	r16, Y+1	; 0x01
    25ea:	ee 24       	eor	r14, r14
    25ec:	ff 24       	eor	r15, r15
    25ee:	cc 24       	eor	r12, r12
    25f0:	dd 24       	eor	r13, r13
    25f2:	aa 24       	eor	r10, r10
    25f4:	bb 24       	eor	r11, r11
    25f6:	0e 94 da 26 	call	0x4db4	; 0x4db4 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    25fa:	8b e1       	ldi	r24, 0x1B	; 27
    25fc:	93 e1       	ldi	r25, 0x13	; 19
    25fe:	28 e6       	ldi	r18, 0x68	; 104
    2600:	30 e0       	ldi	r19, 0x00	; 0
    2602:	e9 ea       	ldi	r30, 0xA9	; 169
    2604:	f1 e0       	ldi	r31, 0x01	; 1
    2606:	b9 01       	movw	r22, r18
    2608:	45 e5       	ldi	r20, 0x55	; 85
    260a:	50 e0       	ldi	r21, 0x00	; 0
    260c:	9f 01       	movw	r18, r30
    260e:	09 81       	ldd	r16, Y+1	; 0x01
    2610:	ee 24       	eor	r14, r14
    2612:	ff 24       	eor	r15, r15
    2614:	cc 24       	eor	r12, r12
    2616:	dd 24       	eor	r13, r13
    2618:	aa 24       	eor	r10, r10
    261a:	bb 24       	eor	r11, r11
    261c:	0e 94 da 26 	call	0x4db4	; 0x4db4 <xTaskGenericCreate>
}
    2620:	0f 90       	pop	r0
    2622:	cf 91       	pop	r28
    2624:	df 91       	pop	r29
    2626:	0f 91       	pop	r16
    2628:	ff 90       	pop	r15
    262a:	ef 90       	pop	r14
    262c:	df 90       	pop	r13
    262e:	cf 90       	pop	r12
    2630:	bf 90       	pop	r11
    2632:	af 90       	pop	r10
    2634:	08 95       	ret

00002636 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2636:	df 93       	push	r29
    2638:	cf 93       	push	r28
    263a:	00 d0       	rcall	.+0      	; 0x263c <vPolledQueueProducer+0x6>
    263c:	00 d0       	rcall	.+0      	; 0x263e <vPolledQueueProducer+0x8>
    263e:	00 d0       	rcall	.+0      	; 0x2640 <vPolledQueueProducer+0xa>
    2640:	cd b7       	in	r28, 0x3d	; 61
    2642:	de b7       	in	r29, 0x3e	; 62
    2644:	9e 83       	std	Y+6, r25	; 0x06
    2646:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
    2648:	1c 82       	std	Y+4, r1	; 0x04
    264a:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
    264c:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    264e:	19 82       	std	Y+1, r1	; 0x01
    2650:	27 c0       	rjmp	.+78     	; 0x26a0 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2652:	ed 81       	ldd	r30, Y+5	; 0x05
    2654:	fe 81       	ldd	r31, Y+6	; 0x06
    2656:	80 81       	ld	r24, Z
    2658:	91 81       	ldd	r25, Z+1	; 0x01
    265a:	9e 01       	movw	r18, r28
    265c:	2d 5f       	subi	r18, 0xFD	; 253
    265e:	3f 4f       	sbci	r19, 0xFF	; 255
    2660:	b9 01       	movw	r22, r18
    2662:	40 e0       	ldi	r20, 0x00	; 0
    2664:	50 e0       	ldi	r21, 0x00	; 0
    2666:	20 e0       	ldi	r18, 0x00	; 0
    2668:	0e 94 7f 20 	call	0x40fe	; 0x40fe <xQueueGenericSend>
    266c:	81 30       	cpi	r24, 0x01	; 1
    266e:	19 f0       	breq	.+6      	; 0x2676 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	8a 83       	std	Y+2, r24	; 0x02
    2674:	12 c0       	rjmp	.+36     	; 0x269a <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
    2676:	8a 81       	ldd	r24, Y+2	; 0x02
    2678:	88 23       	and	r24, r24
    267a:	51 f4       	brne	.+20     	; 0x2690 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    267c:	0f b6       	in	r0, 0x3f	; 63
    267e:	f8 94       	cli
    2680:	0f 92       	push	r0
						xPollingProducerCount++;
    2682:	80 91 a8 01 	lds	r24, 0x01A8
    2686:	8f 5f       	subi	r24, 0xFF	; 255
    2688:	80 93 a8 01 	sts	0x01A8, r24
					portEXIT_CRITICAL();
    268c:	0f 90       	pop	r0
    268e:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2690:	8b 81       	ldd	r24, Y+3	; 0x03
    2692:	9c 81       	ldd	r25, Y+4	; 0x04
    2694:	01 96       	adiw	r24, 0x01	; 1
    2696:	9c 83       	std	Y+4, r25	; 0x04
    2698:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	8f 5f       	subi	r24, 0xFF	; 255
    269e:	89 83       	std	Y+1, r24	; 0x01
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
    26a2:	83 30       	cpi	r24, 0x03	; 3
    26a4:	b4 f2       	brlt	.-84     	; 0x2652 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    26a6:	88 ec       	ldi	r24, 0xC8	; 200
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	0e 94 94 28 	call	0x5128	; 0x5128 <vTaskDelay>
    26ae:	cf cf       	rjmp	.-98     	; 0x264e <vPolledQueueProducer+0x18>

000026b0 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    26b0:	df 93       	push	r29
    26b2:	cf 93       	push	r28
    26b4:	cd b7       	in	r28, 0x3d	; 61
    26b6:	de b7       	in	r29, 0x3e	; 62
    26b8:	27 97       	sbiw	r28, 0x07	; 7
    26ba:	0f b6       	in	r0, 0x3f	; 63
    26bc:	f8 94       	cli
    26be:	de bf       	out	0x3e, r29	; 62
    26c0:	0f be       	out	0x3f, r0	; 63
    26c2:	cd bf       	out	0x3d, r28	; 61
    26c4:	9f 83       	std	Y+7, r25	; 0x07
    26c6:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    26c8:	1b 82       	std	Y+3, r1	; 0x03
    26ca:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
    26cc:	19 82       	std	Y+1, r1	; 0x01
    26ce:	2f c0       	rjmp	.+94     	; 0x272e <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    26d0:	ee 81       	ldd	r30, Y+6	; 0x06
    26d2:	ff 81       	ldd	r31, Y+7	; 0x07
    26d4:	80 81       	ld	r24, Z
    26d6:	91 81       	ldd	r25, Z+1	; 0x01
    26d8:	9e 01       	movw	r18, r28
    26da:	2c 5f       	subi	r18, 0xFC	; 252
    26dc:	3f 4f       	sbci	r19, 0xFF	; 255
    26de:	b9 01       	movw	r22, r18
    26e0:	40 e0       	ldi	r20, 0x00	; 0
    26e2:	50 e0       	ldi	r21, 0x00	; 0
    26e4:	20 e0       	ldi	r18, 0x00	; 0
    26e6:	0e 94 8d 21 	call	0x431a	; 0x431a <xQueueGenericReceive>
    26ea:	81 30       	cpi	r24, 0x01	; 1
    26ec:	01 f5       	brne	.+64     	; 0x272e <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
    26ee:	2c 81       	ldd	r18, Y+4	; 0x04
    26f0:	3d 81       	ldd	r19, Y+5	; 0x05
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	28 17       	cp	r18, r24
    26f8:	39 07       	cpc	r19, r25
    26fa:	39 f0       	breq	.+14     	; 0x270a <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    2700:	8c 81       	ldd	r24, Y+4	; 0x04
    2702:	9d 81       	ldd	r25, Y+5	; 0x05
    2704:	9b 83       	std	Y+3, r25	; 0x03
    2706:	8a 83       	std	Y+2, r24	; 0x02
    2708:	0d c0       	rjmp	.+26     	; 0x2724 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	88 23       	and	r24, r24
    270e:	51 f4       	brne	.+20     	; 0x2724 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	0f 92       	push	r0
							xPollingConsumerCount++;
    2716:	80 91 a7 01 	lds	r24, 0x01A7
    271a:	8f 5f       	subi	r24, 0xFF	; 255
    271c:	80 93 a7 01 	sts	0x01A7, r24
						portEXIT_CRITICAL();
    2720:	0f 90       	pop	r0
    2722:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2724:	8a 81       	ldd	r24, Y+2	; 0x02
    2726:	9b 81       	ldd	r25, Y+3	; 0x03
    2728:	01 96       	adiw	r24, 0x01	; 1
    272a:	9b 83       	std	Y+3, r25	; 0x03
    272c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    272e:	ee 81       	ldd	r30, Y+6	; 0x06
    2730:	ff 81       	ldd	r31, Y+7	; 0x07
    2732:	80 81       	ld	r24, Z
    2734:	91 81       	ldd	r25, Z+1	; 0x01
    2736:	0e 94 fe 22 	call	0x45fc	; 0x45fc <uxQueueMessagesWaiting>
    273a:	88 23       	and	r24, r24
    273c:	49 f6       	brne	.-110    	; 0x26d0 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    273e:	84 eb       	ldi	r24, 0xB4	; 180
    2740:	90 e0       	ldi	r25, 0x00	; 0
    2742:	0e 94 94 28 	call	0x5128	; 0x5128 <vTaskDelay>
    2746:	f3 cf       	rjmp	.-26     	; 0x272e <vPolledQueueConsumer+0x7e>

00002748 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
    2748:	df 93       	push	r29
    274a:	cf 93       	push	r28
    274c:	0f 92       	push	r0
    274e:	cd b7       	in	r28, 0x3d	; 61
    2750:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2752:	80 91 a7 01 	lds	r24, 0x01A7
    2756:	88 23       	and	r24, r24
    2758:	21 f0       	breq	.+8      	; 0x2762 <xArePollingQueuesStillRunning+0x1a>
    275a:	80 91 a8 01 	lds	r24, 0x01A8
    275e:	88 23       	and	r24, r24
    2760:	11 f4       	brne	.+4      	; 0x2766 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    2762:	19 82       	std	Y+1, r1	; 0x01
    2764:	02 c0       	rjmp	.+4      	; 0x276a <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    276a:	10 92 a7 01 	sts	0x01A7, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    276e:	10 92 a8 01 	sts	0x01A8, r1

	return xReturn;
    2772:	89 81       	ldd	r24, Y+1	; 0x01
}
    2774:	0f 90       	pop	r0
    2776:	cf 91       	pop	r28
    2778:	df 91       	pop	r29
    277a:	08 95       	ret

0000277c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    277c:	df 93       	push	r29
    277e:	cf 93       	push	r28
    2780:	cd b7       	in	r28, 0x3d	; 61
    2782:	de b7       	in	r29, 0x3e	; 62
    2784:	27 97       	sbiw	r28, 0x07	; 7
    2786:	0f b6       	in	r0, 0x3f	; 63
    2788:	f8 94       	cli
    278a:	de bf       	out	0x3e, r29	; 62
    278c:	0f be       	out	0x3f, r0	; 63
    278e:	cd bf       	out	0x3d, r28	; 61
    2790:	9d 83       	std	Y+5, r25	; 0x05
    2792:	8c 83       	std	Y+4, r24	; 0x04
    2794:	6e 83       	std	Y+6, r22	; 0x06
    2796:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2798:	8a e1       	ldi	r24, 0x1A	; 26
    279a:	90 e0       	ldi	r25, 0x00	; 0
    279c:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    27a0:	9a 83       	std	Y+2, r25	; 0x02
    27a2:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    27a4:	89 81       	ldd	r24, Y+1	; 0x01
    27a6:	9a 81       	ldd	r25, Y+2	; 0x02
    27a8:	00 97       	sbiw	r24, 0x00	; 0
    27aa:	09 f4       	brne	.+2      	; 0x27ae <xCoRoutineCreate+0x32>
    27ac:	6f c0       	rjmp	.+222    	; 0x288c <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    27ae:	80 91 ab 01 	lds	r24, 0x01AB
    27b2:	90 91 ac 01 	lds	r25, 0x01AC
    27b6:	00 97       	sbiw	r24, 0x00	; 0
    27b8:	41 f4       	brne	.+16     	; 0x27ca <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    27ba:	89 81       	ldd	r24, Y+1	; 0x01
    27bc:	9a 81       	ldd	r25, Y+2	; 0x02
    27be:	90 93 ac 01 	sts	0x01AC, r25
    27c2:	80 93 ab 01 	sts	0x01AB, r24
			prvInitialiseCoRoutineLists();
    27c6:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    27ca:	8e 81       	ldd	r24, Y+6	; 0x06
    27cc:	82 30       	cpi	r24, 0x02	; 2
    27ce:	10 f0       	brcs	.+4      	; 0x27d4 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    27d4:	e9 81       	ldd	r30, Y+1	; 0x01
    27d6:	fa 81       	ldd	r31, Y+2	; 0x02
    27d8:	11 8e       	std	Z+25, r1	; 0x19
    27da:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    27dc:	e9 81       	ldd	r30, Y+1	; 0x01
    27de:	fa 81       	ldd	r31, Y+2	; 0x02
    27e0:	8e 81       	ldd	r24, Y+6	; 0x06
    27e2:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    27e4:	e9 81       	ldd	r30, Y+1	; 0x01
    27e6:	fa 81       	ldd	r31, Y+2	; 0x02
    27e8:	8f 81       	ldd	r24, Y+7	; 0x07
    27ea:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    27ec:	e9 81       	ldd	r30, Y+1	; 0x01
    27ee:	fa 81       	ldd	r31, Y+2	; 0x02
    27f0:	8c 81       	ldd	r24, Y+4	; 0x04
    27f2:	9d 81       	ldd	r25, Y+5	; 0x05
    27f4:	91 83       	std	Z+1, r25	; 0x01
    27f6:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	9a 81       	ldd	r25, Y+2	; 0x02
    27fc:	02 96       	adiw	r24, 0x02	; 2
    27fe:	0e 94 4e 1b 	call	0x369c	; 0x369c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2802:	89 81       	ldd	r24, Y+1	; 0x01
    2804:	9a 81       	ldd	r25, Y+2	; 0x02
    2806:	0c 96       	adiw	r24, 0x0c	; 12
    2808:	0e 94 4e 1b 	call	0x369c	; 0x369c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    280c:	e9 81       	ldd	r30, Y+1	; 0x01
    280e:	fa 81       	ldd	r31, Y+2	; 0x02
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
    2814:	91 87       	std	Z+9, r25	; 0x09
    2816:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2818:	e9 81       	ldd	r30, Y+1	; 0x01
    281a:	fa 81       	ldd	r31, Y+2	; 0x02
    281c:	89 81       	ldd	r24, Y+1	; 0x01
    281e:	9a 81       	ldd	r25, Y+2	; 0x02
    2820:	93 8b       	std	Z+19, r25	; 0x13
    2822:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2824:	8e 81       	ldd	r24, Y+6	; 0x06
    2826:	28 2f       	mov	r18, r24
    2828:	30 e0       	ldi	r19, 0x00	; 0
    282a:	82 e0       	ldi	r24, 0x02	; 2
    282c:	90 e0       	ldi	r25, 0x00	; 0
    282e:	82 1b       	sub	r24, r18
    2830:	93 0b       	sbc	r25, r19
    2832:	e9 81       	ldd	r30, Y+1	; 0x01
    2834:	fa 81       	ldd	r31, Y+2	; 0x02
    2836:	95 87       	std	Z+13, r25	; 0x0d
    2838:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    283a:	e9 81       	ldd	r30, Y+1	; 0x01
    283c:	fa 81       	ldd	r31, Y+2	; 0x02
    283e:	96 89       	ldd	r25, Z+22	; 0x16
    2840:	80 91 ad 01 	lds	r24, 0x01AD
    2844:	89 17       	cp	r24, r25
    2846:	28 f4       	brcc	.+10     	; 0x2852 <xCoRoutineCreate+0xd6>
    2848:	e9 81       	ldd	r30, Y+1	; 0x01
    284a:	fa 81       	ldd	r31, Y+2	; 0x02
    284c:	86 89       	ldd	r24, Z+22	; 0x16
    284e:	80 93 ad 01 	sts	0x01AD, r24
    2852:	e9 81       	ldd	r30, Y+1	; 0x01
    2854:	fa 81       	ldd	r31, Y+2	; 0x02
    2856:	86 89       	ldd	r24, Z+22	; 0x16
    2858:	28 2f       	mov	r18, r24
    285a:	30 e0       	ldi	r19, 0x00	; 0
    285c:	c9 01       	movw	r24, r18
    285e:	88 0f       	add	r24, r24
    2860:	99 1f       	adc	r25, r25
    2862:	88 0f       	add	r24, r24
    2864:	99 1f       	adc	r25, r25
    2866:	88 0f       	add	r24, r24
    2868:	99 1f       	adc	r25, r25
    286a:	82 0f       	add	r24, r18
    286c:	93 1f       	adc	r25, r19
    286e:	ac 01       	movw	r20, r24
    2870:	4c 54       	subi	r20, 0x4C	; 76
    2872:	5e 4f       	sbci	r21, 0xFE	; 254
    2874:	89 81       	ldd	r24, Y+1	; 0x01
    2876:	9a 81       	ldd	r25, Y+2	; 0x02
    2878:	9c 01       	movw	r18, r24
    287a:	2e 5f       	subi	r18, 0xFE	; 254
    287c:	3f 4f       	sbci	r19, 0xFF	; 255
    287e:	ca 01       	movw	r24, r20
    2880:	b9 01       	movw	r22, r18
    2882:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

		xReturn = pdPASS;
    2886:	81 e0       	ldi	r24, 0x01	; 1
    2888:	8b 83       	std	Y+3, r24	; 0x03
    288a:	02 c0       	rjmp	.+4      	; 0x2890 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    288c:	8f ef       	ldi	r24, 0xFF	; 255
    288e:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
    2890:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2892:	27 96       	adiw	r28, 0x07	; 7
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	de bf       	out	0x3e, r29	; 62
    289a:	0f be       	out	0x3f, r0	; 63
    289c:	cd bf       	out	0x3d, r28	; 61
    289e:	cf 91       	pop	r28
    28a0:	df 91       	pop	r29
    28a2:	08 95       	ret

000028a4 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    28a4:	df 93       	push	r29
    28a6:	cf 93       	push	r28
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <vCoRoutineAddToDelayedList+0x6>
    28aa:	00 d0       	rcall	.+0      	; 0x28ac <vCoRoutineAddToDelayedList+0x8>
    28ac:	00 d0       	rcall	.+0      	; 0x28ae <vCoRoutineAddToDelayedList+0xa>
    28ae:	cd b7       	in	r28, 0x3d	; 61
    28b0:	de b7       	in	r29, 0x3e	; 62
    28b2:	9c 83       	std	Y+4, r25	; 0x04
    28b4:	8b 83       	std	Y+3, r24	; 0x03
    28b6:	7e 83       	std	Y+6, r23	; 0x06
    28b8:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    28ba:	20 91 ae 01 	lds	r18, 0x01AE
    28be:	30 91 af 01 	lds	r19, 0x01AF
    28c2:	8b 81       	ldd	r24, Y+3	; 0x03
    28c4:	9c 81       	ldd	r25, Y+4	; 0x04
    28c6:	82 0f       	add	r24, r18
    28c8:	93 1f       	adc	r25, r19
    28ca:	9a 83       	std	Y+2, r25	; 0x02
    28cc:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28ce:	80 91 ab 01 	lds	r24, 0x01AB
    28d2:	90 91 ac 01 	lds	r25, 0x01AC
    28d6:	02 96       	adiw	r24, 0x02	; 2
    28d8:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    28dc:	e0 91 ab 01 	lds	r30, 0x01AB
    28e0:	f0 91 ac 01 	lds	r31, 0x01AC
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	9a 81       	ldd	r25, Y+2	; 0x02
    28e8:	93 83       	std	Z+3, r25	; 0x03
    28ea:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    28ec:	20 91 ae 01 	lds	r18, 0x01AE
    28f0:	30 91 af 01 	lds	r19, 0x01AF
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	9a 81       	ldd	r25, Y+2	; 0x02
    28f8:	82 17       	cp	r24, r18
    28fa:	93 07       	cpc	r25, r19
    28fc:	70 f4       	brcc	.+28     	; 0x291a <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28fe:	80 91 da 01 	lds	r24, 0x01DA
    2902:	90 91 db 01 	lds	r25, 0x01DB
    2906:	20 91 ab 01 	lds	r18, 0x01AB
    290a:	30 91 ac 01 	lds	r19, 0x01AC
    290e:	2e 5f       	subi	r18, 0xFE	; 254
    2910:	3f 4f       	sbci	r19, 0xFF	; 255
    2912:	b9 01       	movw	r22, r18
    2914:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>
    2918:	0d c0       	rjmp	.+26     	; 0x2934 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    291a:	80 91 d8 01 	lds	r24, 0x01D8
    291e:	90 91 d9 01 	lds	r25, 0x01D9
    2922:	20 91 ab 01 	lds	r18, 0x01AB
    2926:	30 91 ac 01 	lds	r19, 0x01AC
    292a:	2e 5f       	subi	r18, 0xFE	; 254
    292c:	3f 4f       	sbci	r19, 0xFF	; 255
    292e:	b9 01       	movw	r22, r18
    2930:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>
	}

	if( pxEventList )
    2934:	8d 81       	ldd	r24, Y+5	; 0x05
    2936:	9e 81       	ldd	r25, Y+6	; 0x06
    2938:	00 97       	sbiw	r24, 0x00	; 0
    293a:	61 f0       	breq	.+24     	; 0x2954 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    293c:	80 91 ab 01 	lds	r24, 0x01AB
    2940:	90 91 ac 01 	lds	r25, 0x01AC
    2944:	9c 01       	movw	r18, r24
    2946:	24 5f       	subi	r18, 0xF4	; 244
    2948:	3f 4f       	sbci	r19, 0xFF	; 255
    294a:	8d 81       	ldd	r24, Y+5	; 0x05
    294c:	9e 81       	ldd	r25, Y+6	; 0x06
    294e:	b9 01       	movw	r22, r18
    2950:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>
	}
}
    2954:	26 96       	adiw	r28, 0x06	; 6
    2956:	0f b6       	in	r0, 0x3f	; 63
    2958:	f8 94       	cli
    295a:	de bf       	out	0x3e, r29	; 62
    295c:	0f be       	out	0x3f, r0	; 63
    295e:	cd bf       	out	0x3d, r28	; 61
    2960:	cf 91       	pop	r28
    2962:	df 91       	pop	r29
    2964:	08 95       	ret

00002966 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2966:	df 93       	push	r29
    2968:	cf 93       	push	r28
    296a:	00 d0       	rcall	.+0      	; 0x296c <prvCheckPendingReadyList+0x6>
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
    2970:	3a c0       	rjmp	.+116    	; 0x29e6 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2972:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2974:	e0 91 e1 01 	lds	r30, 0x01E1
    2978:	f0 91 e2 01 	lds	r31, 0x01E2
    297c:	86 81       	ldd	r24, Z+6	; 0x06
    297e:	97 81       	ldd	r25, Z+7	; 0x07
    2980:	9a 83       	std	Y+2, r25	; 0x02
    2982:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2984:	89 81       	ldd	r24, Y+1	; 0x01
    2986:	9a 81       	ldd	r25, Y+2	; 0x02
    2988:	0c 96       	adiw	r24, 0x0c	; 12
    298a:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    298e:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2990:	89 81       	ldd	r24, Y+1	; 0x01
    2992:	9a 81       	ldd	r25, Y+2	; 0x02
    2994:	02 96       	adiw	r24, 0x02	; 2
    2996:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    299a:	e9 81       	ldd	r30, Y+1	; 0x01
    299c:	fa 81       	ldd	r31, Y+2	; 0x02
    299e:	96 89       	ldd	r25, Z+22	; 0x16
    29a0:	80 91 ad 01 	lds	r24, 0x01AD
    29a4:	89 17       	cp	r24, r25
    29a6:	28 f4       	brcc	.+10     	; 0x29b2 <prvCheckPendingReadyList+0x4c>
    29a8:	e9 81       	ldd	r30, Y+1	; 0x01
    29aa:	fa 81       	ldd	r31, Y+2	; 0x02
    29ac:	86 89       	ldd	r24, Z+22	; 0x16
    29ae:	80 93 ad 01 	sts	0x01AD, r24
    29b2:	e9 81       	ldd	r30, Y+1	; 0x01
    29b4:	fa 81       	ldd	r31, Y+2	; 0x02
    29b6:	86 89       	ldd	r24, Z+22	; 0x16
    29b8:	28 2f       	mov	r18, r24
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	c9 01       	movw	r24, r18
    29be:	88 0f       	add	r24, r24
    29c0:	99 1f       	adc	r25, r25
    29c2:	88 0f       	add	r24, r24
    29c4:	99 1f       	adc	r25, r25
    29c6:	88 0f       	add	r24, r24
    29c8:	99 1f       	adc	r25, r25
    29ca:	82 0f       	add	r24, r18
    29cc:	93 1f       	adc	r25, r19
    29ce:	ac 01       	movw	r20, r24
    29d0:	4c 54       	subi	r20, 0x4C	; 76
    29d2:	5e 4f       	sbci	r21, 0xFE	; 254
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	9c 01       	movw	r18, r24
    29da:	2e 5f       	subi	r18, 0xFE	; 254
    29dc:	3f 4f       	sbci	r19, 0xFF	; 255
    29de:	ca 01       	movw	r24, r20
    29e0:	b9 01       	movw	r22, r18
    29e2:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29e6:	80 91 dc 01 	lds	r24, 0x01DC
    29ea:	88 23       	and	r24, r24
    29ec:	09 f0       	breq	.+2      	; 0x29f0 <prvCheckPendingReadyList+0x8a>
    29ee:	c1 cf       	rjmp	.-126    	; 0x2972 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
    29f4:	cf 91       	pop	r28
    29f6:	df 91       	pop	r29
    29f8:	08 95       	ret

000029fa <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    29fa:	df 93       	push	r29
    29fc:	cf 93       	push	r28
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <prvCheckDelayedList+0x6>
    2a00:	00 d0       	rcall	.+0      	; 0x2a02 <prvCheckDelayedList+0x8>
    2a02:	cd b7       	in	r28, 0x3d	; 61
    2a04:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2a06:	0e 94 04 2c 	call	0x5808	; 0x5808 <xTaskGetTickCount>
    2a0a:	20 91 b0 01 	lds	r18, 0x01B0
    2a0e:	30 91 b1 01 	lds	r19, 0x01B1
    2a12:	82 1b       	sub	r24, r18
    2a14:	93 0b       	sbc	r25, r19
    2a16:	90 93 b3 01 	sts	0x01B3, r25
    2a1a:	80 93 b2 01 	sts	0x01B2, r24
    2a1e:	85 c0       	rjmp	.+266    	; 0x2b2a <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2a20:	80 91 ae 01 	lds	r24, 0x01AE
    2a24:	90 91 af 01 	lds	r25, 0x01AF
    2a28:	01 96       	adiw	r24, 0x01	; 1
    2a2a:	90 93 af 01 	sts	0x01AF, r25
    2a2e:	80 93 ae 01 	sts	0x01AE, r24
		xPassedTicks--;
    2a32:	80 91 b2 01 	lds	r24, 0x01B2
    2a36:	90 91 b3 01 	lds	r25, 0x01B3
    2a3a:	01 97       	sbiw	r24, 0x01	; 1
    2a3c:	90 93 b3 01 	sts	0x01B3, r25
    2a40:	80 93 b2 01 	sts	0x01B2, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a44:	80 91 ae 01 	lds	r24, 0x01AE
    2a48:	90 91 af 01 	lds	r25, 0x01AF
    2a4c:	00 97       	sbiw	r24, 0x00	; 0
    2a4e:	09 f0       	breq	.+2      	; 0x2a52 <prvCheckDelayedList+0x58>
    2a50:	64 c0       	rjmp	.+200    	; 0x2b1a <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a52:	80 91 d8 01 	lds	r24, 0x01D8
    2a56:	90 91 d9 01 	lds	r25, 0x01D9
    2a5a:	9a 83       	std	Y+2, r25	; 0x02
    2a5c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a5e:	80 91 da 01 	lds	r24, 0x01DA
    2a62:	90 91 db 01 	lds	r25, 0x01DB
    2a66:	90 93 d9 01 	sts	0x01D9, r25
    2a6a:	80 93 d8 01 	sts	0x01D8, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a6e:	89 81       	ldd	r24, Y+1	; 0x01
    2a70:	9a 81       	ldd	r25, Y+2	; 0x02
    2a72:	90 93 db 01 	sts	0x01DB, r25
    2a76:	80 93 da 01 	sts	0x01DA, r24
    2a7a:	4f c0       	rjmp	.+158    	; 0x2b1a <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a7c:	e0 91 d8 01 	lds	r30, 0x01D8
    2a80:	f0 91 d9 01 	lds	r31, 0x01D9
    2a84:	05 80       	ldd	r0, Z+5	; 0x05
    2a86:	f6 81       	ldd	r31, Z+6	; 0x06
    2a88:	e0 2d       	mov	r30, r0
    2a8a:	86 81       	ldd	r24, Z+6	; 0x06
    2a8c:	97 81       	ldd	r25, Z+7	; 0x07
    2a8e:	9c 83       	std	Y+4, r25	; 0x04
    2a90:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2a92:	eb 81       	ldd	r30, Y+3	; 0x03
    2a94:	fc 81       	ldd	r31, Y+4	; 0x04
    2a96:	22 81       	ldd	r18, Z+2	; 0x02
    2a98:	33 81       	ldd	r19, Z+3	; 0x03
    2a9a:	80 91 ae 01 	lds	r24, 0x01AE
    2a9e:	90 91 af 01 	lds	r25, 0x01AF
    2aa2:	82 17       	cp	r24, r18
    2aa4:	93 07       	cpc	r25, r19
    2aa6:	08 f4       	brcc	.+2      	; 0x2aaa <prvCheckDelayedList+0xb0>
    2aa8:	40 c0       	rjmp	.+128    	; 0x2b2a <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2aaa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2aac:	8b 81       	ldd	r24, Y+3	; 0x03
    2aae:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab0:	02 96       	adiw	r24, 0x02	; 2
    2ab2:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	84 89       	ldd	r24, Z+20	; 0x14
    2abc:	95 89       	ldd	r25, Z+21	; 0x15
    2abe:	00 97       	sbiw	r24, 0x00	; 0
    2ac0:	29 f0       	breq	.+10     	; 0x2acc <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac6:	0c 96       	adiw	r24, 0x0c	; 12
    2ac8:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2acc:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	96 89       	ldd	r25, Z+22	; 0x16
    2ad4:	80 91 ad 01 	lds	r24, 0x01AD
    2ad8:	89 17       	cp	r24, r25
    2ada:	28 f4       	brcc	.+10     	; 0x2ae6 <prvCheckDelayedList+0xec>
    2adc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ade:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae0:	86 89       	ldd	r24, Z+22	; 0x16
    2ae2:	80 93 ad 01 	sts	0x01AD, r24
    2ae6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aea:	86 89       	ldd	r24, Z+22	; 0x16
    2aec:	28 2f       	mov	r18, r24
    2aee:	30 e0       	ldi	r19, 0x00	; 0
    2af0:	c9 01       	movw	r24, r18
    2af2:	88 0f       	add	r24, r24
    2af4:	99 1f       	adc	r25, r25
    2af6:	88 0f       	add	r24, r24
    2af8:	99 1f       	adc	r25, r25
    2afa:	88 0f       	add	r24, r24
    2afc:	99 1f       	adc	r25, r25
    2afe:	82 0f       	add	r24, r18
    2b00:	93 1f       	adc	r25, r19
    2b02:	ac 01       	movw	r20, r24
    2b04:	4c 54       	subi	r20, 0x4C	; 76
    2b06:	5e 4f       	sbci	r21, 0xFE	; 254
    2b08:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0c:	9c 01       	movw	r18, r24
    2b0e:	2e 5f       	subi	r18, 0xFE	; 254
    2b10:	3f 4f       	sbci	r19, 0xFF	; 255
    2b12:	ca 01       	movw	r24, r20
    2b14:	b9 01       	movw	r22, r18
    2b16:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b1a:	e0 91 d8 01 	lds	r30, 0x01D8
    2b1e:	f0 91 d9 01 	lds	r31, 0x01D9
    2b22:	80 81       	ld	r24, Z
    2b24:	88 23       	and	r24, r24
    2b26:	09 f0       	breq	.+2      	; 0x2b2a <prvCheckDelayedList+0x130>
    2b28:	a9 cf       	rjmp	.-174    	; 0x2a7c <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2b2a:	80 91 b2 01 	lds	r24, 0x01B2
    2b2e:	90 91 b3 01 	lds	r25, 0x01B3
    2b32:	00 97       	sbiw	r24, 0x00	; 0
    2b34:	09 f0       	breq	.+2      	; 0x2b38 <prvCheckDelayedList+0x13e>
    2b36:	74 cf       	rjmp	.-280    	; 0x2a20 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2b38:	80 91 ae 01 	lds	r24, 0x01AE
    2b3c:	90 91 af 01 	lds	r25, 0x01AF
    2b40:	90 93 b1 01 	sts	0x01B1, r25
    2b44:	80 93 b0 01 	sts	0x01B0, r24
}
    2b48:	0f 90       	pop	r0
    2b4a:	0f 90       	pop	r0
    2b4c:	0f 90       	pop	r0
    2b4e:	0f 90       	pop	r0
    2b50:	cf 91       	pop	r28
    2b52:	df 91       	pop	r29
    2b54:	08 95       	ret

00002b56 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2b56:	df 93       	push	r29
    2b58:	cf 93       	push	r28
    2b5a:	00 d0       	rcall	.+0      	; 0x2b5c <vCoRoutineSchedule+0x6>
    2b5c:	cd b7       	in	r28, 0x3d	; 61
    2b5e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b60:	0e 94 b3 14 	call	0x2966	; 0x2966 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b64:	0e 94 fd 14 	call	0x29fa	; 0x29fa <prvCheckDelayedList>
    2b68:	0a c0       	rjmp	.+20     	; 0x2b7e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b6a:	80 91 ad 01 	lds	r24, 0x01AD
    2b6e:	88 23       	and	r24, r24
    2b70:	09 f4       	brne	.+2      	; 0x2b74 <vCoRoutineSchedule+0x1e>
    2b72:	66 c0       	rjmp	.+204    	; 0x2c40 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2b74:	80 91 ad 01 	lds	r24, 0x01AD
    2b78:	81 50       	subi	r24, 0x01	; 1
    2b7a:	80 93 ad 01 	sts	0x01AD, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b7e:	80 91 ad 01 	lds	r24, 0x01AD
    2b82:	28 2f       	mov	r18, r24
    2b84:	30 e0       	ldi	r19, 0x00	; 0
    2b86:	c9 01       	movw	r24, r18
    2b88:	88 0f       	add	r24, r24
    2b8a:	99 1f       	adc	r25, r25
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	88 0f       	add	r24, r24
    2b92:	99 1f       	adc	r25, r25
    2b94:	82 0f       	add	r24, r18
    2b96:	93 1f       	adc	r25, r19
    2b98:	fc 01       	movw	r30, r24
    2b9a:	ec 54       	subi	r30, 0x4C	; 76
    2b9c:	fe 4f       	sbci	r31, 0xFE	; 254
    2b9e:	80 81       	ld	r24, Z
    2ba0:	88 23       	and	r24, r24
    2ba2:	19 f3       	breq	.-58     	; 0x2b6a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2ba4:	80 91 ad 01 	lds	r24, 0x01AD
    2ba8:	28 2f       	mov	r18, r24
    2baa:	30 e0       	ldi	r19, 0x00	; 0
    2bac:	c9 01       	movw	r24, r18
    2bae:	88 0f       	add	r24, r24
    2bb0:	99 1f       	adc	r25, r25
    2bb2:	88 0f       	add	r24, r24
    2bb4:	99 1f       	adc	r25, r25
    2bb6:	88 0f       	add	r24, r24
    2bb8:	99 1f       	adc	r25, r25
    2bba:	82 0f       	add	r24, r18
    2bbc:	93 1f       	adc	r25, r19
    2bbe:	8c 54       	subi	r24, 0x4C	; 76
    2bc0:	9e 4f       	sbci	r25, 0xFE	; 254
    2bc2:	9a 83       	std	Y+2, r25	; 0x02
    2bc4:	89 83       	std	Y+1, r24	; 0x01
    2bc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2bca:	01 80       	ldd	r0, Z+1	; 0x01
    2bcc:	f2 81       	ldd	r31, Z+2	; 0x02
    2bce:	e0 2d       	mov	r30, r0
    2bd0:	82 81       	ldd	r24, Z+2	; 0x02
    2bd2:	93 81       	ldd	r25, Z+3	; 0x03
    2bd4:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd6:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd8:	92 83       	std	Z+2, r25	; 0x02
    2bda:	81 83       	std	Z+1, r24	; 0x01
    2bdc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bde:	fa 81       	ldd	r31, Y+2	; 0x02
    2be0:	21 81       	ldd	r18, Z+1	; 0x01
    2be2:	32 81       	ldd	r19, Z+2	; 0x02
    2be4:	89 81       	ldd	r24, Y+1	; 0x01
    2be6:	9a 81       	ldd	r25, Y+2	; 0x02
    2be8:	03 96       	adiw	r24, 0x03	; 3
    2bea:	28 17       	cp	r18, r24
    2bec:	39 07       	cpc	r19, r25
    2bee:	59 f4       	brne	.+22     	; 0x2c06 <vCoRoutineSchedule+0xb0>
    2bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    2bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf4:	01 80       	ldd	r0, Z+1	; 0x01
    2bf6:	f2 81       	ldd	r31, Z+2	; 0x02
    2bf8:	e0 2d       	mov	r30, r0
    2bfa:	82 81       	ldd	r24, Z+2	; 0x02
    2bfc:	93 81       	ldd	r25, Z+3	; 0x03
    2bfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2c00:	fa 81       	ldd	r31, Y+2	; 0x02
    2c02:	92 83       	std	Z+2, r25	; 0x02
    2c04:	81 83       	std	Z+1, r24	; 0x01
    2c06:	e9 81       	ldd	r30, Y+1	; 0x01
    2c08:	fa 81       	ldd	r31, Y+2	; 0x02
    2c0a:	01 80       	ldd	r0, Z+1	; 0x01
    2c0c:	f2 81       	ldd	r31, Z+2	; 0x02
    2c0e:	e0 2d       	mov	r30, r0
    2c10:	86 81       	ldd	r24, Z+6	; 0x06
    2c12:	97 81       	ldd	r25, Z+7	; 0x07
    2c14:	90 93 ac 01 	sts	0x01AC, r25
    2c18:	80 93 ab 01 	sts	0x01AB, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2c1c:	e0 91 ab 01 	lds	r30, 0x01AB
    2c20:	f0 91 ac 01 	lds	r31, 0x01AC
    2c24:	40 81       	ld	r20, Z
    2c26:	51 81       	ldd	r21, Z+1	; 0x01
    2c28:	80 91 ab 01 	lds	r24, 0x01AB
    2c2c:	90 91 ac 01 	lds	r25, 0x01AC
    2c30:	e0 91 ab 01 	lds	r30, 0x01AB
    2c34:	f0 91 ac 01 	lds	r31, 0x01AC
    2c38:	27 89       	ldd	r18, Z+23	; 0x17
    2c3a:	62 2f       	mov	r22, r18
    2c3c:	fa 01       	movw	r30, r20
    2c3e:	09 95       	icall

	return;
}
    2c40:	0f 90       	pop	r0
    2c42:	0f 90       	pop	r0
    2c44:	cf 91       	pop	r28
    2c46:	df 91       	pop	r29
    2c48:	08 95       	ret

00002c4a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2c4a:	df 93       	push	r29
    2c4c:	cf 93       	push	r28
    2c4e:	0f 92       	push	r0
    2c50:	cd b7       	in	r28, 0x3d	; 61
    2c52:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c54:	19 82       	std	Y+1, r1	; 0x01
    2c56:	13 c0       	rjmp	.+38     	; 0x2c7e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	28 2f       	mov	r18, r24
    2c5c:	30 e0       	ldi	r19, 0x00	; 0
    2c5e:	c9 01       	movw	r24, r18
    2c60:	88 0f       	add	r24, r24
    2c62:	99 1f       	adc	r25, r25
    2c64:	88 0f       	add	r24, r24
    2c66:	99 1f       	adc	r25, r25
    2c68:	88 0f       	add	r24, r24
    2c6a:	99 1f       	adc	r25, r25
    2c6c:	82 0f       	add	r24, r18
    2c6e:	93 1f       	adc	r25, r19
    2c70:	8c 54       	subi	r24, 0x4C	; 76
    2c72:	9e 4f       	sbci	r25, 0xFE	; 254
    2c74:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c78:	89 81       	ldd	r24, Y+1	; 0x01
    2c7a:	8f 5f       	subi	r24, 0xFF	; 255
    2c7c:	89 83       	std	Y+1, r24	; 0x01
    2c7e:	89 81       	ldd	r24, Y+1	; 0x01
    2c80:	82 30       	cpi	r24, 0x02	; 2
    2c82:	50 f3       	brcs	.-44     	; 0x2c58 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2c84:	86 ec       	ldi	r24, 0xC6	; 198
    2c86:	91 e0       	ldi	r25, 0x01	; 1
    2c88:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2c8c:	8f ec       	ldi	r24, 0xCF	; 207
    2c8e:	91 e0       	ldi	r25, 0x01	; 1
    2c90:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    2c94:	8c ed       	ldi	r24, 0xDC	; 220
    2c96:	91 e0       	ldi	r25, 0x01	; 1
    2c98:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c9c:	86 ec       	ldi	r24, 0xC6	; 198
    2c9e:	91 e0       	ldi	r25, 0x01	; 1
    2ca0:	90 93 d9 01 	sts	0x01D9, r25
    2ca4:	80 93 d8 01 	sts	0x01D8, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2ca8:	8f ec       	ldi	r24, 0xCF	; 207
    2caa:	91 e0       	ldi	r25, 0x01	; 1
    2cac:	90 93 db 01 	sts	0x01DB, r25
    2cb0:	80 93 da 01 	sts	0x01DA, r24
}
    2cb4:	0f 90       	pop	r0
    2cb6:	cf 91       	pop	r28
    2cb8:	df 91       	pop	r29
    2cba:	08 95       	ret

00002cbc <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2cbc:	df 93       	push	r29
    2cbe:	cf 93       	push	r28
    2cc0:	00 d0       	rcall	.+0      	; 0x2cc2 <xCoRoutineRemoveFromEventList+0x6>
    2cc2:	00 d0       	rcall	.+0      	; 0x2cc4 <xCoRoutineRemoveFromEventList+0x8>
    2cc4:	0f 92       	push	r0
    2cc6:	cd b7       	in	r28, 0x3d	; 61
    2cc8:	de b7       	in	r29, 0x3e	; 62
    2cca:	9d 83       	std	Y+5, r25	; 0x05
    2ccc:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cce:	ec 81       	ldd	r30, Y+4	; 0x04
    2cd0:	fd 81       	ldd	r31, Y+5	; 0x05
    2cd2:	05 80       	ldd	r0, Z+5	; 0x05
    2cd4:	f6 81       	ldd	r31, Z+6	; 0x06
    2cd6:	e0 2d       	mov	r30, r0
    2cd8:	86 81       	ldd	r24, Z+6	; 0x06
    2cda:	97 81       	ldd	r25, Z+7	; 0x07
    2cdc:	9b 83       	std	Y+3, r25	; 0x03
    2cde:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ce4:	0c 96       	adiw	r24, 0x0c	; 12
    2ce6:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2cea:	8a 81       	ldd	r24, Y+2	; 0x02
    2cec:	9b 81       	ldd	r25, Y+3	; 0x03
    2cee:	9c 01       	movw	r18, r24
    2cf0:	24 5f       	subi	r18, 0xF4	; 244
    2cf2:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf4:	8c ed       	ldi	r24, 0xDC	; 220
    2cf6:	91 e0       	ldi	r25, 0x01	; 1
    2cf8:	b9 01       	movw	r22, r18
    2cfa:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2cfe:	ea 81       	ldd	r30, Y+2	; 0x02
    2d00:	fb 81       	ldd	r31, Y+3	; 0x03
    2d02:	96 89       	ldd	r25, Z+22	; 0x16
    2d04:	e0 91 ab 01 	lds	r30, 0x01AB
    2d08:	f0 91 ac 01 	lds	r31, 0x01AC
    2d0c:	86 89       	ldd	r24, Z+22	; 0x16
    2d0e:	98 17       	cp	r25, r24
    2d10:	18 f0       	brcs	.+6      	; 0x2d18 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2d12:	81 e0       	ldi	r24, 0x01	; 1
    2d14:	89 83       	std	Y+1, r24	; 0x01
    2d16:	01 c0       	rjmp	.+2      	; 0x2d1a <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2d18:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d1c:	0f 90       	pop	r0
    2d1e:	0f 90       	pop	r0
    2d20:	0f 90       	pop	r0
    2d22:	0f 90       	pop	r0
    2d24:	0f 90       	pop	r0
    2d26:	cf 91       	pop	r28
    2d28:	df 91       	pop	r29
    2d2a:	08 95       	ret

00002d2c <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    2d2c:	df 93       	push	r29
    2d2e:	cf 93       	push	r28
    2d30:	00 d0       	rcall	.+0      	; 0x2d32 <xEventGroupCreate+0x6>
    2d32:	cd b7       	in	r28, 0x3d	; 61
    2d34:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    2d36:	8b e0       	ldi	r24, 0x0B	; 11
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    2d3e:	9a 83       	std	Y+2, r25	; 0x02
    2d40:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	9a 81       	ldd	r25, Y+2	; 0x02
    2d46:	00 97       	sbiw	r24, 0x00	; 0
    2d48:	49 f0       	breq	.+18     	; 0x2d5c <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    2d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4e:	11 82       	std	Z+1, r1	; 0x01
    2d50:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2d52:	89 81       	ldd	r24, Y+1	; 0x01
    2d54:	9a 81       	ldd	r25, Y+2	; 0x02
    2d56:	02 96       	adiw	r24, 0x02	; 2
    2d58:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    2d5c:	89 81       	ldd	r24, Y+1	; 0x01
    2d5e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d60:	0f 90       	pop	r0
    2d62:	0f 90       	pop	r0
    2d64:	cf 91       	pop	r28
    2d66:	df 91       	pop	r29
    2d68:	08 95       	ret

00002d6a <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2d6a:	df 93       	push	r29
    2d6c:	cf 93       	push	r28
    2d6e:	cd b7       	in	r28, 0x3d	; 61
    2d70:	de b7       	in	r29, 0x3e	; 62
    2d72:	60 97       	sbiw	r28, 0x10	; 16
    2d74:	0f b6       	in	r0, 0x3f	; 63
    2d76:	f8 94       	cli
    2d78:	de bf       	out	0x3e, r29	; 62
    2d7a:	0f be       	out	0x3f, r0	; 63
    2d7c:	cd bf       	out	0x3d, r28	; 61
    2d7e:	9a 87       	std	Y+10, r25	; 0x0a
    2d80:	89 87       	std	Y+9, r24	; 0x09
    2d82:	7c 87       	std	Y+12, r23	; 0x0c
    2d84:	6b 87       	std	Y+11, r22	; 0x0b
    2d86:	5e 87       	std	Y+14, r21	; 0x0e
    2d88:	4d 87       	std	Y+13, r20	; 0x0d
    2d8a:	38 8b       	std	Y+16, r19	; 0x10
    2d8c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2d8e:	89 85       	ldd	r24, Y+9	; 0x09
    2d90:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d92:	9c 83       	std	Y+4, r25	; 0x04
    2d94:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2d96:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2d98:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2d9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2da0:	80 81       	ld	r24, Z
    2da2:	91 81       	ldd	r25, Z+1	; 0x01
    2da4:	98 87       	std	Y+8, r25	; 0x08
    2da6:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2da8:	89 85       	ldd	r24, Y+9	; 0x09
    2daa:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dac:	2b 85       	ldd	r18, Y+11	; 0x0b
    2dae:	3c 85       	ldd	r19, Y+12	; 0x0c
    2db0:	b9 01       	movw	r22, r18
    2db2:	0e 94 87 18 	call	0x310e	; 0x310e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2db6:	2f 81       	ldd	r18, Y+7	; 0x07
    2db8:	38 85       	ldd	r19, Y+8	; 0x08
    2dba:	8b 85       	ldd	r24, Y+11	; 0x0b
    2dbc:	9c 85       	ldd	r25, Y+12	; 0x0c
    2dbe:	28 2b       	or	r18, r24
    2dc0:	39 2b       	or	r19, r25
    2dc2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dc4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2dc6:	28 23       	and	r18, r24
    2dc8:	39 23       	and	r19, r25
    2dca:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    2dce:	28 17       	cp	r18, r24
    2dd0:	39 07       	cpc	r19, r25
    2dd2:	c9 f4       	brne	.+50     	; 0x2e06 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2dd4:	2f 81       	ldd	r18, Y+7	; 0x07
    2dd6:	38 85       	ldd	r19, Y+8	; 0x08
    2dd8:	8b 85       	ldd	r24, Y+11	; 0x0b
    2dda:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ddc:	82 2b       	or	r24, r18
    2dde:	93 2b       	or	r25, r19
    2de0:	9e 83       	std	Y+6, r25	; 0x06
    2de2:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2de4:	eb 81       	ldd	r30, Y+3	; 0x03
    2de6:	fc 81       	ldd	r31, Y+4	; 0x04
    2de8:	20 81       	ld	r18, Z
    2dea:	31 81       	ldd	r19, Z+1	; 0x01
    2dec:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dee:	9e 85       	ldd	r25, Y+14	; 0x0e
    2df0:	80 95       	com	r24
    2df2:	90 95       	com	r25
    2df4:	82 23       	and	r24, r18
    2df6:	93 23       	and	r25, r19
    2df8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    2dfc:	91 83       	std	Z+1, r25	; 0x01
    2dfe:	80 83       	st	Z, r24

			xTicksToWait = 0;
    2e00:	18 8a       	std	Y+16, r1	; 0x10
    2e02:	1f 86       	std	Y+15, r1	; 0x0f
    2e04:	1c c0       	rjmp	.+56     	; 0x2e3e <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2e06:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e08:	98 89       	ldd	r25, Y+16	; 0x10
    2e0a:	00 97       	sbiw	r24, 0x00	; 0
    2e0c:	91 f0       	breq	.+36     	; 0x2e32 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e10:	9c 81       	ldd	r25, Y+4	; 0x04
    2e12:	bc 01       	movw	r22, r24
    2e14:	6e 5f       	subi	r22, 0xFE	; 254
    2e16:	7f 4f       	sbci	r23, 0xFF	; 255
    2e18:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e1c:	9c 01       	movw	r18, r24
    2e1e:	35 60       	ori	r19, 0x05	; 5
    2e20:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e22:	58 89       	ldd	r21, Y+16	; 0x10
    2e24:	cb 01       	movw	r24, r22
    2e26:	b9 01       	movw	r22, r18
    2e28:	0e 94 d1 2d 	call	0x5ba2	; 0x5ba2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    2e2c:	1e 82       	std	Y+6, r1	; 0x06
    2e2e:	1d 82       	std	Y+5, r1	; 0x05
    2e30:	06 c0       	rjmp	.+12     	; 0x2e3e <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2e32:	eb 81       	ldd	r30, Y+3	; 0x03
    2e34:	fc 81       	ldd	r31, Y+4	; 0x04
    2e36:	80 81       	ld	r24, Z
    2e38:	91 81       	ldd	r25, Z+1	; 0x01
    2e3a:	9e 83       	std	Y+6, r25	; 0x06
    2e3c:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2e3e:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    2e42:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2e44:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e46:	98 89       	ldd	r25, Y+16	; 0x10
    2e48:	00 97       	sbiw	r24, 0x00	; 0
    2e4a:	09 f4       	brne	.+2      	; 0x2e4e <xEventGroupSync+0xe4>
    2e4c:	3a c0       	rjmp	.+116    	; 0x2ec2 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    2e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e50:	88 23       	and	r24, r24
    2e52:	11 f4       	brne	.+4      	; 0x2e58 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    2e54:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2e58:	0e 94 6e 32 	call	0x64dc	; 0x64dc <uxTaskResetEventItemValue>
    2e5c:	9e 83       	std	Y+6, r25	; 0x06
    2e5e:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2e60:	8d 81       	ldd	r24, Y+5	; 0x05
    2e62:	9e 81       	ldd	r25, Y+6	; 0x06
    2e64:	80 70       	andi	r24, 0x00	; 0
    2e66:	92 70       	andi	r25, 0x02	; 2
    2e68:	00 97       	sbiw	r24, 0x00	; 0
    2e6a:	31 f5       	brne	.+76     	; 0x2eb8 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2e6c:	0f b6       	in	r0, 0x3f	; 63
    2e6e:	f8 94       	cli
    2e70:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2e72:	eb 81       	ldd	r30, Y+3	; 0x03
    2e74:	fc 81       	ldd	r31, Y+4	; 0x04
    2e76:	80 81       	ld	r24, Z
    2e78:	91 81       	ldd	r25, Z+1	; 0x01
    2e7a:	9e 83       	std	Y+6, r25	; 0x06
    2e7c:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2e7e:	2d 81       	ldd	r18, Y+5	; 0x05
    2e80:	3e 81       	ldd	r19, Y+6	; 0x06
    2e82:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e84:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e86:	28 23       	and	r18, r24
    2e88:	39 23       	and	r19, r25
    2e8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e8e:	28 17       	cp	r18, r24
    2e90:	39 07       	cpc	r19, r25
    2e92:	71 f4       	brne	.+28     	; 0x2eb0 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2e94:	eb 81       	ldd	r30, Y+3	; 0x03
    2e96:	fc 81       	ldd	r31, Y+4	; 0x04
    2e98:	20 81       	ld	r18, Z
    2e9a:	31 81       	ldd	r19, Z+1	; 0x01
    2e9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e9e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ea0:	80 95       	com	r24
    2ea2:	90 95       	com	r25
    2ea4:	82 23       	and	r24, r18
    2ea6:	93 23       	and	r25, r19
    2ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    2eac:	91 83       	std	Z+1, r25	; 0x01
    2eae:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2eb0:	0f 90       	pop	r0
    2eb2:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2eb4:	81 e0       	ldi	r24, 0x01	; 1
    2eb6:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2eb8:	8d 81       	ldd	r24, Y+5	; 0x05
    2eba:	9e 81       	ldd	r25, Y+6	; 0x06
    2ebc:	90 70       	andi	r25, 0x00	; 0
    2ebe:	9e 83       	std	Y+6, r25	; 0x06
    2ec0:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2ec2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2ec6:	60 96       	adiw	r28, 0x10	; 16
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	f8 94       	cli
    2ecc:	de bf       	out	0x3e, r29	; 62
    2ece:	0f be       	out	0x3f, r0	; 63
    2ed0:	cd bf       	out	0x3d, r28	; 61
    2ed2:	cf 91       	pop	r28
    2ed4:	df 91       	pop	r29
    2ed6:	08 95       	ret

00002ed8 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2ed8:	0f 93       	push	r16
    2eda:	1f 93       	push	r17
    2edc:	df 93       	push	r29
    2ede:	cf 93       	push	r28
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
    2ee4:	63 97       	sbiw	r28, 0x13	; 19
    2ee6:	0f b6       	in	r0, 0x3f	; 63
    2ee8:	f8 94       	cli
    2eea:	de bf       	out	0x3e, r29	; 62
    2eec:	0f be       	out	0x3f, r0	; 63
    2eee:	cd bf       	out	0x3d, r28	; 61
    2ef0:	9d 87       	std	Y+13, r25	; 0x0d
    2ef2:	8c 87       	std	Y+12, r24	; 0x0c
    2ef4:	7f 87       	std	Y+15, r23	; 0x0f
    2ef6:	6e 87       	std	Y+14, r22	; 0x0e
    2ef8:	48 8b       	std	Y+16, r20	; 0x10
    2efa:	29 8b       	std	Y+17, r18	; 0x11
    2efc:	1b 8b       	std	Y+19, r17	; 0x13
    2efe:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2f00:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f02:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f04:	9b 87       	std	Y+11, r25	; 0x0b
    2f06:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    2f08:	1f 82       	std	Y+7, r1	; 0x07
    2f0a:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2f0c:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2f0e:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2f12:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f14:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f16:	80 81       	ld	r24, Z
    2f18:	91 81       	ldd	r25, Z+1	; 0x01
    2f1a:	9a 83       	std	Y+2, r25	; 0x02
    2f1c:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2f1e:	89 81       	ldd	r24, Y+1	; 0x01
    2f20:	9a 81       	ldd	r25, Y+2	; 0x02
    2f22:	2e 85       	ldd	r18, Y+14	; 0x0e
    2f24:	3f 85       	ldd	r19, Y+15	; 0x0f
    2f26:	b9 01       	movw	r22, r18
    2f28:	49 89       	ldd	r20, Y+17	; 0x11
    2f2a:	0e 94 a4 19 	call	0x3348	; 0x3348 <prvTestWaitCondition>
    2f2e:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2f30:	8d 81       	ldd	r24, Y+5	; 0x05
    2f32:	88 23       	and	r24, r24
    2f34:	c1 f0       	breq	.+48     	; 0x2f66 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2f36:	89 81       	ldd	r24, Y+1	; 0x01
    2f38:	9a 81       	ldd	r25, Y+2	; 0x02
    2f3a:	99 87       	std	Y+9, r25	; 0x09
    2f3c:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2f3e:	1b 8a       	std	Y+19, r1	; 0x13
    2f40:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2f42:	88 89       	ldd	r24, Y+16	; 0x10
    2f44:	88 23       	and	r24, r24
    2f46:	d9 f1       	breq	.+118    	; 0x2fbe <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2f48:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f4a:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f4c:	20 81       	ld	r18, Z
    2f4e:	31 81       	ldd	r19, Z+1	; 0x01
    2f50:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f52:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f54:	80 95       	com	r24
    2f56:	90 95       	com	r25
    2f58:	82 23       	and	r24, r18
    2f5a:	93 23       	and	r25, r19
    2f5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f60:	91 83       	std	Z+1, r25	; 0x01
    2f62:	80 83       	st	Z, r24
    2f64:	2c c0       	rjmp	.+88     	; 0x2fbe <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2f66:	8a 89       	ldd	r24, Y+18	; 0x12
    2f68:	9b 89       	ldd	r25, Y+19	; 0x13
    2f6a:	00 97       	sbiw	r24, 0x00	; 0
    2f6c:	29 f4       	brne	.+10     	; 0x2f78 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2f6e:	89 81       	ldd	r24, Y+1	; 0x01
    2f70:	9a 81       	ldd	r25, Y+2	; 0x02
    2f72:	99 87       	std	Y+9, r25	; 0x09
    2f74:	88 87       	std	Y+8, r24	; 0x08
    2f76:	23 c0       	rjmp	.+70     	; 0x2fbe <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2f78:	88 89       	ldd	r24, Y+16	; 0x10
    2f7a:	88 23       	and	r24, r24
    2f7c:	29 f0       	breq	.+10     	; 0x2f88 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2f7e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f80:	9f 81       	ldd	r25, Y+7	; 0x07
    2f82:	91 60       	ori	r25, 0x01	; 1
    2f84:	9f 83       	std	Y+7, r25	; 0x07
    2f86:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2f88:	89 89       	ldd	r24, Y+17	; 0x11
    2f8a:	88 23       	and	r24, r24
    2f8c:	29 f0       	breq	.+10     	; 0x2f98 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2f8e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f90:	9f 81       	ldd	r25, Y+7	; 0x07
    2f92:	94 60       	ori	r25, 0x04	; 4
    2f94:	9f 83       	std	Y+7, r25	; 0x07
    2f96:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2f98:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f9c:	bc 01       	movw	r22, r24
    2f9e:	6e 5f       	subi	r22, 0xFE	; 254
    2fa0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fa2:	2e 85       	ldd	r18, Y+14	; 0x0e
    2fa4:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fa6:	8e 81       	ldd	r24, Y+6	; 0x06
    2fa8:	9f 81       	ldd	r25, Y+7	; 0x07
    2faa:	28 2b       	or	r18, r24
    2fac:	39 2b       	or	r19, r25
    2fae:	4a 89       	ldd	r20, Y+18	; 0x12
    2fb0:	5b 89       	ldd	r21, Y+19	; 0x13
    2fb2:	cb 01       	movw	r24, r22
    2fb4:	b9 01       	movw	r22, r18
    2fb6:	0e 94 d1 2d 	call	0x5ba2	; 0x5ba2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2fba:	19 86       	std	Y+9, r1	; 0x09
    2fbc:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2fbe:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    2fc2:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    2fc4:	8a 89       	ldd	r24, Y+18	; 0x12
    2fc6:	9b 89       	ldd	r25, Y+19	; 0x13
    2fc8:	00 97       	sbiw	r24, 0x00	; 0
    2fca:	09 f4       	brne	.+2      	; 0x2fce <xEventGroupWaitBits+0xf6>
    2fcc:	3b c0       	rjmp	.+118    	; 0x3044 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    2fce:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd0:	88 23       	and	r24, r24
    2fd2:	11 f4       	brne	.+4      	; 0x2fd8 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    2fd4:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2fd8:	0e 94 6e 32 	call	0x64dc	; 0x64dc <uxTaskResetEventItemValue>
    2fdc:	99 87       	std	Y+9, r25	; 0x09
    2fde:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2fe0:	88 85       	ldd	r24, Y+8	; 0x08
    2fe2:	99 85       	ldd	r25, Y+9	; 0x09
    2fe4:	80 70       	andi	r24, 0x00	; 0
    2fe6:	92 70       	andi	r25, 0x02	; 2
    2fe8:	00 97       	sbiw	r24, 0x00	; 0
    2fea:	39 f5       	brne	.+78     	; 0x303a <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    2fec:	0f b6       	in	r0, 0x3f	; 63
    2fee:	f8 94       	cli
    2ff0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2ff2:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ff4:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ff6:	80 81       	ld	r24, Z
    2ff8:	91 81       	ldd	r25, Z+1	; 0x01
    2ffa:	99 87       	std	Y+9, r25	; 0x09
    2ffc:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2ffe:	88 85       	ldd	r24, Y+8	; 0x08
    3000:	99 85       	ldd	r25, Y+9	; 0x09
    3002:	2e 85       	ldd	r18, Y+14	; 0x0e
    3004:	3f 85       	ldd	r19, Y+15	; 0x0f
    3006:	b9 01       	movw	r22, r18
    3008:	49 89       	ldd	r20, Y+17	; 0x11
    300a:	0e 94 a4 19 	call	0x3348	; 0x3348 <prvTestWaitCondition>
    300e:	88 23       	and	r24, r24
    3010:	89 f0       	breq	.+34     	; 0x3034 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    3012:	88 89       	ldd	r24, Y+16	; 0x10
    3014:	88 23       	and	r24, r24
    3016:	71 f0       	breq	.+28     	; 0x3034 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3018:	ea 85       	ldd	r30, Y+10	; 0x0a
    301a:	fb 85       	ldd	r31, Y+11	; 0x0b
    301c:	20 81       	ld	r18, Z
    301e:	31 81       	ldd	r19, Z+1	; 0x01
    3020:	8e 85       	ldd	r24, Y+14	; 0x0e
    3022:	9f 85       	ldd	r25, Y+15	; 0x0f
    3024:	80 95       	com	r24
    3026:	90 95       	com	r25
    3028:	82 23       	and	r24, r18
    302a:	93 23       	and	r25, r19
    302c:	ea 85       	ldd	r30, Y+10	; 0x0a
    302e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3030:	91 83       	std	Z+1, r25	; 0x01
    3032:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3034:	0f 90       	pop	r0
    3036:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    3038:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    303a:	88 85       	ldd	r24, Y+8	; 0x08
    303c:	99 85       	ldd	r25, Y+9	; 0x09
    303e:	90 70       	andi	r25, 0x00	; 0
    3040:	99 87       	std	Y+9, r25	; 0x09
    3042:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    3044:	88 85       	ldd	r24, Y+8	; 0x08
    3046:	99 85       	ldd	r25, Y+9	; 0x09
}
    3048:	63 96       	adiw	r28, 0x13	; 19
    304a:	0f b6       	in	r0, 0x3f	; 63
    304c:	f8 94       	cli
    304e:	de bf       	out	0x3e, r29	; 62
    3050:	0f be       	out	0x3f, r0	; 63
    3052:	cd bf       	out	0x3d, r28	; 61
    3054:	cf 91       	pop	r28
    3056:	df 91       	pop	r29
    3058:	1f 91       	pop	r17
    305a:	0f 91       	pop	r16
    305c:	08 95       	ret

0000305e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    305e:	df 93       	push	r29
    3060:	cf 93       	push	r28
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
    3066:	28 97       	sbiw	r28, 0x08	; 8
    3068:	0f b6       	in	r0, 0x3f	; 63
    306a:	f8 94       	cli
    306c:	de bf       	out	0x3e, r29	; 62
    306e:	0f be       	out	0x3f, r0	; 63
    3070:	cd bf       	out	0x3d, r28	; 61
    3072:	9e 83       	std	Y+6, r25	; 0x06
    3074:	8d 83       	std	Y+5, r24	; 0x05
    3076:	78 87       	std	Y+8, r23	; 0x08
    3078:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    307a:	8d 81       	ldd	r24, Y+5	; 0x05
    307c:	9e 81       	ldd	r25, Y+6	; 0x06
    307e:	9c 83       	std	Y+4, r25	; 0x04
    3080:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    3082:	0f b6       	in	r0, 0x3f	; 63
    3084:	f8 94       	cli
    3086:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    3088:	eb 81       	ldd	r30, Y+3	; 0x03
    308a:	fc 81       	ldd	r31, Y+4	; 0x04
    308c:	80 81       	ld	r24, Z
    308e:	91 81       	ldd	r25, Z+1	; 0x01
    3090:	9a 83       	std	Y+2, r25	; 0x02
    3092:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    3094:	eb 81       	ldd	r30, Y+3	; 0x03
    3096:	fc 81       	ldd	r31, Y+4	; 0x04
    3098:	20 81       	ld	r18, Z
    309a:	31 81       	ldd	r19, Z+1	; 0x01
    309c:	8f 81       	ldd	r24, Y+7	; 0x07
    309e:	98 85       	ldd	r25, Y+8	; 0x08
    30a0:	80 95       	com	r24
    30a2:	90 95       	com	r25
    30a4:	82 23       	and	r24, r18
    30a6:	93 23       	and	r25, r19
    30a8:	eb 81       	ldd	r30, Y+3	; 0x03
    30aa:	fc 81       	ldd	r31, Y+4	; 0x04
    30ac:	91 83       	std	Z+1, r25	; 0x01
    30ae:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    30b0:	0f 90       	pop	r0
    30b2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30b8:	28 96       	adiw	r28, 0x08	; 8
    30ba:	0f b6       	in	r0, 0x3f	; 63
    30bc:	f8 94       	cli
    30be:	de bf       	out	0x3e, r29	; 62
    30c0:	0f be       	out	0x3f, r0	; 63
    30c2:	cd bf       	out	0x3d, r28	; 61
    30c4:	cf 91       	pop	r28
    30c6:	df 91       	pop	r29
    30c8:	08 95       	ret

000030ca <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    30ca:	df 93       	push	r29
    30cc:	cf 93       	push	r28
    30ce:	cd b7       	in	r28, 0x3d	; 61
    30d0:	de b7       	in	r29, 0x3e	; 62
    30d2:	27 97       	sbiw	r28, 0x07	; 7
    30d4:	0f b6       	in	r0, 0x3f	; 63
    30d6:	f8 94       	cli
    30d8:	de bf       	out	0x3e, r29	; 62
    30da:	0f be       	out	0x3f, r0	; 63
    30dc:	cd bf       	out	0x3d, r28	; 61
    30de:	9f 83       	std	Y+7, r25	; 0x07
    30e0:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    30e2:	8e 81       	ldd	r24, Y+6	; 0x06
    30e4:	9f 81       	ldd	r25, Y+7	; 0x07
    30e6:	9c 83       	std	Y+4, r25	; 0x04
    30e8:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30ea:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    30ec:	eb 81       	ldd	r30, Y+3	; 0x03
    30ee:	fc 81       	ldd	r31, Y+4	; 0x04
    30f0:	80 81       	ld	r24, Z
    30f2:	91 81       	ldd	r25, Z+1	; 0x01
    30f4:	9a 83       	std	Y+2, r25	; 0x02
    30f6:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
    30fa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30fc:	27 96       	adiw	r28, 0x07	; 7
    30fe:	0f b6       	in	r0, 0x3f	; 63
    3100:	f8 94       	cli
    3102:	de bf       	out	0x3e, r29	; 62
    3104:	0f be       	out	0x3f, r0	; 63
    3106:	cd bf       	out	0x3d, r28	; 61
    3108:	cf 91       	pop	r28
    310a:	df 91       	pop	r29
    310c:	08 95       	ret

0000310e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    310e:	df 93       	push	r29
    3110:	cf 93       	push	r28
    3112:	cd b7       	in	r28, 0x3d	; 61
    3114:	de b7       	in	r29, 0x3e	; 62
    3116:	65 97       	sbiw	r28, 0x15	; 21
    3118:	0f b6       	in	r0, 0x3f	; 63
    311a:	f8 94       	cli
    311c:	de bf       	out	0x3e, r29	; 62
    311e:	0f be       	out	0x3f, r0	; 63
    3120:	cd bf       	out	0x3d, r28	; 61
    3122:	9b 8b       	std	Y+19, r25	; 0x13
    3124:	8a 8b       	std	Y+18, r24	; 0x12
    3126:	7d 8b       	std	Y+21, r23	; 0x15
    3128:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    312a:	19 86       	std	Y+9, r1	; 0x09
    312c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    312e:	8a 89       	ldd	r24, Y+18	; 0x12
    3130:	9b 89       	ldd	r25, Y+19	; 0x13
    3132:	9b 83       	std	Y+3, r25	; 0x03
    3134:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    3136:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    3138:	8a 81       	ldd	r24, Y+2	; 0x02
    313a:	9b 81       	ldd	r25, Y+3	; 0x03
    313c:	02 96       	adiw	r24, 0x02	; 2
    313e:	9b 87       	std	Y+11, r25	; 0x0b
    3140:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3142:	8a 85       	ldd	r24, Y+10	; 0x0a
    3144:	9b 85       	ldd	r25, Y+11	; 0x0b
    3146:	03 96       	adiw	r24, 0x03	; 3
    3148:	9d 87       	std	Y+13, r25	; 0x0d
    314a:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    314c:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    3150:	ea 85       	ldd	r30, Y+10	; 0x0a
    3152:	fb 85       	ldd	r31, Y+11	; 0x0b
    3154:	85 81       	ldd	r24, Z+5	; 0x05
    3156:	96 81       	ldd	r25, Z+6	; 0x06
    3158:	99 8b       	std	Y+17, r25	; 0x11
    315a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    315c:	ea 81       	ldd	r30, Y+2	; 0x02
    315e:	fb 81       	ldd	r31, Y+3	; 0x03
    3160:	20 81       	ld	r18, Z
    3162:	31 81       	ldd	r19, Z+1	; 0x01
    3164:	8c 89       	ldd	r24, Y+20	; 0x14
    3166:	9d 89       	ldd	r25, Y+21	; 0x15
    3168:	82 2b       	or	r24, r18
    316a:	93 2b       	or	r25, r19
    316c:	ea 81       	ldd	r30, Y+2	; 0x02
    316e:	fb 81       	ldd	r31, Y+3	; 0x03
    3170:	91 83       	std	Z+1, r25	; 0x01
    3172:	80 83       	st	Z, r24
    3174:	59 c0       	rjmp	.+178    	; 0x3228 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    3176:	e8 89       	ldd	r30, Y+16	; 0x10
    3178:	f9 89       	ldd	r31, Y+17	; 0x11
    317a:	82 81       	ldd	r24, Z+2	; 0x02
    317c:	93 81       	ldd	r25, Z+3	; 0x03
    317e:	9f 87       	std	Y+15, r25	; 0x0f
    3180:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    3182:	e8 89       	ldd	r30, Y+16	; 0x10
    3184:	f9 89       	ldd	r31, Y+17	; 0x11
    3186:	80 81       	ld	r24, Z
    3188:	91 81       	ldd	r25, Z+1	; 0x01
    318a:	9f 83       	std	Y+7, r25	; 0x07
    318c:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    318e:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    3190:	8e 81       	ldd	r24, Y+6	; 0x06
    3192:	9f 81       	ldd	r25, Y+7	; 0x07
    3194:	80 70       	andi	r24, 0x00	; 0
    3196:	9d 83       	std	Y+5, r25	; 0x05
    3198:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    319a:	8e 81       	ldd	r24, Y+6	; 0x06
    319c:	9f 81       	ldd	r25, Y+7	; 0x07
    319e:	90 70       	andi	r25, 0x00	; 0
    31a0:	9f 83       	std	Y+7, r25	; 0x07
    31a2:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    31a4:	8c 81       	ldd	r24, Y+4	; 0x04
    31a6:	9d 81       	ldd	r25, Y+5	; 0x05
    31a8:	80 70       	andi	r24, 0x00	; 0
    31aa:	94 70       	andi	r25, 0x04	; 4
    31ac:	00 97       	sbiw	r24, 0x00	; 0
    31ae:	69 f4       	brne	.+26     	; 0x31ca <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    31b0:	ea 81       	ldd	r30, Y+2	; 0x02
    31b2:	fb 81       	ldd	r31, Y+3	; 0x03
    31b4:	20 81       	ld	r18, Z
    31b6:	31 81       	ldd	r19, Z+1	; 0x01
    31b8:	8e 81       	ldd	r24, Y+6	; 0x06
    31ba:	9f 81       	ldd	r25, Y+7	; 0x07
    31bc:	82 23       	and	r24, r18
    31be:	93 23       	and	r25, r19
    31c0:	00 97       	sbiw	r24, 0x00	; 0
    31c2:	91 f0       	breq	.+36     	; 0x31e8 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    31c4:	81 e0       	ldi	r24, 0x01	; 1
    31c6:	89 83       	std	Y+1, r24	; 0x01
    31c8:	0f c0       	rjmp	.+30     	; 0x31e8 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    31ca:	ea 81       	ldd	r30, Y+2	; 0x02
    31cc:	fb 81       	ldd	r31, Y+3	; 0x03
    31ce:	20 81       	ld	r18, Z
    31d0:	31 81       	ldd	r19, Z+1	; 0x01
    31d2:	8e 81       	ldd	r24, Y+6	; 0x06
    31d4:	9f 81       	ldd	r25, Y+7	; 0x07
    31d6:	28 23       	and	r18, r24
    31d8:	39 23       	and	r19, r25
    31da:	8e 81       	ldd	r24, Y+6	; 0x06
    31dc:	9f 81       	ldd	r25, Y+7	; 0x07
    31de:	28 17       	cp	r18, r24
    31e0:	39 07       	cpc	r19, r25
    31e2:	11 f4       	brne	.+4      	; 0x31e8 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    31e8:	89 81       	ldd	r24, Y+1	; 0x01
    31ea:	88 23       	and	r24, r24
    31ec:	c9 f0       	breq	.+50     	; 0x3220 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    31ee:	8c 81       	ldd	r24, Y+4	; 0x04
    31f0:	9d 81       	ldd	r25, Y+5	; 0x05
    31f2:	80 70       	andi	r24, 0x00	; 0
    31f4:	91 70       	andi	r25, 0x01	; 1
    31f6:	00 97       	sbiw	r24, 0x00	; 0
    31f8:	41 f0       	breq	.+16     	; 0x320a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    31fa:	88 85       	ldd	r24, Y+8	; 0x08
    31fc:	99 85       	ldd	r25, Y+9	; 0x09
    31fe:	2e 81       	ldd	r18, Y+6	; 0x06
    3200:	3f 81       	ldd	r19, Y+7	; 0x07
    3202:	82 2b       	or	r24, r18
    3204:	93 2b       	or	r25, r19
    3206:	99 87       	std	Y+9, r25	; 0x09
    3208:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    320a:	ea 81       	ldd	r30, Y+2	; 0x02
    320c:	fb 81       	ldd	r31, Y+3	; 0x03
    320e:	80 81       	ld	r24, Z
    3210:	91 81       	ldd	r25, Z+1	; 0x01
    3212:	9c 01       	movw	r18, r24
    3214:	32 60       	ori	r19, 0x02	; 2
    3216:	88 89       	ldd	r24, Y+16	; 0x10
    3218:	99 89       	ldd	r25, Y+17	; 0x11
    321a:	b9 01       	movw	r22, r18
    321c:	0e 94 92 2e 	call	0x5d24	; 0x5d24 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    3220:	8e 85       	ldd	r24, Y+14	; 0x0e
    3222:	9f 85       	ldd	r25, Y+15	; 0x0f
    3224:	99 8b       	std	Y+17, r25	; 0x11
    3226:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    3228:	28 89       	ldd	r18, Y+16	; 0x10
    322a:	39 89       	ldd	r19, Y+17	; 0x11
    322c:	8c 85       	ldd	r24, Y+12	; 0x0c
    322e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3230:	28 17       	cp	r18, r24
    3232:	39 07       	cpc	r19, r25
    3234:	09 f0       	breq	.+2      	; 0x3238 <xEventGroupSetBits+0x12a>
    3236:	9f cf       	rjmp	.-194    	; 0x3176 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    3238:	ea 81       	ldd	r30, Y+2	; 0x02
    323a:	fb 81       	ldd	r31, Y+3	; 0x03
    323c:	20 81       	ld	r18, Z
    323e:	31 81       	ldd	r19, Z+1	; 0x01
    3240:	88 85       	ldd	r24, Y+8	; 0x08
    3242:	99 85       	ldd	r25, Y+9	; 0x09
    3244:	80 95       	com	r24
    3246:	90 95       	com	r25
    3248:	82 23       	and	r24, r18
    324a:	93 23       	and	r25, r19
    324c:	ea 81       	ldd	r30, Y+2	; 0x02
    324e:	fb 81       	ldd	r31, Y+3	; 0x03
    3250:	91 83       	std	Z+1, r25	; 0x01
    3252:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    3254:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    3258:	ea 81       	ldd	r30, Y+2	; 0x02
    325a:	fb 81       	ldd	r31, Y+3	; 0x03
    325c:	80 81       	ld	r24, Z
    325e:	91 81       	ldd	r25, Z+1	; 0x01
}
    3260:	65 96       	adiw	r28, 0x15	; 21
    3262:	0f b6       	in	r0, 0x3f	; 63
    3264:	f8 94       	cli
    3266:	de bf       	out	0x3e, r29	; 62
    3268:	0f be       	out	0x3f, r0	; 63
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	cf 91       	pop	r28
    326e:	df 91       	pop	r29
    3270:	08 95       	ret

00003272 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    3272:	df 93       	push	r29
    3274:	cf 93       	push	r28
    3276:	00 d0       	rcall	.+0      	; 0x3278 <vEventGroupDelete+0x6>
    3278:	00 d0       	rcall	.+0      	; 0x327a <vEventGroupDelete+0x8>
    327a:	00 d0       	rcall	.+0      	; 0x327c <vEventGroupDelete+0xa>
    327c:	cd b7       	in	r28, 0x3d	; 61
    327e:	de b7       	in	r29, 0x3e	; 62
    3280:	9e 83       	std	Y+6, r25	; 0x06
    3282:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    3284:	8d 81       	ldd	r24, Y+5	; 0x05
    3286:	9e 81       	ldd	r25, Y+6	; 0x06
    3288:	9c 83       	std	Y+4, r25	; 0x04
    328a:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    328c:	8b 81       	ldd	r24, Y+3	; 0x03
    328e:	9c 81       	ldd	r25, Y+4	; 0x04
    3290:	02 96       	adiw	r24, 0x02	; 2
    3292:	9a 83       	std	Y+2, r25	; 0x02
    3294:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    3296:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
    329a:	08 c0       	rjmp	.+16     	; 0x32ac <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    329c:	e9 81       	ldd	r30, Y+1	; 0x01
    329e:	fa 81       	ldd	r31, Y+2	; 0x02
    32a0:	85 81       	ldd	r24, Z+5	; 0x05
    32a2:	96 81       	ldd	r25, Z+6	; 0x06
    32a4:	60 e0       	ldi	r22, 0x00	; 0
    32a6:	72 e0       	ldi	r23, 0x02	; 2
    32a8:	0e 94 92 2e 	call	0x5d24	; 0x5d24 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    32ac:	e9 81       	ldd	r30, Y+1	; 0x01
    32ae:	fa 81       	ldd	r31, Y+2	; 0x02
    32b0:	80 81       	ld	r24, Z
    32b2:	88 23       	and	r24, r24
    32b4:	99 f7       	brne	.-26     	; 0x329c <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    32b6:	8b 81       	ldd	r24, Y+3	; 0x03
    32b8:	9c 81       	ldd	r25, Y+4	; 0x04
    32ba:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
	}
	( void ) xTaskResumeAll();
    32be:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
}
    32c2:	26 96       	adiw	r28, 0x06	; 6
    32c4:	0f b6       	in	r0, 0x3f	; 63
    32c6:	f8 94       	cli
    32c8:	de bf       	out	0x3e, r29	; 62
    32ca:	0f be       	out	0x3f, r0	; 63
    32cc:	cd bf       	out	0x3d, r28	; 61
    32ce:	cf 91       	pop	r28
    32d0:	df 91       	pop	r29
    32d2:	08 95       	ret

000032d4 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    32d4:	df 93       	push	r29
    32d6:	cf 93       	push	r28
    32d8:	00 d0       	rcall	.+0      	; 0x32da <vEventGroupSetBitsCallback+0x6>
    32da:	00 d0       	rcall	.+0      	; 0x32dc <vEventGroupSetBitsCallback+0x8>
    32dc:	00 d0       	rcall	.+0      	; 0x32de <vEventGroupSetBitsCallback+0xa>
    32de:	cd b7       	in	r28, 0x3d	; 61
    32e0:	de b7       	in	r29, 0x3e	; 62
    32e2:	9a 83       	std	Y+2, r25	; 0x02
    32e4:	89 83       	std	Y+1, r24	; 0x01
    32e6:	4b 83       	std	Y+3, r20	; 0x03
    32e8:	5c 83       	std	Y+4, r21	; 0x04
    32ea:	6d 83       	std	Y+5, r22	; 0x05
    32ec:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    32ee:	2b 81       	ldd	r18, Y+3	; 0x03
    32f0:	3c 81       	ldd	r19, Y+4	; 0x04
    32f2:	89 81       	ldd	r24, Y+1	; 0x01
    32f4:	9a 81       	ldd	r25, Y+2	; 0x02
    32f6:	b9 01       	movw	r22, r18
    32f8:	0e 94 87 18 	call	0x310e	; 0x310e <xEventGroupSetBits>
}
    32fc:	26 96       	adiw	r28, 0x06	; 6
    32fe:	0f b6       	in	r0, 0x3f	; 63
    3300:	f8 94       	cli
    3302:	de bf       	out	0x3e, r29	; 62
    3304:	0f be       	out	0x3f, r0	; 63
    3306:	cd bf       	out	0x3d, r28	; 61
    3308:	cf 91       	pop	r28
    330a:	df 91       	pop	r29
    330c:	08 95       	ret

0000330e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    330e:	df 93       	push	r29
    3310:	cf 93       	push	r28
    3312:	00 d0       	rcall	.+0      	; 0x3314 <vEventGroupClearBitsCallback+0x6>
    3314:	00 d0       	rcall	.+0      	; 0x3316 <vEventGroupClearBitsCallback+0x8>
    3316:	00 d0       	rcall	.+0      	; 0x3318 <vEventGroupClearBitsCallback+0xa>
    3318:	cd b7       	in	r28, 0x3d	; 61
    331a:	de b7       	in	r29, 0x3e	; 62
    331c:	9a 83       	std	Y+2, r25	; 0x02
    331e:	89 83       	std	Y+1, r24	; 0x01
    3320:	4b 83       	std	Y+3, r20	; 0x03
    3322:	5c 83       	std	Y+4, r21	; 0x04
    3324:	6d 83       	std	Y+5, r22	; 0x05
    3326:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    3328:	2b 81       	ldd	r18, Y+3	; 0x03
    332a:	3c 81       	ldd	r19, Y+4	; 0x04
    332c:	89 81       	ldd	r24, Y+1	; 0x01
    332e:	9a 81       	ldd	r25, Y+2	; 0x02
    3330:	b9 01       	movw	r22, r18
    3332:	0e 94 2f 18 	call	0x305e	; 0x305e <xEventGroupClearBits>
}
    3336:	26 96       	adiw	r28, 0x06	; 6
    3338:	0f b6       	in	r0, 0x3f	; 63
    333a:	f8 94       	cli
    333c:	de bf       	out	0x3e, r29	; 62
    333e:	0f be       	out	0x3f, r0	; 63
    3340:	cd bf       	out	0x3d, r28	; 61
    3342:	cf 91       	pop	r28
    3344:	df 91       	pop	r29
    3346:	08 95       	ret

00003348 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    3348:	df 93       	push	r29
    334a:	cf 93       	push	r28
    334c:	00 d0       	rcall	.+0      	; 0x334e <prvTestWaitCondition+0x6>
    334e:	00 d0       	rcall	.+0      	; 0x3350 <prvTestWaitCondition+0x8>
    3350:	00 d0       	rcall	.+0      	; 0x3352 <prvTestWaitCondition+0xa>
    3352:	cd b7       	in	r28, 0x3d	; 61
    3354:	de b7       	in	r29, 0x3e	; 62
    3356:	9b 83       	std	Y+3, r25	; 0x03
    3358:	8a 83       	std	Y+2, r24	; 0x02
    335a:	7d 83       	std	Y+5, r23	; 0x05
    335c:	6c 83       	std	Y+4, r22	; 0x04
    335e:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    3360:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    3362:	8e 81       	ldd	r24, Y+6	; 0x06
    3364:	88 23       	and	r24, r24
    3366:	59 f4       	brne	.+22     	; 0x337e <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    3368:	8a 81       	ldd	r24, Y+2	; 0x02
    336a:	9b 81       	ldd	r25, Y+3	; 0x03
    336c:	2c 81       	ldd	r18, Y+4	; 0x04
    336e:	3d 81       	ldd	r19, Y+5	; 0x05
    3370:	82 23       	and	r24, r18
    3372:	93 23       	and	r25, r19
    3374:	00 97       	sbiw	r24, 0x00	; 0
    3376:	81 f0       	breq	.+32     	; 0x3398 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    3378:	81 e0       	ldi	r24, 0x01	; 1
    337a:	89 83       	std	Y+1, r24	; 0x01
    337c:	0d c0       	rjmp	.+26     	; 0x3398 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    337e:	2a 81       	ldd	r18, Y+2	; 0x02
    3380:	3b 81       	ldd	r19, Y+3	; 0x03
    3382:	8c 81       	ldd	r24, Y+4	; 0x04
    3384:	9d 81       	ldd	r25, Y+5	; 0x05
    3386:	28 23       	and	r18, r24
    3388:	39 23       	and	r19, r25
    338a:	8c 81       	ldd	r24, Y+4	; 0x04
    338c:	9d 81       	ldd	r25, Y+5	; 0x05
    338e:	28 17       	cp	r18, r24
    3390:	39 07       	cpc	r19, r25
    3392:	11 f4       	brne	.+4      	; 0x3398 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    3394:	81 e0       	ldi	r24, 0x01	; 1
    3396:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    3398:	89 81       	ldd	r24, Y+1	; 0x01
}
    339a:	26 96       	adiw	r28, 0x06	; 6
    339c:	0f b6       	in	r0, 0x3f	; 63
    339e:	f8 94       	cli
    33a0:	de bf       	out	0x3e, r29	; 62
    33a2:	0f be       	out	0x3f, r0	; 63
    33a4:	cd bf       	out	0x3d, r28	; 61
    33a6:	cf 91       	pop	r28
    33a8:	df 91       	pop	r29
    33aa:	08 95       	ret

000033ac <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    33ac:	df 93       	push	r29
    33ae:	cf 93       	push	r28
    33b0:	00 d0       	rcall	.+0      	; 0x33b2 <pvPortMalloc+0x6>
    33b2:	00 d0       	rcall	.+0      	; 0x33b4 <pvPortMalloc+0x8>
    33b4:	cd b7       	in	r28, 0x3d	; 61
    33b6:	de b7       	in	r29, 0x3e	; 62
    33b8:	9c 83       	std	Y+4, r25	; 0x04
    33ba:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    33bc:	1a 82       	std	Y+2, r1	; 0x02
    33be:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    33c0:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    33c4:	80 91 e7 01 	lds	r24, 0x01E7
    33c8:	90 91 e8 01 	lds	r25, 0x01E8
    33cc:	00 97       	sbiw	r24, 0x00	; 0
    33ce:	31 f4       	brne	.+12     	; 0x33dc <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    33d0:	8a ee       	ldi	r24, 0xEA	; 234
    33d2:	91 e0       	ldi	r25, 0x01	; 1
    33d4:	90 93 e8 01 	sts	0x01E8, r25
    33d8:	80 93 e7 01 	sts	0x01E7, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    33dc:	80 91 e5 01 	lds	r24, 0x01E5
    33e0:	90 91 e6 01 	lds	r25, 0x01E6
    33e4:	2b 81       	ldd	r18, Y+3	; 0x03
    33e6:	3c 81       	ldd	r19, Y+4	; 0x04
    33e8:	82 0f       	add	r24, r18
    33ea:	93 1f       	adc	r25, r19
    33ec:	24 e0       	ldi	r18, 0x04	; 4
    33ee:	8d 37       	cpi	r24, 0x7D	; 125
    33f0:	92 07       	cpc	r25, r18
    33f2:	38 f5       	brcc	.+78     	; 0x3442 <pvPortMalloc+0x96>
    33f4:	20 91 e5 01 	lds	r18, 0x01E5
    33f8:	30 91 e6 01 	lds	r19, 0x01E6
    33fc:	8b 81       	ldd	r24, Y+3	; 0x03
    33fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3400:	28 0f       	add	r18, r24
    3402:	39 1f       	adc	r19, r25
    3404:	80 91 e5 01 	lds	r24, 0x01E5
    3408:	90 91 e6 01 	lds	r25, 0x01E6
    340c:	82 17       	cp	r24, r18
    340e:	93 07       	cpc	r25, r19
    3410:	c0 f4       	brcc	.+48     	; 0x3442 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3412:	20 91 e7 01 	lds	r18, 0x01E7
    3416:	30 91 e8 01 	lds	r19, 0x01E8
    341a:	80 91 e5 01 	lds	r24, 0x01E5
    341e:	90 91 e6 01 	lds	r25, 0x01E6
    3422:	82 0f       	add	r24, r18
    3424:	93 1f       	adc	r25, r19
    3426:	9a 83       	std	Y+2, r25	; 0x02
    3428:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    342a:	20 91 e5 01 	lds	r18, 0x01E5
    342e:	30 91 e6 01 	lds	r19, 0x01E6
    3432:	8b 81       	ldd	r24, Y+3	; 0x03
    3434:	9c 81       	ldd	r25, Y+4	; 0x04
    3436:	82 0f       	add	r24, r18
    3438:	93 1f       	adc	r25, r19
    343a:	90 93 e6 01 	sts	0x01E6, r25
    343e:	80 93 e5 01 	sts	0x01E5, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3442:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    3446:	89 81       	ldd	r24, Y+1	; 0x01
    3448:	9a 81       	ldd	r25, Y+2	; 0x02
}
    344a:	0f 90       	pop	r0
    344c:	0f 90       	pop	r0
    344e:	0f 90       	pop	r0
    3450:	0f 90       	pop	r0
    3452:	cf 91       	pop	r28
    3454:	df 91       	pop	r29
    3456:	08 95       	ret

00003458 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3458:	df 93       	push	r29
    345a:	cf 93       	push	r28
    345c:	00 d0       	rcall	.+0      	; 0x345e <vPortFree+0x6>
    345e:	cd b7       	in	r28, 0x3d	; 61
    3460:	de b7       	in	r29, 0x3e	; 62
    3462:	9a 83       	std	Y+2, r25	; 0x02
    3464:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    3466:	0f 90       	pop	r0
    3468:	0f 90       	pop	r0
    346a:	cf 91       	pop	r28
    346c:	df 91       	pop	r29
    346e:	08 95       	ret

00003470 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    3470:	df 93       	push	r29
    3472:	cf 93       	push	r28
    3474:	cd b7       	in	r28, 0x3d	; 61
    3476:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    3478:	10 92 e6 01 	sts	0x01E6, r1
    347c:	10 92 e5 01 	sts	0x01E5, r1
}
    3480:	cf 91       	pop	r28
    3482:	df 91       	pop	r29
    3484:	08 95       	ret

00003486 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3486:	df 93       	push	r29
    3488:	cf 93       	push	r28
    348a:	cd b7       	in	r28, 0x3d	; 61
    348c:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    348e:	20 91 e5 01 	lds	r18, 0x01E5
    3492:	30 91 e6 01 	lds	r19, 0x01E6
    3496:	8d e7       	ldi	r24, 0x7D	; 125
    3498:	94 e0       	ldi	r25, 0x04	; 4
    349a:	82 1b       	sub	r24, r18
    349c:	93 0b       	sbc	r25, r19
}
    349e:	cf 91       	pop	r28
    34a0:	df 91       	pop	r29
    34a2:	08 95       	ret

000034a4 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    34a4:	af 92       	push	r10
    34a6:	bf 92       	push	r11
    34a8:	cf 92       	push	r12
    34aa:	df 92       	push	r13
    34ac:	ef 92       	push	r14
    34ae:	ff 92       	push	r15
    34b0:	0f 93       	push	r16
    34b2:	df 93       	push	r29
    34b4:	cf 93       	push	r28
    34b6:	00 d0       	rcall	.+0      	; 0x34b8 <vStartIntegerMathTasks+0x14>
    34b8:	0f 92       	push	r0
    34ba:	cd b7       	in	r28, 0x3d	; 61
    34bc:	de b7       	in	r29, 0x3e	; 62
    34be:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    34c0:	1a 82       	std	Y+2, r1	; 0x02
    34c2:	19 82       	std	Y+1, r1	; 0x01
    34c4:	1b c0       	rjmp	.+54     	; 0x34fc <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
    34c8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ca:	fc 01       	movw	r30, r24
    34cc:	e9 59       	subi	r30, 0x99	; 153
    34ce:	f9 4f       	sbci	r31, 0xF9	; 249
    34d0:	80 e9       	ldi	r24, 0x90	; 144
    34d2:	9a e1       	ldi	r25, 0x1A	; 26
    34d4:	20 e7       	ldi	r18, 0x70	; 112
    34d6:	30 e0       	ldi	r19, 0x00	; 0
    34d8:	b9 01       	movw	r22, r18
    34da:	45 e5       	ldi	r20, 0x55	; 85
    34dc:	50 e0       	ldi	r21, 0x00	; 0
    34de:	9f 01       	movw	r18, r30
    34e0:	0b 81       	ldd	r16, Y+3	; 0x03
    34e2:	ee 24       	eor	r14, r14
    34e4:	ff 24       	eor	r15, r15
    34e6:	cc 24       	eor	r12, r12
    34e8:	dd 24       	eor	r13, r13
    34ea:	aa 24       	eor	r10, r10
    34ec:	bb 24       	eor	r11, r11
    34ee:	0e 94 da 26 	call	0x4db4	; 0x4db4 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    34f2:	89 81       	ldd	r24, Y+1	; 0x01
    34f4:	9a 81       	ldd	r25, Y+2	; 0x02
    34f6:	01 96       	adiw	r24, 0x01	; 1
    34f8:	9a 83       	std	Y+2, r25	; 0x02
    34fa:	89 83       	std	Y+1, r24	; 0x01
    34fc:	89 81       	ldd	r24, Y+1	; 0x01
    34fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3500:	18 16       	cp	r1, r24
    3502:	19 06       	cpc	r1, r25
    3504:	04 f7       	brge	.-64     	; 0x34c6 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    3506:	0f 90       	pop	r0
    3508:	0f 90       	pop	r0
    350a:	0f 90       	pop	r0
    350c:	cf 91       	pop	r28
    350e:	df 91       	pop	r29
    3510:	0f 91       	pop	r16
    3512:	ff 90       	pop	r15
    3514:	ef 90       	pop	r14
    3516:	df 90       	pop	r13
    3518:	cf 90       	pop	r12
    351a:	bf 90       	pop	r11
    351c:	af 90       	pop	r10
    351e:	08 95       	ret

00003520 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    3520:	df 93       	push	r29
    3522:	cf 93       	push	r28
    3524:	cd b7       	in	r28, 0x3d	; 61
    3526:	de b7       	in	r29, 0x3e	; 62
    3528:	2a 97       	sbiw	r28, 0x0a	; 10
    352a:	0f b6       	in	r0, 0x3f	; 63
    352c:	f8 94       	cli
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	0f be       	out	0x3f, r0	; 63
    3532:	cd bf       	out	0x3d, r28	; 61
    3534:	9a 87       	std	Y+10, r25	; 0x0a
    3536:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    3538:	1c 82       	std	Y+4, r1	; 0x04
    353a:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    353c:	89 85       	ldd	r24, Y+9	; 0x09
    353e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3540:	9a 83       	std	Y+2, r25	; 0x02
    3542:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    3544:	8b e7       	ldi	r24, 0x7B	; 123
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	a0 e0       	ldi	r26, 0x00	; 0
    354a:	b0 e0       	ldi	r27, 0x00	; 0
    354c:	8d 83       	std	Y+5, r24	; 0x05
    354e:	9e 83       	std	Y+6, r25	; 0x06
    3550:	af 83       	std	Y+7, r26	; 0x07
    3552:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    3554:	8d 81       	ldd	r24, Y+5	; 0x05
    3556:	9e 81       	ldd	r25, Y+6	; 0x06
    3558:	af 81       	ldd	r26, Y+7	; 0x07
    355a:	b8 85       	ldd	r27, Y+8	; 0x08
    355c:	89 5b       	subi	r24, 0xB9	; 185
    355e:	9b 46       	sbci	r25, 0x6B	; 107
    3560:	ac 4f       	sbci	r26, 0xFC	; 252
    3562:	bf 4f       	sbci	r27, 0xFF	; 255
    3564:	8d 83       	std	Y+5, r24	; 0x05
    3566:	9e 83       	std	Y+6, r25	; 0x06
    3568:	af 83       	std	Y+7, r26	; 0x07
    356a:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    356c:	8d 81       	ldd	r24, Y+5	; 0x05
    356e:	9e 81       	ldd	r25, Y+6	; 0x06
    3570:	af 81       	ldd	r26, Y+7	; 0x07
    3572:	b8 85       	ldd	r27, Y+8	; 0x08
    3574:	2d ef       	ldi	r18, 0xFD	; 253
    3576:	3f ef       	ldi	r19, 0xFF	; 255
    3578:	4f ef       	ldi	r20, 0xFF	; 255
    357a:	5f ef       	ldi	r21, 0xFF	; 255
    357c:	bc 01       	movw	r22, r24
    357e:	cd 01       	movw	r24, r26
    3580:	0e 94 3a 33 	call	0x6674	; 0x6674 <__mulsi3>
    3584:	dc 01       	movw	r26, r24
    3586:	cb 01       	movw	r24, r22
    3588:	8d 83       	std	Y+5, r24	; 0x05
    358a:	9e 83       	std	Y+6, r25	; 0x06
    358c:	af 83       	std	Y+7, r26	; 0x07
    358e:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    3590:	8d 81       	ldd	r24, Y+5	; 0x05
    3592:	9e 81       	ldd	r25, Y+6	; 0x06
    3594:	af 81       	ldd	r26, Y+7	; 0x07
    3596:	b8 85       	ldd	r27, Y+8	; 0x08
    3598:	27 e0       	ldi	r18, 0x07	; 7
    359a:	30 e0       	ldi	r19, 0x00	; 0
    359c:	40 e0       	ldi	r20, 0x00	; 0
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	bc 01       	movw	r22, r24
    35a2:	cd 01       	movw	r24, r26
    35a4:	0e 94 59 33 	call	0x66b2	; 0x66b2 <__divmodsi4>
    35a8:	da 01       	movw	r26, r20
    35aa:	c9 01       	movw	r24, r18
    35ac:	8d 83       	std	Y+5, r24	; 0x05
    35ae:	9e 83       	std	Y+6, r25	; 0x06
    35b0:	af 83       	std	Y+7, r26	; 0x07
    35b2:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    35b4:	8d 81       	ldd	r24, Y+5	; 0x05
    35b6:	9e 81       	ldd	r25, Y+6	; 0x06
    35b8:	af 81       	ldd	r26, Y+7	; 0x07
    35ba:	b8 85       	ldd	r27, Y+8	; 0x08
    35bc:	8b 31       	cpi	r24, 0x1B	; 27
    35be:	27 e7       	ldi	r18, 0x77	; 119
    35c0:	92 07       	cpc	r25, r18
    35c2:	2e ef       	ldi	r18, 0xFE	; 254
    35c4:	a2 07       	cpc	r26, r18
    35c6:	2f ef       	ldi	r18, 0xFF	; 255
    35c8:	b2 07       	cpc	r27, r18
    35ca:	21 f0       	breq	.+8      	; 0x35d4 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	90 e0       	ldi	r25, 0x00	; 0
    35d0:	9c 83       	std	Y+4, r25	; 0x04
    35d2:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    35d4:	8b 81       	ldd	r24, Y+3	; 0x03
    35d6:	9c 81       	ldd	r25, Y+4	; 0x04
    35d8:	00 97       	sbiw	r24, 0x00	; 0
    35da:	09 f0       	breq	.+2      	; 0x35de <vCompeteingIntMathTask+0xbe>
    35dc:	b3 cf       	rjmp	.-154    	; 0x3544 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    35de:	0f b6       	in	r0, 0x3f	; 63
    35e0:	f8 94       	cli
    35e2:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    35e4:	e9 81       	ldd	r30, Y+1	; 0x01
    35e6:	fa 81       	ldd	r31, Y+2	; 0x02
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    35ec:	0f 90       	pop	r0
    35ee:	0f be       	out	0x3f, r0	; 63
    35f0:	a9 cf       	rjmp	.-174    	; 0x3544 <vCompeteingIntMathTask+0x24>

000035f2 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    35f2:	df 93       	push	r29
    35f4:	cf 93       	push	r28
    35f6:	00 d0       	rcall	.+0      	; 0x35f8 <xAreIntegerMathsTaskStillRunning+0x6>
    35f8:	0f 92       	push	r0
    35fa:	cd b7       	in	r28, 0x3d	; 61
    35fc:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    35fe:	81 e0       	ldi	r24, 0x01	; 1
    3600:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3602:	1a 82       	std	Y+2, r1	; 0x02
    3604:	19 82       	std	Y+1, r1	; 0x01
    3606:	14 c0       	rjmp	.+40     	; 0x3630 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    3608:	89 81       	ldd	r24, Y+1	; 0x01
    360a:	9a 81       	ldd	r25, Y+2	; 0x02
    360c:	fc 01       	movw	r30, r24
    360e:	e9 59       	subi	r30, 0x99	; 153
    3610:	f9 4f       	sbci	r31, 0xF9	; 249
    3612:	80 81       	ld	r24, Z
    3614:	88 23       	and	r24, r24
    3616:	09 f4       	brne	.+2      	; 0x361a <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    3618:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	9a 81       	ldd	r25, Y+2	; 0x02
    361e:	fc 01       	movw	r30, r24
    3620:	e9 59       	subi	r30, 0x99	; 153
    3622:	f9 4f       	sbci	r31, 0xF9	; 249
    3624:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3626:	89 81       	ldd	r24, Y+1	; 0x01
    3628:	9a 81       	ldd	r25, Y+2	; 0x02
    362a:	01 96       	adiw	r24, 0x01	; 1
    362c:	9a 83       	std	Y+2, r25	; 0x02
    362e:	89 83       	std	Y+1, r24	; 0x01
    3630:	89 81       	ldd	r24, Y+1	; 0x01
    3632:	9a 81       	ldd	r25, Y+2	; 0x02
    3634:	18 16       	cp	r1, r24
    3636:	19 06       	cpc	r1, r25
    3638:	3c f7       	brge	.-50     	; 0x3608 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    363a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    363c:	0f 90       	pop	r0
    363e:	0f 90       	pop	r0
    3640:	0f 90       	pop	r0
    3642:	cf 91       	pop	r28
    3644:	df 91       	pop	r29
    3646:	08 95       	ret

00003648 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3648:	df 93       	push	r29
    364a:	cf 93       	push	r28
    364c:	00 d0       	rcall	.+0      	; 0x364e <vListInitialise+0x6>
    364e:	cd b7       	in	r28, 0x3d	; 61
    3650:	de b7       	in	r29, 0x3e	; 62
    3652:	9a 83       	std	Y+2, r25	; 0x02
    3654:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3656:	89 81       	ldd	r24, Y+1	; 0x01
    3658:	9a 81       	ldd	r25, Y+2	; 0x02
    365a:	03 96       	adiw	r24, 0x03	; 3
    365c:	e9 81       	ldd	r30, Y+1	; 0x01
    365e:	fa 81       	ldd	r31, Y+2	; 0x02
    3660:	92 83       	std	Z+2, r25	; 0x02
    3662:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3664:	e9 81       	ldd	r30, Y+1	; 0x01
    3666:	fa 81       	ldd	r31, Y+2	; 0x02
    3668:	8f ef       	ldi	r24, 0xFF	; 255
    366a:	9f ef       	ldi	r25, 0xFF	; 255
    366c:	94 83       	std	Z+4, r25	; 0x04
    366e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	9a 81       	ldd	r25, Y+2	; 0x02
    3674:	03 96       	adiw	r24, 0x03	; 3
    3676:	e9 81       	ldd	r30, Y+1	; 0x01
    3678:	fa 81       	ldd	r31, Y+2	; 0x02
    367a:	96 83       	std	Z+6, r25	; 0x06
    367c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    367e:	89 81       	ldd	r24, Y+1	; 0x01
    3680:	9a 81       	ldd	r25, Y+2	; 0x02
    3682:	03 96       	adiw	r24, 0x03	; 3
    3684:	e9 81       	ldd	r30, Y+1	; 0x01
    3686:	fa 81       	ldd	r31, Y+2	; 0x02
    3688:	90 87       	std	Z+8, r25	; 0x08
    368a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    368c:	e9 81       	ldd	r30, Y+1	; 0x01
    368e:	fa 81       	ldd	r31, Y+2	; 0x02
    3690:	10 82       	st	Z, r1
}
    3692:	0f 90       	pop	r0
    3694:	0f 90       	pop	r0
    3696:	cf 91       	pop	r28
    3698:	df 91       	pop	r29
    369a:	08 95       	ret

0000369c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    369c:	df 93       	push	r29
    369e:	cf 93       	push	r28
    36a0:	00 d0       	rcall	.+0      	; 0x36a2 <vListInitialiseItem+0x6>
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
    36a6:	9a 83       	std	Y+2, r25	; 0x02
    36a8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    36aa:	e9 81       	ldd	r30, Y+1	; 0x01
    36ac:	fa 81       	ldd	r31, Y+2	; 0x02
    36ae:	11 86       	std	Z+9, r1	; 0x09
    36b0:	10 86       	std	Z+8, r1	; 0x08
}
    36b2:	0f 90       	pop	r0
    36b4:	0f 90       	pop	r0
    36b6:	cf 91       	pop	r28
    36b8:	df 91       	pop	r29
    36ba:	08 95       	ret

000036bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    36bc:	df 93       	push	r29
    36be:	cf 93       	push	r28
    36c0:	00 d0       	rcall	.+0      	; 0x36c2 <vListInsertEnd+0x6>
    36c2:	00 d0       	rcall	.+0      	; 0x36c4 <vListInsertEnd+0x8>
    36c4:	00 d0       	rcall	.+0      	; 0x36c6 <vListInsertEnd+0xa>
    36c6:	cd b7       	in	r28, 0x3d	; 61
    36c8:	de b7       	in	r29, 0x3e	; 62
    36ca:	9c 83       	std	Y+4, r25	; 0x04
    36cc:	8b 83       	std	Y+3, r24	; 0x03
    36ce:	7e 83       	std	Y+6, r23	; 0x06
    36d0:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    36d2:	eb 81       	ldd	r30, Y+3	; 0x03
    36d4:	fc 81       	ldd	r31, Y+4	; 0x04
    36d6:	81 81       	ldd	r24, Z+1	; 0x01
    36d8:	92 81       	ldd	r25, Z+2	; 0x02
    36da:	9a 83       	std	Y+2, r25	; 0x02
    36dc:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    36de:	ed 81       	ldd	r30, Y+5	; 0x05
    36e0:	fe 81       	ldd	r31, Y+6	; 0x06
    36e2:	89 81       	ldd	r24, Y+1	; 0x01
    36e4:	9a 81       	ldd	r25, Y+2	; 0x02
    36e6:	93 83       	std	Z+3, r25	; 0x03
    36e8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    36ea:	e9 81       	ldd	r30, Y+1	; 0x01
    36ec:	fa 81       	ldd	r31, Y+2	; 0x02
    36ee:	84 81       	ldd	r24, Z+4	; 0x04
    36f0:	95 81       	ldd	r25, Z+5	; 0x05
    36f2:	ed 81       	ldd	r30, Y+5	; 0x05
    36f4:	fe 81       	ldd	r31, Y+6	; 0x06
    36f6:	95 83       	std	Z+5, r25	; 0x05
    36f8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    36fa:	e9 81       	ldd	r30, Y+1	; 0x01
    36fc:	fa 81       	ldd	r31, Y+2	; 0x02
    36fe:	04 80       	ldd	r0, Z+4	; 0x04
    3700:	f5 81       	ldd	r31, Z+5	; 0x05
    3702:	e0 2d       	mov	r30, r0
    3704:	8d 81       	ldd	r24, Y+5	; 0x05
    3706:	9e 81       	ldd	r25, Y+6	; 0x06
    3708:	93 83       	std	Z+3, r25	; 0x03
    370a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    370c:	e9 81       	ldd	r30, Y+1	; 0x01
    370e:	fa 81       	ldd	r31, Y+2	; 0x02
    3710:	8d 81       	ldd	r24, Y+5	; 0x05
    3712:	9e 81       	ldd	r25, Y+6	; 0x06
    3714:	95 83       	std	Z+5, r25	; 0x05
    3716:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3718:	ed 81       	ldd	r30, Y+5	; 0x05
    371a:	fe 81       	ldd	r31, Y+6	; 0x06
    371c:	8b 81       	ldd	r24, Y+3	; 0x03
    371e:	9c 81       	ldd	r25, Y+4	; 0x04
    3720:	91 87       	std	Z+9, r25	; 0x09
    3722:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3724:	eb 81       	ldd	r30, Y+3	; 0x03
    3726:	fc 81       	ldd	r31, Y+4	; 0x04
    3728:	80 81       	ld	r24, Z
    372a:	8f 5f       	subi	r24, 0xFF	; 255
    372c:	eb 81       	ldd	r30, Y+3	; 0x03
    372e:	fc 81       	ldd	r31, Y+4	; 0x04
    3730:	80 83       	st	Z, r24
}
    3732:	26 96       	adiw	r28, 0x06	; 6
    3734:	0f b6       	in	r0, 0x3f	; 63
    3736:	f8 94       	cli
    3738:	de bf       	out	0x3e, r29	; 62
    373a:	0f be       	out	0x3f, r0	; 63
    373c:	cd bf       	out	0x3d, r28	; 61
    373e:	cf 91       	pop	r28
    3740:	df 91       	pop	r29
    3742:	08 95       	ret

00003744 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3744:	df 93       	push	r29
    3746:	cf 93       	push	r28
    3748:	cd b7       	in	r28, 0x3d	; 61
    374a:	de b7       	in	r29, 0x3e	; 62
    374c:	28 97       	sbiw	r28, 0x08	; 8
    374e:	0f b6       	in	r0, 0x3f	; 63
    3750:	f8 94       	cli
    3752:	de bf       	out	0x3e, r29	; 62
    3754:	0f be       	out	0x3f, r0	; 63
    3756:	cd bf       	out	0x3d, r28	; 61
    3758:	9e 83       	std	Y+6, r25	; 0x06
    375a:	8d 83       	std	Y+5, r24	; 0x05
    375c:	78 87       	std	Y+8, r23	; 0x08
    375e:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3760:	ef 81       	ldd	r30, Y+7	; 0x07
    3762:	f8 85       	ldd	r31, Y+8	; 0x08
    3764:	80 81       	ld	r24, Z
    3766:	91 81       	ldd	r25, Z+1	; 0x01
    3768:	9a 83       	std	Y+2, r25	; 0x02
    376a:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    376c:	89 81       	ldd	r24, Y+1	; 0x01
    376e:	9a 81       	ldd	r25, Y+2	; 0x02
    3770:	2f ef       	ldi	r18, 0xFF	; 255
    3772:	8f 3f       	cpi	r24, 0xFF	; 255
    3774:	92 07       	cpc	r25, r18
    3776:	39 f4       	brne	.+14     	; 0x3786 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3778:	ed 81       	ldd	r30, Y+5	; 0x05
    377a:	fe 81       	ldd	r31, Y+6	; 0x06
    377c:	87 81       	ldd	r24, Z+7	; 0x07
    377e:	90 85       	ldd	r25, Z+8	; 0x08
    3780:	9c 83       	std	Y+4, r25	; 0x04
    3782:	8b 83       	std	Y+3, r24	; 0x03
    3784:	18 c0       	rjmp	.+48     	; 0x37b6 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3786:	8d 81       	ldd	r24, Y+5	; 0x05
    3788:	9e 81       	ldd	r25, Y+6	; 0x06
    378a:	03 96       	adiw	r24, 0x03	; 3
    378c:	9c 83       	std	Y+4, r25	; 0x04
    378e:	8b 83       	std	Y+3, r24	; 0x03
    3790:	06 c0       	rjmp	.+12     	; 0x379e <vListInsert+0x5a>
    3792:	eb 81       	ldd	r30, Y+3	; 0x03
    3794:	fc 81       	ldd	r31, Y+4	; 0x04
    3796:	82 81       	ldd	r24, Z+2	; 0x02
    3798:	93 81       	ldd	r25, Z+3	; 0x03
    379a:	9c 83       	std	Y+4, r25	; 0x04
    379c:	8b 83       	std	Y+3, r24	; 0x03
    379e:	eb 81       	ldd	r30, Y+3	; 0x03
    37a0:	fc 81       	ldd	r31, Y+4	; 0x04
    37a2:	02 80       	ldd	r0, Z+2	; 0x02
    37a4:	f3 81       	ldd	r31, Z+3	; 0x03
    37a6:	e0 2d       	mov	r30, r0
    37a8:	20 81       	ld	r18, Z
    37aa:	31 81       	ldd	r19, Z+1	; 0x01
    37ac:	89 81       	ldd	r24, Y+1	; 0x01
    37ae:	9a 81       	ldd	r25, Y+2	; 0x02
    37b0:	82 17       	cp	r24, r18
    37b2:	93 07       	cpc	r25, r19
    37b4:	70 f7       	brcc	.-36     	; 0x3792 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    37b6:	eb 81       	ldd	r30, Y+3	; 0x03
    37b8:	fc 81       	ldd	r31, Y+4	; 0x04
    37ba:	82 81       	ldd	r24, Z+2	; 0x02
    37bc:	93 81       	ldd	r25, Z+3	; 0x03
    37be:	ef 81       	ldd	r30, Y+7	; 0x07
    37c0:	f8 85       	ldd	r31, Y+8	; 0x08
    37c2:	93 83       	std	Z+3, r25	; 0x03
    37c4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    37c6:	ef 81       	ldd	r30, Y+7	; 0x07
    37c8:	f8 85       	ldd	r31, Y+8	; 0x08
    37ca:	02 80       	ldd	r0, Z+2	; 0x02
    37cc:	f3 81       	ldd	r31, Z+3	; 0x03
    37ce:	e0 2d       	mov	r30, r0
    37d0:	8f 81       	ldd	r24, Y+7	; 0x07
    37d2:	98 85       	ldd	r25, Y+8	; 0x08
    37d4:	95 83       	std	Z+5, r25	; 0x05
    37d6:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    37d8:	ef 81       	ldd	r30, Y+7	; 0x07
    37da:	f8 85       	ldd	r31, Y+8	; 0x08
    37dc:	8b 81       	ldd	r24, Y+3	; 0x03
    37de:	9c 81       	ldd	r25, Y+4	; 0x04
    37e0:	95 83       	std	Z+5, r25	; 0x05
    37e2:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    37e4:	eb 81       	ldd	r30, Y+3	; 0x03
    37e6:	fc 81       	ldd	r31, Y+4	; 0x04
    37e8:	8f 81       	ldd	r24, Y+7	; 0x07
    37ea:	98 85       	ldd	r25, Y+8	; 0x08
    37ec:	93 83       	std	Z+3, r25	; 0x03
    37ee:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    37f0:	ef 81       	ldd	r30, Y+7	; 0x07
    37f2:	f8 85       	ldd	r31, Y+8	; 0x08
    37f4:	8d 81       	ldd	r24, Y+5	; 0x05
    37f6:	9e 81       	ldd	r25, Y+6	; 0x06
    37f8:	91 87       	std	Z+9, r25	; 0x09
    37fa:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    37fc:	ed 81       	ldd	r30, Y+5	; 0x05
    37fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3800:	80 81       	ld	r24, Z
    3802:	8f 5f       	subi	r24, 0xFF	; 255
    3804:	ed 81       	ldd	r30, Y+5	; 0x05
    3806:	fe 81       	ldd	r31, Y+6	; 0x06
    3808:	80 83       	st	Z, r24
}
    380a:	28 96       	adiw	r28, 0x08	; 8
    380c:	0f b6       	in	r0, 0x3f	; 63
    380e:	f8 94       	cli
    3810:	de bf       	out	0x3e, r29	; 62
    3812:	0f be       	out	0x3f, r0	; 63
    3814:	cd bf       	out	0x3d, r28	; 61
    3816:	cf 91       	pop	r28
    3818:	df 91       	pop	r29
    381a:	08 95       	ret

0000381c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    381c:	df 93       	push	r29
    381e:	cf 93       	push	r28
    3820:	00 d0       	rcall	.+0      	; 0x3822 <uxListRemove+0x6>
    3822:	00 d0       	rcall	.+0      	; 0x3824 <uxListRemove+0x8>
    3824:	cd b7       	in	r28, 0x3d	; 61
    3826:	de b7       	in	r29, 0x3e	; 62
    3828:	9c 83       	std	Y+4, r25	; 0x04
    382a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    382c:	eb 81       	ldd	r30, Y+3	; 0x03
    382e:	fc 81       	ldd	r31, Y+4	; 0x04
    3830:	80 85       	ldd	r24, Z+8	; 0x08
    3832:	91 85       	ldd	r25, Z+9	; 0x09
    3834:	9a 83       	std	Y+2, r25	; 0x02
    3836:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3838:	eb 81       	ldd	r30, Y+3	; 0x03
    383a:	fc 81       	ldd	r31, Y+4	; 0x04
    383c:	a2 81       	ldd	r26, Z+2	; 0x02
    383e:	b3 81       	ldd	r27, Z+3	; 0x03
    3840:	eb 81       	ldd	r30, Y+3	; 0x03
    3842:	fc 81       	ldd	r31, Y+4	; 0x04
    3844:	84 81       	ldd	r24, Z+4	; 0x04
    3846:	95 81       	ldd	r25, Z+5	; 0x05
    3848:	15 96       	adiw	r26, 0x05	; 5
    384a:	9c 93       	st	X, r25
    384c:	8e 93       	st	-X, r24
    384e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3850:	eb 81       	ldd	r30, Y+3	; 0x03
    3852:	fc 81       	ldd	r31, Y+4	; 0x04
    3854:	a4 81       	ldd	r26, Z+4	; 0x04
    3856:	b5 81       	ldd	r27, Z+5	; 0x05
    3858:	eb 81       	ldd	r30, Y+3	; 0x03
    385a:	fc 81       	ldd	r31, Y+4	; 0x04
    385c:	82 81       	ldd	r24, Z+2	; 0x02
    385e:	93 81       	ldd	r25, Z+3	; 0x03
    3860:	13 96       	adiw	r26, 0x03	; 3
    3862:	9c 93       	st	X, r25
    3864:	8e 93       	st	-X, r24
    3866:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3868:	e9 81       	ldd	r30, Y+1	; 0x01
    386a:	fa 81       	ldd	r31, Y+2	; 0x02
    386c:	21 81       	ldd	r18, Z+1	; 0x01
    386e:	32 81       	ldd	r19, Z+2	; 0x02
    3870:	8b 81       	ldd	r24, Y+3	; 0x03
    3872:	9c 81       	ldd	r25, Y+4	; 0x04
    3874:	28 17       	cp	r18, r24
    3876:	39 07       	cpc	r19, r25
    3878:	41 f4       	brne	.+16     	; 0x388a <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    387a:	eb 81       	ldd	r30, Y+3	; 0x03
    387c:	fc 81       	ldd	r31, Y+4	; 0x04
    387e:	84 81       	ldd	r24, Z+4	; 0x04
    3880:	95 81       	ldd	r25, Z+5	; 0x05
    3882:	e9 81       	ldd	r30, Y+1	; 0x01
    3884:	fa 81       	ldd	r31, Y+2	; 0x02
    3886:	92 83       	std	Z+2, r25	; 0x02
    3888:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    388a:	eb 81       	ldd	r30, Y+3	; 0x03
    388c:	fc 81       	ldd	r31, Y+4	; 0x04
    388e:	11 86       	std	Z+9, r1	; 0x09
    3890:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3892:	e9 81       	ldd	r30, Y+1	; 0x01
    3894:	fa 81       	ldd	r31, Y+2	; 0x02
    3896:	80 81       	ld	r24, Z
    3898:	81 50       	subi	r24, 0x01	; 1
    389a:	e9 81       	ldd	r30, Y+1	; 0x01
    389c:	fa 81       	ldd	r31, Y+2	; 0x02
    389e:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    38a0:	e9 81       	ldd	r30, Y+1	; 0x01
    38a2:	fa 81       	ldd	r31, Y+2	; 0x02
    38a4:	80 81       	ld	r24, Z
}
    38a6:	0f 90       	pop	r0
    38a8:	0f 90       	pop	r0
    38aa:	0f 90       	pop	r0
    38ac:	0f 90       	pop	r0
    38ae:	cf 91       	pop	r28
    38b0:	df 91       	pop	r29
    38b2:	08 95       	ret

000038b4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    38b4:	df 93       	push	r29
    38b6:	cf 93       	push	r28
    38b8:	cd b7       	in	r28, 0x3d	; 61
    38ba:	de b7       	in	r29, 0x3e	; 62
    38bc:	28 97       	sbiw	r28, 0x08	; 8
    38be:	0f b6       	in	r0, 0x3f	; 63
    38c0:	f8 94       	cli
    38c2:	de bf       	out	0x3e, r29	; 62
    38c4:	0f be       	out	0x3f, r0	; 63
    38c6:	cd bf       	out	0x3d, r28	; 61
    38c8:	9c 83       	std	Y+4, r25	; 0x04
    38ca:	8b 83       	std	Y+3, r24	; 0x03
    38cc:	7e 83       	std	Y+6, r23	; 0x06
    38ce:	6d 83       	std	Y+5, r22	; 0x05
    38d0:	58 87       	std	Y+8, r21	; 0x08
    38d2:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    38d4:	eb 81       	ldd	r30, Y+3	; 0x03
    38d6:	fc 81       	ldd	r31, Y+4	; 0x04
    38d8:	81 e1       	ldi	r24, 0x11	; 17
    38da:	80 83       	st	Z, r24
	pxTopOfStack--;
    38dc:	8b 81       	ldd	r24, Y+3	; 0x03
    38de:	9c 81       	ldd	r25, Y+4	; 0x04
    38e0:	01 97       	sbiw	r24, 0x01	; 1
    38e2:	9c 83       	std	Y+4, r25	; 0x04
    38e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    38e6:	eb 81       	ldd	r30, Y+3	; 0x03
    38e8:	fc 81       	ldd	r31, Y+4	; 0x04
    38ea:	82 e2       	ldi	r24, 0x22	; 34
    38ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ee:	8b 81       	ldd	r24, Y+3	; 0x03
    38f0:	9c 81       	ldd	r25, Y+4	; 0x04
    38f2:	01 97       	sbiw	r24, 0x01	; 1
    38f4:	9c 83       	std	Y+4, r25	; 0x04
    38f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    38f8:	eb 81       	ldd	r30, Y+3	; 0x03
    38fa:	fc 81       	ldd	r31, Y+4	; 0x04
    38fc:	83 e3       	ldi	r24, 0x33	; 51
    38fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3900:	8b 81       	ldd	r24, Y+3	; 0x03
    3902:	9c 81       	ldd	r25, Y+4	; 0x04
    3904:	01 97       	sbiw	r24, 0x01	; 1
    3906:	9c 83       	std	Y+4, r25	; 0x04
    3908:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    390a:	8d 81       	ldd	r24, Y+5	; 0x05
    390c:	9e 81       	ldd	r25, Y+6	; 0x06
    390e:	9a 83       	std	Y+2, r25	; 0x02
    3910:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	eb 81       	ldd	r30, Y+3	; 0x03
    3916:	fc 81       	ldd	r31, Y+4	; 0x04
    3918:	80 83       	st	Z, r24
	pxTopOfStack--;
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	9c 81       	ldd	r25, Y+4	; 0x04
    391e:	01 97       	sbiw	r24, 0x01	; 1
    3920:	9c 83       	std	Y+4, r25	; 0x04
    3922:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3924:	89 81       	ldd	r24, Y+1	; 0x01
    3926:	9a 81       	ldd	r25, Y+2	; 0x02
    3928:	89 2f       	mov	r24, r25
    392a:	99 27       	eor	r25, r25
    392c:	9a 83       	std	Y+2, r25	; 0x02
    392e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3930:	89 81       	ldd	r24, Y+1	; 0x01
    3932:	eb 81       	ldd	r30, Y+3	; 0x03
    3934:	fc 81       	ldd	r31, Y+4	; 0x04
    3936:	80 83       	st	Z, r24
	pxTopOfStack--;
    3938:	8b 81       	ldd	r24, Y+3	; 0x03
    393a:	9c 81       	ldd	r25, Y+4	; 0x04
    393c:	01 97       	sbiw	r24, 0x01	; 1
    393e:	9c 83       	std	Y+4, r25	; 0x04
    3940:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3942:	eb 81       	ldd	r30, Y+3	; 0x03
    3944:	fc 81       	ldd	r31, Y+4	; 0x04
    3946:	10 82       	st	Z, r1
	pxTopOfStack--;
    3948:	8b 81       	ldd	r24, Y+3	; 0x03
    394a:	9c 81       	ldd	r25, Y+4	; 0x04
    394c:	01 97       	sbiw	r24, 0x01	; 1
    394e:	9c 83       	std	Y+4, r25	; 0x04
    3950:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3952:	eb 81       	ldd	r30, Y+3	; 0x03
    3954:	fc 81       	ldd	r31, Y+4	; 0x04
    3956:	80 e8       	ldi	r24, 0x80	; 128
    3958:	80 83       	st	Z, r24
	pxTopOfStack--;
    395a:	8b 81       	ldd	r24, Y+3	; 0x03
    395c:	9c 81       	ldd	r25, Y+4	; 0x04
    395e:	01 97       	sbiw	r24, 0x01	; 1
    3960:	9c 83       	std	Y+4, r25	; 0x04
    3962:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3964:	eb 81       	ldd	r30, Y+3	; 0x03
    3966:	fc 81       	ldd	r31, Y+4	; 0x04
    3968:	10 82       	st	Z, r1
	pxTopOfStack--;
    396a:	8b 81       	ldd	r24, Y+3	; 0x03
    396c:	9c 81       	ldd	r25, Y+4	; 0x04
    396e:	01 97       	sbiw	r24, 0x01	; 1
    3970:	9c 83       	std	Y+4, r25	; 0x04
    3972:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3974:	eb 81       	ldd	r30, Y+3	; 0x03
    3976:	fc 81       	ldd	r31, Y+4	; 0x04
    3978:	82 e0       	ldi	r24, 0x02	; 2
    397a:	80 83       	st	Z, r24
	pxTopOfStack--;
    397c:	8b 81       	ldd	r24, Y+3	; 0x03
    397e:	9c 81       	ldd	r25, Y+4	; 0x04
    3980:	01 97       	sbiw	r24, 0x01	; 1
    3982:	9c 83       	std	Y+4, r25	; 0x04
    3984:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3986:	eb 81       	ldd	r30, Y+3	; 0x03
    3988:	fc 81       	ldd	r31, Y+4	; 0x04
    398a:	83 e0       	ldi	r24, 0x03	; 3
    398c:	80 83       	st	Z, r24
	pxTopOfStack--;
    398e:	8b 81       	ldd	r24, Y+3	; 0x03
    3990:	9c 81       	ldd	r25, Y+4	; 0x04
    3992:	01 97       	sbiw	r24, 0x01	; 1
    3994:	9c 83       	std	Y+4, r25	; 0x04
    3996:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3998:	eb 81       	ldd	r30, Y+3	; 0x03
    399a:	fc 81       	ldd	r31, Y+4	; 0x04
    399c:	84 e0       	ldi	r24, 0x04	; 4
    399e:	80 83       	st	Z, r24
	pxTopOfStack--;
    39a0:	8b 81       	ldd	r24, Y+3	; 0x03
    39a2:	9c 81       	ldd	r25, Y+4	; 0x04
    39a4:	01 97       	sbiw	r24, 0x01	; 1
    39a6:	9c 83       	std	Y+4, r25	; 0x04
    39a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    39aa:	eb 81       	ldd	r30, Y+3	; 0x03
    39ac:	fc 81       	ldd	r31, Y+4	; 0x04
    39ae:	85 e0       	ldi	r24, 0x05	; 5
    39b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    39b2:	8b 81       	ldd	r24, Y+3	; 0x03
    39b4:	9c 81       	ldd	r25, Y+4	; 0x04
    39b6:	01 97       	sbiw	r24, 0x01	; 1
    39b8:	9c 83       	std	Y+4, r25	; 0x04
    39ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    39bc:	eb 81       	ldd	r30, Y+3	; 0x03
    39be:	fc 81       	ldd	r31, Y+4	; 0x04
    39c0:	86 e0       	ldi	r24, 0x06	; 6
    39c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    39c4:	8b 81       	ldd	r24, Y+3	; 0x03
    39c6:	9c 81       	ldd	r25, Y+4	; 0x04
    39c8:	01 97       	sbiw	r24, 0x01	; 1
    39ca:	9c 83       	std	Y+4, r25	; 0x04
    39cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    39ce:	eb 81       	ldd	r30, Y+3	; 0x03
    39d0:	fc 81       	ldd	r31, Y+4	; 0x04
    39d2:	87 e0       	ldi	r24, 0x07	; 7
    39d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    39d6:	8b 81       	ldd	r24, Y+3	; 0x03
    39d8:	9c 81       	ldd	r25, Y+4	; 0x04
    39da:	01 97       	sbiw	r24, 0x01	; 1
    39dc:	9c 83       	std	Y+4, r25	; 0x04
    39de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    39e0:	eb 81       	ldd	r30, Y+3	; 0x03
    39e2:	fc 81       	ldd	r31, Y+4	; 0x04
    39e4:	88 e0       	ldi	r24, 0x08	; 8
    39e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ea:	9c 81       	ldd	r25, Y+4	; 0x04
    39ec:	01 97       	sbiw	r24, 0x01	; 1
    39ee:	9c 83       	std	Y+4, r25	; 0x04
    39f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    39f2:	eb 81       	ldd	r30, Y+3	; 0x03
    39f4:	fc 81       	ldd	r31, Y+4	; 0x04
    39f6:	89 e0       	ldi	r24, 0x09	; 9
    39f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	01 97       	sbiw	r24, 0x01	; 1
    3a00:	9c 83       	std	Y+4, r25	; 0x04
    3a02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3a04:	eb 81       	ldd	r30, Y+3	; 0x03
    3a06:	fc 81       	ldd	r31, Y+4	; 0x04
    3a08:	80 e1       	ldi	r24, 0x10	; 16
    3a0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a10:	01 97       	sbiw	r24, 0x01	; 1
    3a12:	9c 83       	std	Y+4, r25	; 0x04
    3a14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3a16:	eb 81       	ldd	r30, Y+3	; 0x03
    3a18:	fc 81       	ldd	r31, Y+4	; 0x04
    3a1a:	81 e1       	ldi	r24, 0x11	; 17
    3a1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a20:	9c 81       	ldd	r25, Y+4	; 0x04
    3a22:	01 97       	sbiw	r24, 0x01	; 1
    3a24:	9c 83       	std	Y+4, r25	; 0x04
    3a26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3a28:	eb 81       	ldd	r30, Y+3	; 0x03
    3a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a2c:	82 e1       	ldi	r24, 0x12	; 18
    3a2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a30:	8b 81       	ldd	r24, Y+3	; 0x03
    3a32:	9c 81       	ldd	r25, Y+4	; 0x04
    3a34:	01 97       	sbiw	r24, 0x01	; 1
    3a36:	9c 83       	std	Y+4, r25	; 0x04
    3a38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a3e:	83 e1       	ldi	r24, 0x13	; 19
    3a40:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a42:	8b 81       	ldd	r24, Y+3	; 0x03
    3a44:	9c 81       	ldd	r25, Y+4	; 0x04
    3a46:	01 97       	sbiw	r24, 0x01	; 1
    3a48:	9c 83       	std	Y+4, r25	; 0x04
    3a4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a50:	84 e1       	ldi	r24, 0x14	; 20
    3a52:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a54:	8b 81       	ldd	r24, Y+3	; 0x03
    3a56:	9c 81       	ldd	r25, Y+4	; 0x04
    3a58:	01 97       	sbiw	r24, 0x01	; 1
    3a5a:	9c 83       	std	Y+4, r25	; 0x04
    3a5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3a5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a60:	fc 81       	ldd	r31, Y+4	; 0x04
    3a62:	85 e1       	ldi	r24, 0x15	; 21
    3a64:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a66:	8b 81       	ldd	r24, Y+3	; 0x03
    3a68:	9c 81       	ldd	r25, Y+4	; 0x04
    3a6a:	01 97       	sbiw	r24, 0x01	; 1
    3a6c:	9c 83       	std	Y+4, r25	; 0x04
    3a6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3a70:	eb 81       	ldd	r30, Y+3	; 0x03
    3a72:	fc 81       	ldd	r31, Y+4	; 0x04
    3a74:	86 e1       	ldi	r24, 0x16	; 22
    3a76:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a78:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a7c:	01 97       	sbiw	r24, 0x01	; 1
    3a7e:	9c 83       	std	Y+4, r25	; 0x04
    3a80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3a82:	eb 81       	ldd	r30, Y+3	; 0x03
    3a84:	fc 81       	ldd	r31, Y+4	; 0x04
    3a86:	87 e1       	ldi	r24, 0x17	; 23
    3a88:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a8e:	01 97       	sbiw	r24, 0x01	; 1
    3a90:	9c 83       	std	Y+4, r25	; 0x04
    3a92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3a94:	eb 81       	ldd	r30, Y+3	; 0x03
    3a96:	fc 81       	ldd	r31, Y+4	; 0x04
    3a98:	88 e1       	ldi	r24, 0x18	; 24
    3a9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3aa0:	01 97       	sbiw	r24, 0x01	; 1
    3aa2:	9c 83       	std	Y+4, r25	; 0x04
    3aa4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    3aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    3aaa:	89 e1       	ldi	r24, 0x19	; 25
    3aac:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aae:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ab2:	01 97       	sbiw	r24, 0x01	; 1
    3ab4:	9c 83       	std	Y+4, r25	; 0x04
    3ab6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    3aba:	fc 81       	ldd	r31, Y+4	; 0x04
    3abc:	80 e2       	ldi	r24, 0x20	; 32
    3abe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ac4:	01 97       	sbiw	r24, 0x01	; 1
    3ac6:	9c 83       	std	Y+4, r25	; 0x04
    3ac8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3aca:	eb 81       	ldd	r30, Y+3	; 0x03
    3acc:	fc 81       	ldd	r31, Y+4	; 0x04
    3ace:	81 e2       	ldi	r24, 0x21	; 33
    3ad0:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad6:	01 97       	sbiw	r24, 0x01	; 1
    3ad8:	9c 83       	std	Y+4, r25	; 0x04
    3ada:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3adc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ade:	fc 81       	ldd	r31, Y+4	; 0x04
    3ae0:	82 e2       	ldi	r24, 0x22	; 34
    3ae2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae8:	01 97       	sbiw	r24, 0x01	; 1
    3aea:	9c 83       	std	Y+4, r25	; 0x04
    3aec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3aee:	eb 81       	ldd	r30, Y+3	; 0x03
    3af0:	fc 81       	ldd	r31, Y+4	; 0x04
    3af2:	83 e2       	ldi	r24, 0x23	; 35
    3af4:	80 83       	st	Z, r24
	pxTopOfStack--;
    3af6:	8b 81       	ldd	r24, Y+3	; 0x03
    3af8:	9c 81       	ldd	r25, Y+4	; 0x04
    3afa:	01 97       	sbiw	r24, 0x01	; 1
    3afc:	9c 83       	std	Y+4, r25	; 0x04
    3afe:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    3b00:	8f 81       	ldd	r24, Y+7	; 0x07
    3b02:	98 85       	ldd	r25, Y+8	; 0x08
    3b04:	9a 83       	std	Y+2, r25	; 0x02
    3b06:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b08:	89 81       	ldd	r24, Y+1	; 0x01
    3b0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b10:	8b 81       	ldd	r24, Y+3	; 0x03
    3b12:	9c 81       	ldd	r25, Y+4	; 0x04
    3b14:	01 97       	sbiw	r24, 0x01	; 1
    3b16:	9c 83       	std	Y+4, r25	; 0x04
    3b18:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3b1a:	89 81       	ldd	r24, Y+1	; 0x01
    3b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1e:	89 2f       	mov	r24, r25
    3b20:	99 27       	eor	r25, r25
    3b22:	9a 83       	std	Y+2, r25	; 0x02
    3b24:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b26:	89 81       	ldd	r24, Y+1	; 0x01
    3b28:	eb 81       	ldd	r30, Y+3	; 0x03
    3b2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b2c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b30:	9c 81       	ldd	r25, Y+4	; 0x04
    3b32:	01 97       	sbiw	r24, 0x01	; 1
    3b34:	9c 83       	std	Y+4, r25	; 0x04
    3b36:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3b38:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3c:	86 e2       	ldi	r24, 0x26	; 38
    3b3e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b40:	8b 81       	ldd	r24, Y+3	; 0x03
    3b42:	9c 81       	ldd	r25, Y+4	; 0x04
    3b44:	01 97       	sbiw	r24, 0x01	; 1
    3b46:	9c 83       	std	Y+4, r25	; 0x04
    3b48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4e:	87 e2       	ldi	r24, 0x27	; 39
    3b50:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b52:	8b 81       	ldd	r24, Y+3	; 0x03
    3b54:	9c 81       	ldd	r25, Y+4	; 0x04
    3b56:	01 97       	sbiw	r24, 0x01	; 1
    3b58:	9c 83       	std	Y+4, r25	; 0x04
    3b5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b60:	88 e2       	ldi	r24, 0x28	; 40
    3b62:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b64:	8b 81       	ldd	r24, Y+3	; 0x03
    3b66:	9c 81       	ldd	r25, Y+4	; 0x04
    3b68:	01 97       	sbiw	r24, 0x01	; 1
    3b6a:	9c 83       	std	Y+4, r25	; 0x04
    3b6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3b6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b70:	fc 81       	ldd	r31, Y+4	; 0x04
    3b72:	89 e2       	ldi	r24, 0x29	; 41
    3b74:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b76:	8b 81       	ldd	r24, Y+3	; 0x03
    3b78:	9c 81       	ldd	r25, Y+4	; 0x04
    3b7a:	01 97       	sbiw	r24, 0x01	; 1
    3b7c:	9c 83       	std	Y+4, r25	; 0x04
    3b7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3b80:	eb 81       	ldd	r30, Y+3	; 0x03
    3b82:	fc 81       	ldd	r31, Y+4	; 0x04
    3b84:	80 e3       	ldi	r24, 0x30	; 48
    3b86:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b88:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b8c:	01 97       	sbiw	r24, 0x01	; 1
    3b8e:	9c 83       	std	Y+4, r25	; 0x04
    3b90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3b92:	eb 81       	ldd	r30, Y+3	; 0x03
    3b94:	fc 81       	ldd	r31, Y+4	; 0x04
    3b96:	81 e3       	ldi	r24, 0x31	; 49
    3b98:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b9e:	01 97       	sbiw	r24, 0x01	; 1
    3ba0:	9c 83       	std	Y+4, r25	; 0x04
    3ba2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3ba8:	28 96       	adiw	r28, 0x08	; 8
    3baa:	0f b6       	in	r0, 0x3f	; 63
    3bac:	f8 94       	cli
    3bae:	de bf       	out	0x3e, r29	; 62
    3bb0:	0f be       	out	0x3f, r0	; 63
    3bb2:	cd bf       	out	0x3d, r28	; 61
    3bb4:	cf 91       	pop	r28
    3bb6:	df 91       	pop	r29
    3bb8:	08 95       	ret

00003bba <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3bba:	df 93       	push	r29
    3bbc:	cf 93       	push	r28
    3bbe:	cd b7       	in	r28, 0x3d	; 61
    3bc0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3bc2:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3bc6:	a0 91 68 06 	lds	r26, 0x0668
    3bca:	b0 91 69 06 	lds	r27, 0x0669
    3bce:	cd 91       	ld	r28, X+
    3bd0:	cd bf       	out	0x3d, r28	; 61
    3bd2:	dd 91       	ld	r29, X+
    3bd4:	de bf       	out	0x3e, r29	; 62
    3bd6:	ff 91       	pop	r31
    3bd8:	ef 91       	pop	r30
    3bda:	df 91       	pop	r29
    3bdc:	cf 91       	pop	r28
    3bde:	bf 91       	pop	r27
    3be0:	af 91       	pop	r26
    3be2:	9f 91       	pop	r25
    3be4:	8f 91       	pop	r24
    3be6:	7f 91       	pop	r23
    3be8:	6f 91       	pop	r22
    3bea:	5f 91       	pop	r21
    3bec:	4f 91       	pop	r20
    3bee:	3f 91       	pop	r19
    3bf0:	2f 91       	pop	r18
    3bf2:	1f 91       	pop	r17
    3bf4:	0f 91       	pop	r16
    3bf6:	ff 90       	pop	r15
    3bf8:	ef 90       	pop	r14
    3bfa:	df 90       	pop	r13
    3bfc:	cf 90       	pop	r12
    3bfe:	bf 90       	pop	r11
    3c00:	af 90       	pop	r10
    3c02:	9f 90       	pop	r9
    3c04:	8f 90       	pop	r8
    3c06:	7f 90       	pop	r7
    3c08:	6f 90       	pop	r6
    3c0a:	5f 90       	pop	r5
    3c0c:	4f 90       	pop	r4
    3c0e:	3f 90       	pop	r3
    3c10:	2f 90       	pop	r2
    3c12:	1f 90       	pop	r1
    3c14:	0f 90       	pop	r0
    3c16:	0f be       	out	0x3f, r0	; 63
    3c18:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3c1a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3c1c:	81 e0       	ldi	r24, 0x01	; 1
}
    3c1e:	cf 91       	pop	r28
    3c20:	df 91       	pop	r29
    3c22:	08 95       	ret

00003c24 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3c24:	df 93       	push	r29
    3c26:	cf 93       	push	r28
    3c28:	cd b7       	in	r28, 0x3d	; 61
    3c2a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3c32:	0f 92       	push	r0
    3c34:	0f b6       	in	r0, 0x3f	; 63
    3c36:	f8 94       	cli
    3c38:	0f 92       	push	r0
    3c3a:	1f 92       	push	r1
    3c3c:	11 24       	eor	r1, r1
    3c3e:	2f 92       	push	r2
    3c40:	3f 92       	push	r3
    3c42:	4f 92       	push	r4
    3c44:	5f 92       	push	r5
    3c46:	6f 92       	push	r6
    3c48:	7f 92       	push	r7
    3c4a:	8f 92       	push	r8
    3c4c:	9f 92       	push	r9
    3c4e:	af 92       	push	r10
    3c50:	bf 92       	push	r11
    3c52:	cf 92       	push	r12
    3c54:	df 92       	push	r13
    3c56:	ef 92       	push	r14
    3c58:	ff 92       	push	r15
    3c5a:	0f 93       	push	r16
    3c5c:	1f 93       	push	r17
    3c5e:	2f 93       	push	r18
    3c60:	3f 93       	push	r19
    3c62:	4f 93       	push	r20
    3c64:	5f 93       	push	r21
    3c66:	6f 93       	push	r22
    3c68:	7f 93       	push	r23
    3c6a:	8f 93       	push	r24
    3c6c:	9f 93       	push	r25
    3c6e:	af 93       	push	r26
    3c70:	bf 93       	push	r27
    3c72:	cf 93       	push	r28
    3c74:	df 93       	push	r29
    3c76:	ef 93       	push	r30
    3c78:	ff 93       	push	r31
    3c7a:	a0 91 68 06 	lds	r26, 0x0668
    3c7e:	b0 91 69 06 	lds	r27, 0x0669
    3c82:	0d b6       	in	r0, 0x3d	; 61
    3c84:	0d 92       	st	X+, r0
    3c86:	0e b6       	in	r0, 0x3e	; 62
    3c88:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3c8a:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3c8e:	a0 91 68 06 	lds	r26, 0x0668
    3c92:	b0 91 69 06 	lds	r27, 0x0669
    3c96:	cd 91       	ld	r28, X+
    3c98:	cd bf       	out	0x3d, r28	; 61
    3c9a:	dd 91       	ld	r29, X+
    3c9c:	de bf       	out	0x3e, r29	; 62
    3c9e:	ff 91       	pop	r31
    3ca0:	ef 91       	pop	r30
    3ca2:	df 91       	pop	r29
    3ca4:	cf 91       	pop	r28
    3ca6:	bf 91       	pop	r27
    3ca8:	af 91       	pop	r26
    3caa:	9f 91       	pop	r25
    3cac:	8f 91       	pop	r24
    3cae:	7f 91       	pop	r23
    3cb0:	6f 91       	pop	r22
    3cb2:	5f 91       	pop	r21
    3cb4:	4f 91       	pop	r20
    3cb6:	3f 91       	pop	r19
    3cb8:	2f 91       	pop	r18
    3cba:	1f 91       	pop	r17
    3cbc:	0f 91       	pop	r16
    3cbe:	ff 90       	pop	r15
    3cc0:	ef 90       	pop	r14
    3cc2:	df 90       	pop	r13
    3cc4:	cf 90       	pop	r12
    3cc6:	bf 90       	pop	r11
    3cc8:	af 90       	pop	r10
    3cca:	9f 90       	pop	r9
    3ccc:	8f 90       	pop	r8
    3cce:	7f 90       	pop	r7
    3cd0:	6f 90       	pop	r6
    3cd2:	5f 90       	pop	r5
    3cd4:	4f 90       	pop	r4
    3cd6:	3f 90       	pop	r3
    3cd8:	2f 90       	pop	r2
    3cda:	1f 90       	pop	r1
    3cdc:	0f 90       	pop	r0
    3cde:	0f be       	out	0x3f, r0	; 63
    3ce0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3ce2:	08 95       	ret

00003ce4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3ce4:	0f 92       	push	r0
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	0f 92       	push	r0
    3cec:	1f 92       	push	r1
    3cee:	11 24       	eor	r1, r1
    3cf0:	2f 92       	push	r2
    3cf2:	3f 92       	push	r3
    3cf4:	4f 92       	push	r4
    3cf6:	5f 92       	push	r5
    3cf8:	6f 92       	push	r6
    3cfa:	7f 92       	push	r7
    3cfc:	8f 92       	push	r8
    3cfe:	9f 92       	push	r9
    3d00:	af 92       	push	r10
    3d02:	bf 92       	push	r11
    3d04:	cf 92       	push	r12
    3d06:	df 92       	push	r13
    3d08:	ef 92       	push	r14
    3d0a:	ff 92       	push	r15
    3d0c:	0f 93       	push	r16
    3d0e:	1f 93       	push	r17
    3d10:	2f 93       	push	r18
    3d12:	3f 93       	push	r19
    3d14:	4f 93       	push	r20
    3d16:	5f 93       	push	r21
    3d18:	6f 93       	push	r22
    3d1a:	7f 93       	push	r23
    3d1c:	8f 93       	push	r24
    3d1e:	9f 93       	push	r25
    3d20:	af 93       	push	r26
    3d22:	bf 93       	push	r27
    3d24:	cf 93       	push	r28
    3d26:	df 93       	push	r29
    3d28:	ef 93       	push	r30
    3d2a:	ff 93       	push	r31
    3d2c:	a0 91 68 06 	lds	r26, 0x0668
    3d30:	b0 91 69 06 	lds	r27, 0x0669
    3d34:	0d b6       	in	r0, 0x3d	; 61
    3d36:	0d 92       	st	X+, r0
    3d38:	0e b6       	in	r0, 0x3e	; 62
    3d3a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3d3c:	0e 94 39 2c 	call	0x5872	; 0x5872 <xTaskIncrementTick>
    3d40:	88 23       	and	r24, r24
    3d42:	11 f0       	breq	.+4      	; 0x3d48 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3d44:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3d48:	a0 91 68 06 	lds	r26, 0x0668
    3d4c:	b0 91 69 06 	lds	r27, 0x0669
    3d50:	cd 91       	ld	r28, X+
    3d52:	cd bf       	out	0x3d, r28	; 61
    3d54:	dd 91       	ld	r29, X+
    3d56:	de bf       	out	0x3e, r29	; 62
    3d58:	ff 91       	pop	r31
    3d5a:	ef 91       	pop	r30
    3d5c:	df 91       	pop	r29
    3d5e:	cf 91       	pop	r28
    3d60:	bf 91       	pop	r27
    3d62:	af 91       	pop	r26
    3d64:	9f 91       	pop	r25
    3d66:	8f 91       	pop	r24
    3d68:	7f 91       	pop	r23
    3d6a:	6f 91       	pop	r22
    3d6c:	5f 91       	pop	r21
    3d6e:	4f 91       	pop	r20
    3d70:	3f 91       	pop	r19
    3d72:	2f 91       	pop	r18
    3d74:	1f 91       	pop	r17
    3d76:	0f 91       	pop	r16
    3d78:	ff 90       	pop	r15
    3d7a:	ef 90       	pop	r14
    3d7c:	df 90       	pop	r13
    3d7e:	cf 90       	pop	r12
    3d80:	bf 90       	pop	r11
    3d82:	af 90       	pop	r10
    3d84:	9f 90       	pop	r9
    3d86:	8f 90       	pop	r8
    3d88:	7f 90       	pop	r7
    3d8a:	6f 90       	pop	r6
    3d8c:	5f 90       	pop	r5
    3d8e:	4f 90       	pop	r4
    3d90:	3f 90       	pop	r3
    3d92:	2f 90       	pop	r2
    3d94:	1f 90       	pop	r1
    3d96:	0f 90       	pop	r0
    3d98:	0f be       	out	0x3f, r0	; 63
    3d9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3d9c:	08 95       	ret

00003d9e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3d9e:	df 93       	push	r29
    3da0:	cf 93       	push	r28
    3da2:	00 d0       	rcall	.+0      	; 0x3da4 <prvSetupTimerInterrupt+0x6>
    3da4:	00 d0       	rcall	.+0      	; 0x3da6 <prvSetupTimerInterrupt+0x8>
    3da6:	00 d0       	rcall	.+0      	; 0x3da8 <prvSetupTimerInterrupt+0xa>
    3da8:	cd b7       	in	r28, 0x3d	; 61
    3daa:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3dac:	80 e4       	ldi	r24, 0x40	; 64
    3dae:	9f e1       	ldi	r25, 0x1F	; 31
    3db0:	a0 e0       	ldi	r26, 0x00	; 0
    3db2:	b0 e0       	ldi	r27, 0x00	; 0
    3db4:	8b 83       	std	Y+3, r24	; 0x03
    3db6:	9c 83       	std	Y+4, r25	; 0x04
    3db8:	ad 83       	std	Y+5, r26	; 0x05
    3dba:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3dc0:	ad 81       	ldd	r26, Y+5	; 0x05
    3dc2:	be 81       	ldd	r27, Y+6	; 0x06
    3dc4:	68 94       	set
    3dc6:	15 f8       	bld	r1, 5
    3dc8:	b6 95       	lsr	r27
    3dca:	a7 95       	ror	r26
    3dcc:	97 95       	ror	r25
    3dce:	87 95       	ror	r24
    3dd0:	16 94       	lsr	r1
    3dd2:	d1 f7       	brne	.-12     	; 0x3dc8 <prvSetupTimerInterrupt+0x2a>
    3dd4:	8b 83       	std	Y+3, r24	; 0x03
    3dd6:	9c 83       	std	Y+4, r25	; 0x04
    3dd8:	ad 83       	std	Y+5, r26	; 0x05
    3dda:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dde:	9c 81       	ldd	r25, Y+4	; 0x04
    3de0:	ad 81       	ldd	r26, Y+5	; 0x05
    3de2:	be 81       	ldd	r27, Y+6	; 0x06
    3de4:	01 97       	sbiw	r24, 0x01	; 1
    3de6:	a1 09       	sbc	r26, r1
    3de8:	b1 09       	sbc	r27, r1
    3dea:	8b 83       	std	Y+3, r24	; 0x03
    3dec:	9c 83       	std	Y+4, r25	; 0x04
    3dee:	ad 83       	std	Y+5, r26	; 0x05
    3df0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3df2:	8b 81       	ldd	r24, Y+3	; 0x03
    3df4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3df6:	8b 81       	ldd	r24, Y+3	; 0x03
    3df8:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfa:	ad 81       	ldd	r26, Y+5	; 0x05
    3dfc:	be 81       	ldd	r27, Y+6	; 0x06
    3dfe:	89 2f       	mov	r24, r25
    3e00:	9a 2f       	mov	r25, r26
    3e02:	ab 2f       	mov	r26, r27
    3e04:	bb 27       	eor	r27, r27
    3e06:	8b 83       	std	Y+3, r24	; 0x03
    3e08:	9c 83       	std	Y+4, r25	; 0x04
    3e0a:	ad 83       	std	Y+5, r26	; 0x05
    3e0c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e10:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3e12:	eb e4       	ldi	r30, 0x4B	; 75
    3e14:	f0 e0       	ldi	r31, 0x00	; 0
    3e16:	8a 81       	ldd	r24, Y+2	; 0x02
    3e18:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3e1a:	ea e4       	ldi	r30, 0x4A	; 74
    3e1c:	f0 e0       	ldi	r31, 0x00	; 0
    3e1e:	89 81       	ldd	r24, Y+1	; 0x01
    3e20:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3e22:	8b e0       	ldi	r24, 0x0B	; 11
    3e24:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3e26:	ee e4       	ldi	r30, 0x4E	; 78
    3e28:	f0 e0       	ldi	r31, 0x00	; 0
    3e2a:	89 81       	ldd	r24, Y+1	; 0x01
    3e2c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3e2e:	e9 e5       	ldi	r30, 0x59	; 89
    3e30:	f0 e0       	ldi	r31, 0x00	; 0
    3e32:	80 81       	ld	r24, Z
    3e34:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3e36:	89 81       	ldd	r24, Y+1	; 0x01
    3e38:	80 61       	ori	r24, 0x10	; 16
    3e3a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3e3c:	e9 e5       	ldi	r30, 0x59	; 89
    3e3e:	f0 e0       	ldi	r31, 0x00	; 0
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	80 83       	st	Z, r24
}
    3e44:	26 96       	adiw	r28, 0x06	; 6
    3e46:	0f b6       	in	r0, 0x3f	; 63
    3e48:	f8 94       	cli
    3e4a:	de bf       	out	0x3e, r29	; 62
    3e4c:	0f be       	out	0x3f, r0	; 63
    3e4e:	cd bf       	out	0x3d, r28	; 61
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3e56:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3e5a:	18 95       	reti

00003e5c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3e5c:	df 93       	push	r29
    3e5e:	cf 93       	push	r28
    3e60:	00 d0       	rcall	.+0      	; 0x3e62 <xQueueGenericReset+0x6>
    3e62:	00 d0       	rcall	.+0      	; 0x3e64 <xQueueGenericReset+0x8>
    3e64:	0f 92       	push	r0
    3e66:	cd b7       	in	r28, 0x3d	; 61
    3e68:	de b7       	in	r29, 0x3e	; 62
    3e6a:	9c 83       	std	Y+4, r25	; 0x04
    3e6c:	8b 83       	std	Y+3, r24	; 0x03
    3e6e:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3e70:	8b 81       	ldd	r24, Y+3	; 0x03
    3e72:	9c 81       	ldd	r25, Y+4	; 0x04
    3e74:	9a 83       	std	Y+2, r25	; 0x02
    3e76:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3e78:	0f b6       	in	r0, 0x3f	; 63
    3e7a:	f8 94       	cli
    3e7c:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e80:	fa 81       	ldd	r31, Y+2	; 0x02
    3e82:	40 81       	ld	r20, Z
    3e84:	51 81       	ldd	r21, Z+1	; 0x01
    3e86:	e9 81       	ldd	r30, Y+1	; 0x01
    3e88:	fa 81       	ldd	r31, Y+2	; 0x02
    3e8a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3e8c:	28 2f       	mov	r18, r24
    3e8e:	30 e0       	ldi	r19, 0x00	; 0
    3e90:	e9 81       	ldd	r30, Y+1	; 0x01
    3e92:	fa 81       	ldd	r31, Y+2	; 0x02
    3e94:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e96:	88 2f       	mov	r24, r24
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	bc 01       	movw	r22, r24
    3e9c:	26 9f       	mul	r18, r22
    3e9e:	c0 01       	movw	r24, r0
    3ea0:	27 9f       	mul	r18, r23
    3ea2:	90 0d       	add	r25, r0
    3ea4:	36 9f       	mul	r19, r22
    3ea6:	90 0d       	add	r25, r0
    3ea8:	11 24       	eor	r1, r1
    3eaa:	84 0f       	add	r24, r20
    3eac:	95 1f       	adc	r25, r21
    3eae:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb2:	93 83       	std	Z+3, r25	; 0x03
    3eb4:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eba:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec0:	80 81       	ld	r24, Z
    3ec2:	91 81       	ldd	r25, Z+1	; 0x01
    3ec4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ec6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec8:	95 83       	std	Z+5, r25	; 0x05
    3eca:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    3ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ece:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed0:	40 81       	ld	r20, Z
    3ed2:	51 81       	ldd	r21, Z+1	; 0x01
    3ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3eda:	88 2f       	mov	r24, r24
    3edc:	90 e0       	ldi	r25, 0x00	; 0
    3ede:	9c 01       	movw	r18, r24
    3ee0:	21 50       	subi	r18, 0x01	; 1
    3ee2:	30 40       	sbci	r19, 0x00	; 0
    3ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3eea:	88 2f       	mov	r24, r24
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	bc 01       	movw	r22, r24
    3ef0:	26 9f       	mul	r18, r22
    3ef2:	c0 01       	movw	r24, r0
    3ef4:	27 9f       	mul	r18, r23
    3ef6:	90 0d       	add	r25, r0
    3ef8:	36 9f       	mul	r19, r22
    3efa:	90 0d       	add	r25, r0
    3efc:	11 24       	eor	r1, r1
    3efe:	84 0f       	add	r24, r20
    3f00:	95 1f       	adc	r25, r21
    3f02:	e9 81       	ldd	r30, Y+1	; 0x01
    3f04:	fa 81       	ldd	r31, Y+2	; 0x02
    3f06:	97 83       	std	Z+7, r25	; 0x07
    3f08:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    3f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f0e:	8f ef       	ldi	r24, 0xFF	; 255
    3f10:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    3f12:	e9 81       	ldd	r30, Y+1	; 0x01
    3f14:	fa 81       	ldd	r31, Y+2	; 0x02
    3f16:	8f ef       	ldi	r24, 0xFF	; 255
    3f18:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3f1a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f1c:	88 23       	and	r24, r24
    3f1e:	79 f4       	brne	.+30     	; 0x3f3e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f20:	e9 81       	ldd	r30, Y+1	; 0x01
    3f22:	fa 81       	ldd	r31, Y+2	; 0x02
    3f24:	80 85       	ldd	r24, Z+8	; 0x08
    3f26:	88 23       	and	r24, r24
    3f28:	a1 f0       	breq	.+40     	; 0x3f52 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3f2a:	89 81       	ldd	r24, Y+1	; 0x01
    3f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2e:	08 96       	adiw	r24, 0x08	; 8
    3f30:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    3f34:	81 30       	cpi	r24, 0x01	; 1
    3f36:	69 f4       	brne	.+26     	; 0x3f52 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3f38:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    3f3c:	0a c0       	rjmp	.+20     	; 0x3f52 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3f3e:	89 81       	ldd	r24, Y+1	; 0x01
    3f40:	9a 81       	ldd	r25, Y+2	; 0x02
    3f42:	08 96       	adiw	r24, 0x08	; 8
    3f44:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3f48:	89 81       	ldd	r24, Y+1	; 0x01
    3f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f4c:	41 96       	adiw	r24, 0x11	; 17
    3f4e:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3f52:	0f 90       	pop	r0
    3f54:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3f56:	81 e0       	ldi	r24, 0x01	; 1
}
    3f58:	0f 90       	pop	r0
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	0f 90       	pop	r0
    3f62:	cf 91       	pop	r28
    3f64:	df 91       	pop	r29
    3f66:	08 95       	ret

00003f68 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    3f68:	df 93       	push	r29
    3f6a:	cf 93       	push	r28
    3f6c:	cd b7       	in	r28, 0x3d	; 61
    3f6e:	de b7       	in	r29, 0x3e	; 62
    3f70:	29 97       	sbiw	r28, 0x09	; 9
    3f72:	0f b6       	in	r0, 0x3f	; 63
    3f74:	f8 94       	cli
    3f76:	de bf       	out	0x3e, r29	; 62
    3f78:	0f be       	out	0x3f, r0	; 63
    3f7a:	cd bf       	out	0x3d, r28	; 61
    3f7c:	8f 83       	std	Y+7, r24	; 0x07
    3f7e:	68 87       	std	Y+8, r22	; 0x08
    3f80:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    3f82:	1a 82       	std	Y+2, r1	; 0x02
    3f84:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    3f86:	8f 81       	ldd	r24, Y+7	; 0x07
    3f88:	88 23       	and	r24, r24
    3f8a:	09 f4       	brne	.+2      	; 0x3f8e <xQueueGenericCreate+0x26>
    3f8c:	3f c0       	rjmp	.+126    	; 0x400c <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    3f8e:	8f e1       	ldi	r24, 0x1F	; 31
    3f90:	90 e0       	ldi	r25, 0x00	; 0
    3f92:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    3f96:	9e 83       	std	Y+6, r25	; 0x06
    3f98:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	a9 f1       	breq	.+106    	; 0x400c <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    3fa4:	28 2f       	mov	r18, r24
    3fa6:	30 e0       	ldi	r19, 0x00	; 0
    3fa8:	88 85       	ldd	r24, Y+8	; 0x08
    3faa:	88 2f       	mov	r24, r24
    3fac:	90 e0       	ldi	r25, 0x00	; 0
    3fae:	ac 01       	movw	r20, r24
    3fb0:	24 9f       	mul	r18, r20
    3fb2:	c0 01       	movw	r24, r0
    3fb4:	25 9f       	mul	r18, r21
    3fb6:	90 0d       	add	r25, r0
    3fb8:	34 9f       	mul	r19, r20
    3fba:	90 0d       	add	r25, r0
    3fbc:	11 24       	eor	r1, r1
    3fbe:	01 96       	adiw	r24, 0x01	; 1
    3fc0:	9c 83       	std	Y+4, r25	; 0x04
    3fc2:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    3fc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fc8:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    3fcc:	ed 81       	ldd	r30, Y+5	; 0x05
    3fce:	fe 81       	ldd	r31, Y+6	; 0x06
    3fd0:	91 83       	std	Z+1, r25	; 0x01
    3fd2:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3fd4:	ed 81       	ldd	r30, Y+5	; 0x05
    3fd6:	fe 81       	ldd	r31, Y+6	; 0x06
    3fd8:	80 81       	ld	r24, Z
    3fda:	91 81       	ldd	r25, Z+1	; 0x01
    3fdc:	00 97       	sbiw	r24, 0x00	; 0
    3fde:	91 f0       	breq	.+36     	; 0x4004 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    3fe0:	ed 81       	ldd	r30, Y+5	; 0x05
    3fe2:	fe 81       	ldd	r31, Y+6	; 0x06
    3fe4:	8f 81       	ldd	r24, Y+7	; 0x07
    3fe6:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3fe8:	ed 81       	ldd	r30, Y+5	; 0x05
    3fea:	fe 81       	ldd	r31, Y+6	; 0x06
    3fec:	88 85       	ldd	r24, Y+8	; 0x08
    3fee:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3ff0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ff2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ff4:	61 e0       	ldi	r22, 0x01	; 1
    3ff6:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3ffa:	8d 81       	ldd	r24, Y+5	; 0x05
    3ffc:	9e 81       	ldd	r25, Y+6	; 0x06
    3ffe:	9a 83       	std	Y+2, r25	; 0x02
    4000:	89 83       	std	Y+1, r24	; 0x01
    4002:	04 c0       	rjmp	.+8      	; 0x400c <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    4004:	8d 81       	ldd	r24, Y+5	; 0x05
    4006:	9e 81       	ldd	r25, Y+6	; 0x06
    4008:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4010:	29 96       	adiw	r28, 0x09	; 9
    4012:	0f b6       	in	r0, 0x3f	; 63
    4014:	f8 94       	cli
    4016:	de bf       	out	0x3e, r29	; 62
    4018:	0f be       	out	0x3f, r0	; 63
    401a:	cd bf       	out	0x3d, r28	; 61
    401c:	cf 91       	pop	r28
    401e:	df 91       	pop	r29
    4020:	08 95       	ret

00004022 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    4022:	df 93       	push	r29
    4024:	cf 93       	push	r28
    4026:	00 d0       	rcall	.+0      	; 0x4028 <xQueueCreateMutex+0x6>
    4028:	0f 92       	push	r0
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
    402e:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    4030:	8f e1       	ldi	r24, 0x1F	; 31
    4032:	90 e0       	ldi	r25, 0x00	; 0
    4034:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    4038:	9a 83       	std	Y+2, r25	; 0x02
    403a:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    403c:	89 81       	ldd	r24, Y+1	; 0x01
    403e:	9a 81       	ldd	r25, Y+2	; 0x02
    4040:	00 97       	sbiw	r24, 0x00	; 0
    4042:	a9 f1       	breq	.+106    	; 0x40ae <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	13 82       	std	Z+3, r1	; 0x03
    404a:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    404c:	e9 81       	ldd	r30, Y+1	; 0x01
    404e:	fa 81       	ldd	r31, Y+2	; 0x02
    4050:	11 82       	std	Z+1, r1	; 0x01
    4052:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    4054:	e9 81       	ldd	r30, Y+1	; 0x01
    4056:	fa 81       	ldd	r31, Y+2	; 0x02
    4058:	15 82       	std	Z+5, r1	; 0x05
    405a:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    405c:	e9 81       	ldd	r30, Y+1	; 0x01
    405e:	fa 81       	ldd	r31, Y+2	; 0x02
    4060:	17 82       	std	Z+7, r1	; 0x07
    4062:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    4064:	e9 81       	ldd	r30, Y+1	; 0x01
    4066:	fa 81       	ldd	r31, Y+2	; 0x02
    4068:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    406a:	e9 81       	ldd	r30, Y+1	; 0x01
    406c:	fa 81       	ldd	r31, Y+2	; 0x02
    406e:	81 e0       	ldi	r24, 0x01	; 1
    4070:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    4072:	e9 81       	ldd	r30, Y+1	; 0x01
    4074:	fa 81       	ldd	r31, Y+2	; 0x02
    4076:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    4078:	e9 81       	ldd	r30, Y+1	; 0x01
    407a:	fa 81       	ldd	r31, Y+2	; 0x02
    407c:	8f ef       	ldi	r24, 0xFF	; 255
    407e:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    4080:	e9 81       	ldd	r30, Y+1	; 0x01
    4082:	fa 81       	ldd	r31, Y+2	; 0x02
    4084:	8f ef       	ldi	r24, 0xFF	; 255
    4086:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4088:	89 81       	ldd	r24, Y+1	; 0x01
    408a:	9a 81       	ldd	r25, Y+2	; 0x02
    408c:	08 96       	adiw	r24, 0x08	; 8
    408e:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4092:	89 81       	ldd	r24, Y+1	; 0x01
    4094:	9a 81       	ldd	r25, Y+2	; 0x02
    4096:	41 96       	adiw	r24, 0x11	; 17
    4098:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    409c:	89 81       	ldd	r24, Y+1	; 0x01
    409e:	9a 81       	ldd	r25, Y+2	; 0x02
    40a0:	60 e0       	ldi	r22, 0x00	; 0
    40a2:	70 e0       	ldi	r23, 0x00	; 0
    40a4:	40 e0       	ldi	r20, 0x00	; 0
    40a6:	50 e0       	ldi	r21, 0x00	; 0
    40a8:	20 e0       	ldi	r18, 0x00	; 0
    40aa:	0e 94 7f 20 	call	0x40fe	; 0x40fe <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    40b2:	0f 90       	pop	r0
    40b4:	0f 90       	pop	r0
    40b6:	0f 90       	pop	r0
    40b8:	cf 91       	pop	r28
    40ba:	df 91       	pop	r29
    40bc:	08 95       	ret

000040be <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    40be:	df 93       	push	r29
    40c0:	cf 93       	push	r28
    40c2:	00 d0       	rcall	.+0      	; 0x40c4 <xQueueCreateCountingSemaphore+0x6>
    40c4:	00 d0       	rcall	.+0      	; 0x40c6 <xQueueCreateCountingSemaphore+0x8>
    40c6:	cd b7       	in	r28, 0x3d	; 61
    40c8:	de b7       	in	r29, 0x3e	; 62
    40ca:	8b 83       	std	Y+3, r24	; 0x03
    40cc:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    40ce:	8b 81       	ldd	r24, Y+3	; 0x03
    40d0:	60 e0       	ldi	r22, 0x00	; 0
    40d2:	42 e0       	ldi	r20, 0x02	; 2
    40d4:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <xQueueGenericCreate>
    40d8:	9a 83       	std	Y+2, r25	; 0x02
    40da:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    40dc:	89 81       	ldd	r24, Y+1	; 0x01
    40de:	9a 81       	ldd	r25, Y+2	; 0x02
    40e0:	00 97       	sbiw	r24, 0x00	; 0
    40e2:	21 f0       	breq	.+8      	; 0x40ec <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    40e4:	e9 81       	ldd	r30, Y+1	; 0x01
    40e6:	fa 81       	ldd	r31, Y+2	; 0x02
    40e8:	8c 81       	ldd	r24, Y+4	; 0x04
    40ea:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    40ec:	89 81       	ldd	r24, Y+1	; 0x01
    40ee:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    40f0:	0f 90       	pop	r0
    40f2:	0f 90       	pop	r0
    40f4:	0f 90       	pop	r0
    40f6:	0f 90       	pop	r0
    40f8:	cf 91       	pop	r28
    40fa:	df 91       	pop	r29
    40fc:	08 95       	ret

000040fe <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    40fe:	df 93       	push	r29
    4100:	cf 93       	push	r28
    4102:	cd b7       	in	r28, 0x3d	; 61
    4104:	de b7       	in	r29, 0x3e	; 62
    4106:	2f 97       	sbiw	r28, 0x0f	; 15
    4108:	0f b6       	in	r0, 0x3f	; 63
    410a:	f8 94       	cli
    410c:	de bf       	out	0x3e, r29	; 62
    410e:	0f be       	out	0x3f, r0	; 63
    4110:	cd bf       	out	0x3d, r28	; 61
    4112:	99 87       	std	Y+9, r25	; 0x09
    4114:	88 87       	std	Y+8, r24	; 0x08
    4116:	7b 87       	std	Y+11, r23	; 0x0b
    4118:	6a 87       	std	Y+10, r22	; 0x0a
    411a:	5d 87       	std	Y+13, r21	; 0x0d
    411c:	4c 87       	std	Y+12, r20	; 0x0c
    411e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    4120:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4122:	88 85       	ldd	r24, Y+8	; 0x08
    4124:	99 85       	ldd	r25, Y+9	; 0x09
    4126:	9a 83       	std	Y+2, r25	; 0x02
    4128:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    412a:	0f b6       	in	r0, 0x3f	; 63
    412c:	f8 94       	cli
    412e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4130:	e9 81       	ldd	r30, Y+1	; 0x01
    4132:	fa 81       	ldd	r31, Y+2	; 0x02
    4134:	92 8d       	ldd	r25, Z+26	; 0x1a
    4136:	e9 81       	ldd	r30, Y+1	; 0x01
    4138:	fa 81       	ldd	r31, Y+2	; 0x02
    413a:	83 8d       	ldd	r24, Z+27	; 0x1b
    413c:	98 17       	cp	r25, r24
    413e:	18 f0       	brcs	.+6      	; 0x4146 <xQueueGenericSend+0x48>
    4140:	8e 85       	ldd	r24, Y+14	; 0x0e
    4142:	82 30       	cpi	r24, 0x02	; 2
    4144:	11 f5       	brne	.+68     	; 0x418a <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4146:	89 81       	ldd	r24, Y+1	; 0x01
    4148:	9a 81       	ldd	r25, Y+2	; 0x02
    414a:	2a 85       	ldd	r18, Y+10	; 0x0a
    414c:	3b 85       	ldd	r19, Y+11	; 0x0b
    414e:	b9 01       	movw	r22, r18
    4150:	4e 85       	ldd	r20, Y+14	; 0x0e
    4152:	0e 94 71 23 	call	0x46e2	; 0x46e2 <prvCopyDataToQueue>
    4156:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4158:	e9 81       	ldd	r30, Y+1	; 0x01
    415a:	fa 81       	ldd	r31, Y+2	; 0x02
    415c:	81 89       	ldd	r24, Z+17	; 0x11
    415e:	88 23       	and	r24, r24
    4160:	51 f0       	breq	.+20     	; 0x4176 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    4162:	89 81       	ldd	r24, Y+1	; 0x01
    4164:	9a 81       	ldd	r25, Y+2	; 0x02
    4166:	41 96       	adiw	r24, 0x11	; 17
    4168:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    416c:	81 30       	cpi	r24, 0x01	; 1
    416e:	41 f4       	brne	.+16     	; 0x4180 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    4170:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    4174:	05 c0       	rjmp	.+10     	; 0x4180 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    4176:	8b 81       	ldd	r24, Y+3	; 0x03
    4178:	88 23       	and	r24, r24
    417a:	11 f0       	breq	.+4      	; 0x4180 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    417c:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    4180:	0f 90       	pop	r0
    4182:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4184:	81 e0       	ldi	r24, 0x01	; 1
    4186:	8f 87       	std	Y+15, r24	; 0x0f
    4188:	5c c0       	rjmp	.+184    	; 0x4242 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    418a:	8c 85       	ldd	r24, Y+12	; 0x0c
    418c:	9d 85       	ldd	r25, Y+13	; 0x0d
    418e:	00 97       	sbiw	r24, 0x00	; 0
    4190:	21 f4       	brne	.+8      	; 0x419a <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4192:	0f 90       	pop	r0
    4194:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    4196:	1f 86       	std	Y+15, r1	; 0x0f
    4198:	54 c0       	rjmp	.+168    	; 0x4242 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    419a:	8c 81       	ldd	r24, Y+4	; 0x04
    419c:	88 23       	and	r24, r24
    419e:	31 f4       	brne	.+12     	; 0x41ac <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    41a0:	ce 01       	movw	r24, r28
    41a2:	05 96       	adiw	r24, 0x05	; 5
    41a4:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    41a8:	81 e0       	ldi	r24, 0x01	; 1
    41aa:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    41ac:	0f 90       	pop	r0
    41ae:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    41b0:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    41b4:	0f b6       	in	r0, 0x3f	; 63
    41b6:	f8 94       	cli
    41b8:	0f 92       	push	r0
    41ba:	e9 81       	ldd	r30, Y+1	; 0x01
    41bc:	fa 81       	ldd	r31, Y+2	; 0x02
    41be:	85 8d       	ldd	r24, Z+29	; 0x1d
    41c0:	8f 3f       	cpi	r24, 0xFF	; 255
    41c2:	19 f4       	brne	.+6      	; 0x41ca <xQueueGenericSend+0xcc>
    41c4:	e9 81       	ldd	r30, Y+1	; 0x01
    41c6:	fa 81       	ldd	r31, Y+2	; 0x02
    41c8:	15 8e       	std	Z+29, r1	; 0x1d
    41ca:	e9 81       	ldd	r30, Y+1	; 0x01
    41cc:	fa 81       	ldd	r31, Y+2	; 0x02
    41ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    41d0:	8f 3f       	cpi	r24, 0xFF	; 255
    41d2:	19 f4       	brne	.+6      	; 0x41da <xQueueGenericSend+0xdc>
    41d4:	e9 81       	ldd	r30, Y+1	; 0x01
    41d6:	fa 81       	ldd	r31, Y+2	; 0x02
    41d8:	16 8e       	std	Z+30, r1	; 0x1e
    41da:	0f 90       	pop	r0
    41dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    41de:	ce 01       	movw	r24, r28
    41e0:	05 96       	adiw	r24, 0x05	; 5
    41e2:	9e 01       	movw	r18, r28
    41e4:	24 5f       	subi	r18, 0xF4	; 244
    41e6:	3f 4f       	sbci	r19, 0xFF	; 255
    41e8:	b9 01       	movw	r22, r18
    41ea:	0e 94 10 2f 	call	0x5e20	; 0x5e20 <xTaskCheckForTimeOut>
    41ee:	88 23       	and	r24, r24
    41f0:	09 f5       	brne	.+66     	; 0x4234 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    41f2:	89 81       	ldd	r24, Y+1	; 0x01
    41f4:	9a 81       	ldd	r25, Y+2	; 0x02
    41f6:	0e 94 fa 24 	call	0x49f4	; 0x49f4 <prvIsQueueFull>
    41fa:	88 23       	and	r24, r24
    41fc:	a1 f0       	breq	.+40     	; 0x4226 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    41fe:	89 81       	ldd	r24, Y+1	; 0x01
    4200:	9a 81       	ldd	r25, Y+2	; 0x02
    4202:	08 96       	adiw	r24, 0x08	; 8
    4204:	2c 85       	ldd	r18, Y+12	; 0x0c
    4206:	3d 85       	ldd	r19, Y+13	; 0x0d
    4208:	b9 01       	movw	r22, r18
    420a:	0e 94 89 2d 	call	0x5b12	; 0x5b12 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    420e:	89 81       	ldd	r24, Y+1	; 0x01
    4210:	9a 81       	ldd	r25, Y+2	; 0x02
    4212:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    4216:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    421a:	88 23       	and	r24, r24
    421c:	09 f0       	breq	.+2      	; 0x4220 <xQueueGenericSend+0x122>
    421e:	85 cf       	rjmp	.-246    	; 0x412a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    4220:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    4224:	82 cf       	rjmp	.-252    	; 0x412a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4226:	89 81       	ldd	r24, Y+1	; 0x01
    4228:	9a 81       	ldd	r25, Y+2	; 0x02
    422a:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    422e:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    4232:	7b cf       	rjmp	.-266    	; 0x412a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    4234:	89 81       	ldd	r24, Y+1	; 0x01
    4236:	9a 81       	ldd	r25, Y+2	; 0x02
    4238:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    423c:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4240:	1f 86       	std	Y+15, r1	; 0x0f
    4242:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    4244:	2f 96       	adiw	r28, 0x0f	; 15
    4246:	0f b6       	in	r0, 0x3f	; 63
    4248:	f8 94       	cli
    424a:	de bf       	out	0x3e, r29	; 62
    424c:	0f be       	out	0x3f, r0	; 63
    424e:	cd bf       	out	0x3d, r28	; 61
    4250:	cf 91       	pop	r28
    4252:	df 91       	pop	r29
    4254:	08 95       	ret

00004256 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    4256:	df 93       	push	r29
    4258:	cf 93       	push	r28
    425a:	cd b7       	in	r28, 0x3d	; 61
    425c:	de b7       	in	r29, 0x3e	; 62
    425e:	2b 97       	sbiw	r28, 0x0b	; 11
    4260:	0f b6       	in	r0, 0x3f	; 63
    4262:	f8 94       	cli
    4264:	de bf       	out	0x3e, r29	; 62
    4266:	0f be       	out	0x3f, r0	; 63
    4268:	cd bf       	out	0x3d, r28	; 61
    426a:	9e 83       	std	Y+6, r25	; 0x06
    426c:	8d 83       	std	Y+5, r24	; 0x05
    426e:	78 87       	std	Y+8, r23	; 0x08
    4270:	6f 83       	std	Y+7, r22	; 0x07
    4272:	5a 87       	std	Y+10, r21	; 0x0a
    4274:	49 87       	std	Y+9, r20	; 0x09
    4276:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4278:	8d 81       	ldd	r24, Y+5	; 0x05
    427a:	9e 81       	ldd	r25, Y+6	; 0x06
    427c:	9a 83       	std	Y+2, r25	; 0x02
    427e:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4280:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4282:	e9 81       	ldd	r30, Y+1	; 0x01
    4284:	fa 81       	ldd	r31, Y+2	; 0x02
    4286:	92 8d       	ldd	r25, Z+26	; 0x1a
    4288:	e9 81       	ldd	r30, Y+1	; 0x01
    428a:	fa 81       	ldd	r31, Y+2	; 0x02
    428c:	83 8d       	ldd	r24, Z+27	; 0x1b
    428e:	98 17       	cp	r25, r24
    4290:	18 f0       	brcs	.+6      	; 0x4298 <xQueueGenericSendFromISR+0x42>
    4292:	8b 85       	ldd	r24, Y+11	; 0x0b
    4294:	82 30       	cpi	r24, 0x02	; 2
    4296:	b1 f5       	brne	.+108    	; 0x4304 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	9a 81       	ldd	r25, Y+2	; 0x02
    429c:	2f 81       	ldd	r18, Y+7	; 0x07
    429e:	38 85       	ldd	r19, Y+8	; 0x08
    42a0:	b9 01       	movw	r22, r18
    42a2:	4b 85       	ldd	r20, Y+11	; 0x0b
    42a4:	0e 94 71 23 	call	0x46e2	; 0x46e2 <prvCopyDataToQueue>
    42a8:	88 23       	and	r24, r24
    42aa:	41 f0       	breq	.+16     	; 0x42bc <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    42ac:	89 85       	ldd	r24, Y+9	; 0x09
    42ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    42b0:	00 97       	sbiw	r24, 0x00	; 0
    42b2:	21 f0       	breq	.+8      	; 0x42bc <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    42b4:	e9 85       	ldd	r30, Y+9	; 0x09
    42b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    42b8:	81 e0       	ldi	r24, 0x01	; 1
    42ba:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    42c2:	8f 3f       	cpi	r24, 0xFF	; 255
    42c4:	a9 f4       	brne	.+42     	; 0x42f0 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    42c6:	e9 81       	ldd	r30, Y+1	; 0x01
    42c8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ca:	81 89       	ldd	r24, Z+17	; 0x11
    42cc:	88 23       	and	r24, r24
    42ce:	b9 f0       	breq	.+46     	; 0x42fe <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    42d0:	89 81       	ldd	r24, Y+1	; 0x01
    42d2:	9a 81       	ldd	r25, Y+2	; 0x02
    42d4:	41 96       	adiw	r24, 0x11	; 17
    42d6:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    42da:	88 23       	and	r24, r24
    42dc:	81 f0       	breq	.+32     	; 0x42fe <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    42de:	89 85       	ldd	r24, Y+9	; 0x09
    42e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    42e2:	00 97       	sbiw	r24, 0x00	; 0
    42e4:	61 f0       	breq	.+24     	; 0x42fe <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    42e6:	e9 85       	ldd	r30, Y+9	; 0x09
    42e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ea:	81 e0       	ldi	r24, 0x01	; 1
    42ec:	80 83       	st	Z, r24
    42ee:	07 c0       	rjmp	.+14     	; 0x42fe <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    42f0:	e9 81       	ldd	r30, Y+1	; 0x01
    42f2:	fa 81       	ldd	r31, Y+2	; 0x02
    42f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    42f6:	8f 5f       	subi	r24, 0xFF	; 255
    42f8:	e9 81       	ldd	r30, Y+1	; 0x01
    42fa:	fa 81       	ldd	r31, Y+2	; 0x02
    42fc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	8c 83       	std	Y+4, r24	; 0x04
    4302:	01 c0       	rjmp	.+2      	; 0x4306 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4304:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4306:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4308:	2b 96       	adiw	r28, 0x0b	; 11
    430a:	0f b6       	in	r0, 0x3f	; 63
    430c:	f8 94       	cli
    430e:	de bf       	out	0x3e, r29	; 62
    4310:	0f be       	out	0x3f, r0	; 63
    4312:	cd bf       	out	0x3d, r28	; 61
    4314:	cf 91       	pop	r28
    4316:	df 91       	pop	r29
    4318:	08 95       	ret

0000431a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    431a:	df 93       	push	r29
    431c:	cf 93       	push	r28
    431e:	cd b7       	in	r28, 0x3d	; 61
    4320:	de b7       	in	r29, 0x3e	; 62
    4322:	60 97       	sbiw	r28, 0x10	; 16
    4324:	0f b6       	in	r0, 0x3f	; 63
    4326:	f8 94       	cli
    4328:	de bf       	out	0x3e, r29	; 62
    432a:	0f be       	out	0x3f, r0	; 63
    432c:	cd bf       	out	0x3d, r28	; 61
    432e:	9a 87       	std	Y+10, r25	; 0x0a
    4330:	89 87       	std	Y+9, r24	; 0x09
    4332:	7c 87       	std	Y+12, r23	; 0x0c
    4334:	6b 87       	std	Y+11, r22	; 0x0b
    4336:	5e 87       	std	Y+14, r21	; 0x0e
    4338:	4d 87       	std	Y+13, r20	; 0x0d
    433a:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    433c:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    433e:	89 85       	ldd	r24, Y+9	; 0x09
    4340:	9a 85       	ldd	r25, Y+10	; 0x0a
    4342:	9a 83       	std	Y+2, r25	; 0x02
    4344:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4346:	0f b6       	in	r0, 0x3f	; 63
    4348:	f8 94       	cli
    434a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    434c:	e9 81       	ldd	r30, Y+1	; 0x01
    434e:	fa 81       	ldd	r31, Y+2	; 0x02
    4350:	82 8d       	ldd	r24, Z+26	; 0x1a
    4352:	88 23       	and	r24, r24
    4354:	09 f4       	brne	.+2      	; 0x4358 <xQueueGenericReceive+0x3e>
    4356:	4b c0       	rjmp	.+150    	; 0x43ee <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    4358:	e9 81       	ldd	r30, Y+1	; 0x01
    435a:	fa 81       	ldd	r31, Y+2	; 0x02
    435c:	86 81       	ldd	r24, Z+6	; 0x06
    435e:	97 81       	ldd	r25, Z+7	; 0x07
    4360:	9c 83       	std	Y+4, r25	; 0x04
    4362:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4364:	89 81       	ldd	r24, Y+1	; 0x01
    4366:	9a 81       	ldd	r25, Y+2	; 0x02
    4368:	2b 85       	ldd	r18, Y+11	; 0x0b
    436a:	3c 85       	ldd	r19, Y+12	; 0x0c
    436c:	b9 01       	movw	r22, r18
    436e:	0e 94 2a 24 	call	0x4854	; 0x4854 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    4372:	8f 85       	ldd	r24, Y+15	; 0x0f
    4374:	88 23       	and	r24, r24
    4376:	11 f5       	brne	.+68     	; 0x43bc <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    4378:	e9 81       	ldd	r30, Y+1	; 0x01
    437a:	fa 81       	ldd	r31, Y+2	; 0x02
    437c:	82 8d       	ldd	r24, Z+26	; 0x1a
    437e:	81 50       	subi	r24, 0x01	; 1
    4380:	e9 81       	ldd	r30, Y+1	; 0x01
    4382:	fa 81       	ldd	r31, Y+2	; 0x02
    4384:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4386:	e9 81       	ldd	r30, Y+1	; 0x01
    4388:	fa 81       	ldd	r31, Y+2	; 0x02
    438a:	80 81       	ld	r24, Z
    438c:	91 81       	ldd	r25, Z+1	; 0x01
    438e:	00 97       	sbiw	r24, 0x00	; 0
    4390:	31 f4       	brne	.+12     	; 0x439e <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    4392:	0e 94 95 32 	call	0x652a	; 0x652a <pvTaskIncrementMutexHeldCount>
    4396:	e9 81       	ldd	r30, Y+1	; 0x01
    4398:	fa 81       	ldd	r31, Y+2	; 0x02
    439a:	93 83       	std	Z+3, r25	; 0x03
    439c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    439e:	e9 81       	ldd	r30, Y+1	; 0x01
    43a0:	fa 81       	ldd	r31, Y+2	; 0x02
    43a2:	80 85       	ldd	r24, Z+8	; 0x08
    43a4:	88 23       	and	r24, r24
    43a6:	f1 f0       	breq	.+60     	; 0x43e4 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    43a8:	89 81       	ldd	r24, Y+1	; 0x01
    43aa:	9a 81       	ldd	r25, Y+2	; 0x02
    43ac:	08 96       	adiw	r24, 0x08	; 8
    43ae:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    43b2:	81 30       	cpi	r24, 0x01	; 1
    43b4:	b9 f4       	brne	.+46     	; 0x43e4 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    43b6:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    43ba:	14 c0       	rjmp	.+40     	; 0x43e4 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    43bc:	e9 81       	ldd	r30, Y+1	; 0x01
    43be:	fa 81       	ldd	r31, Y+2	; 0x02
    43c0:	8b 81       	ldd	r24, Y+3	; 0x03
    43c2:	9c 81       	ldd	r25, Y+4	; 0x04
    43c4:	97 83       	std	Z+7, r25	; 0x07
    43c6:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    43c8:	e9 81       	ldd	r30, Y+1	; 0x01
    43ca:	fa 81       	ldd	r31, Y+2	; 0x02
    43cc:	81 89       	ldd	r24, Z+17	; 0x11
    43ce:	88 23       	and	r24, r24
    43d0:	49 f0       	breq	.+18     	; 0x43e4 <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    43d2:	89 81       	ldd	r24, Y+1	; 0x01
    43d4:	9a 81       	ldd	r25, Y+2	; 0x02
    43d6:	41 96       	adiw	r24, 0x11	; 17
    43d8:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    43dc:	88 23       	and	r24, r24
    43de:	11 f0       	breq	.+4      	; 0x43e4 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    43e0:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    43e4:	0f 90       	pop	r0
    43e6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    43e8:	81 e0       	ldi	r24, 0x01	; 1
    43ea:	88 8b       	std	Y+16, r24	; 0x10
    43ec:	6d c0       	rjmp	.+218    	; 0x44c8 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    43ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    43f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    43f2:	00 97       	sbiw	r24, 0x00	; 0
    43f4:	21 f4       	brne	.+8      	; 0x43fe <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    43f6:	0f 90       	pop	r0
    43f8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    43fa:	18 8a       	std	Y+16, r1	; 0x10
    43fc:	65 c0       	rjmp	.+202    	; 0x44c8 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    43fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4400:	88 23       	and	r24, r24
    4402:	31 f4       	brne	.+12     	; 0x4410 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4404:	ce 01       	movw	r24, r28
    4406:	06 96       	adiw	r24, 0x06	; 6
    4408:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    440c:	81 e0       	ldi	r24, 0x01	; 1
    440e:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4410:	0f 90       	pop	r0
    4412:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4414:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4418:	0f b6       	in	r0, 0x3f	; 63
    441a:	f8 94       	cli
    441c:	0f 92       	push	r0
    441e:	e9 81       	ldd	r30, Y+1	; 0x01
    4420:	fa 81       	ldd	r31, Y+2	; 0x02
    4422:	85 8d       	ldd	r24, Z+29	; 0x1d
    4424:	8f 3f       	cpi	r24, 0xFF	; 255
    4426:	19 f4       	brne	.+6      	; 0x442e <xQueueGenericReceive+0x114>
    4428:	e9 81       	ldd	r30, Y+1	; 0x01
    442a:	fa 81       	ldd	r31, Y+2	; 0x02
    442c:	15 8e       	std	Z+29, r1	; 0x1d
    442e:	e9 81       	ldd	r30, Y+1	; 0x01
    4430:	fa 81       	ldd	r31, Y+2	; 0x02
    4432:	86 8d       	ldd	r24, Z+30	; 0x1e
    4434:	8f 3f       	cpi	r24, 0xFF	; 255
    4436:	19 f4       	brne	.+6      	; 0x443e <xQueueGenericReceive+0x124>
    4438:	e9 81       	ldd	r30, Y+1	; 0x01
    443a:	fa 81       	ldd	r31, Y+2	; 0x02
    443c:	16 8e       	std	Z+30, r1	; 0x1e
    443e:	0f 90       	pop	r0
    4440:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4442:	ce 01       	movw	r24, r28
    4444:	06 96       	adiw	r24, 0x06	; 6
    4446:	9e 01       	movw	r18, r28
    4448:	23 5f       	subi	r18, 0xF3	; 243
    444a:	3f 4f       	sbci	r19, 0xFF	; 255
    444c:	b9 01       	movw	r22, r18
    444e:	0e 94 10 2f 	call	0x5e20	; 0x5e20 <xTaskCheckForTimeOut>
    4452:	88 23       	and	r24, r24
    4454:	91 f5       	brne	.+100    	; 0x44ba <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	0e 94 c5 24 	call	0x498a	; 0x498a <prvIsQueueEmpty>
    445e:	88 23       	and	r24, r24
    4460:	29 f1       	breq	.+74     	; 0x44ac <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4462:	e9 81       	ldd	r30, Y+1	; 0x01
    4464:	fa 81       	ldd	r31, Y+2	; 0x02
    4466:	80 81       	ld	r24, Z
    4468:	91 81       	ldd	r25, Z+1	; 0x01
    446a:	00 97       	sbiw	r24, 0x00	; 0
    446c:	59 f4       	brne	.+22     	; 0x4484 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    4474:	e9 81       	ldd	r30, Y+1	; 0x01
    4476:	fa 81       	ldd	r31, Y+2	; 0x02
    4478:	82 81       	ldd	r24, Z+2	; 0x02
    447a:	93 81       	ldd	r25, Z+3	; 0x03
    447c:	0e 94 71 31 	call	0x62e2	; 0x62e2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    4480:	0f 90       	pop	r0
    4482:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4484:	89 81       	ldd	r24, Y+1	; 0x01
    4486:	9a 81       	ldd	r25, Y+2	; 0x02
    4488:	41 96       	adiw	r24, 0x11	; 17
    448a:	2d 85       	ldd	r18, Y+13	; 0x0d
    448c:	3e 85       	ldd	r19, Y+14	; 0x0e
    448e:	b9 01       	movw	r22, r18
    4490:	0e 94 89 2d 	call	0x5b12	; 0x5b12 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	9a 81       	ldd	r25, Y+2	; 0x02
    4498:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    449c:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    44a0:	88 23       	and	r24, r24
    44a2:	09 f0       	breq	.+2      	; 0x44a6 <xQueueGenericReceive+0x18c>
    44a4:	50 cf       	rjmp	.-352    	; 0x4346 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    44a6:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    44aa:	4d cf       	rjmp	.-358    	; 0x4346 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    44ac:	89 81       	ldd	r24, Y+1	; 0x01
    44ae:	9a 81       	ldd	r25, Y+2	; 0x02
    44b0:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    44b4:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    44b8:	46 cf       	rjmp	.-372    	; 0x4346 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    44ba:	89 81       	ldd	r24, Y+1	; 0x01
    44bc:	9a 81       	ldd	r25, Y+2	; 0x02
    44be:	0e 94 71 24 	call	0x48e2	; 0x48e2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    44c2:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    44c6:	18 8a       	std	Y+16, r1	; 0x10
    44c8:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    44ca:	60 96       	adiw	r28, 0x10	; 16
    44cc:	0f b6       	in	r0, 0x3f	; 63
    44ce:	f8 94       	cli
    44d0:	de bf       	out	0x3e, r29	; 62
    44d2:	0f be       	out	0x3f, r0	; 63
    44d4:	cd bf       	out	0x3d, r28	; 61
    44d6:	cf 91       	pop	r28
    44d8:	df 91       	pop	r29
    44da:	08 95       	ret

000044dc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    44dc:	df 93       	push	r29
    44de:	cf 93       	push	r28
    44e0:	cd b7       	in	r28, 0x3d	; 61
    44e2:	de b7       	in	r29, 0x3e	; 62
    44e4:	2a 97       	sbiw	r28, 0x0a	; 10
    44e6:	0f b6       	in	r0, 0x3f	; 63
    44e8:	f8 94       	cli
    44ea:	de bf       	out	0x3e, r29	; 62
    44ec:	0f be       	out	0x3f, r0	; 63
    44ee:	cd bf       	out	0x3d, r28	; 61
    44f0:	9e 83       	std	Y+6, r25	; 0x06
    44f2:	8d 83       	std	Y+5, r24	; 0x05
    44f4:	78 87       	std	Y+8, r23	; 0x08
    44f6:	6f 83       	std	Y+7, r22	; 0x07
    44f8:	5a 87       	std	Y+10, r21	; 0x0a
    44fa:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    44fc:	8d 81       	ldd	r24, Y+5	; 0x05
    44fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4500:	9a 83       	std	Y+2, r25	; 0x02
    4502:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4504:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4506:	e9 81       	ldd	r30, Y+1	; 0x01
    4508:	fa 81       	ldd	r31, Y+2	; 0x02
    450a:	82 8d       	ldd	r24, Z+26	; 0x1a
    450c:	88 23       	and	r24, r24
    450e:	91 f1       	breq	.+100    	; 0x4574 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4510:	89 81       	ldd	r24, Y+1	; 0x01
    4512:	9a 81       	ldd	r25, Y+2	; 0x02
    4514:	2f 81       	ldd	r18, Y+7	; 0x07
    4516:	38 85       	ldd	r19, Y+8	; 0x08
    4518:	b9 01       	movw	r22, r18
    451a:	0e 94 2a 24 	call	0x4854	; 0x4854 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    451e:	e9 81       	ldd	r30, Y+1	; 0x01
    4520:	fa 81       	ldd	r31, Y+2	; 0x02
    4522:	82 8d       	ldd	r24, Z+26	; 0x1a
    4524:	81 50       	subi	r24, 0x01	; 1
    4526:	e9 81       	ldd	r30, Y+1	; 0x01
    4528:	fa 81       	ldd	r31, Y+2	; 0x02
    452a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    452c:	e9 81       	ldd	r30, Y+1	; 0x01
    452e:	fa 81       	ldd	r31, Y+2	; 0x02
    4530:	85 8d       	ldd	r24, Z+29	; 0x1d
    4532:	8f 3f       	cpi	r24, 0xFF	; 255
    4534:	a9 f4       	brne	.+42     	; 0x4560 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4536:	e9 81       	ldd	r30, Y+1	; 0x01
    4538:	fa 81       	ldd	r31, Y+2	; 0x02
    453a:	80 85       	ldd	r24, Z+8	; 0x08
    453c:	88 23       	and	r24, r24
    453e:	b9 f0       	breq	.+46     	; 0x456e <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4540:	89 81       	ldd	r24, Y+1	; 0x01
    4542:	9a 81       	ldd	r25, Y+2	; 0x02
    4544:	08 96       	adiw	r24, 0x08	; 8
    4546:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    454a:	88 23       	and	r24, r24
    454c:	81 f0       	breq	.+32     	; 0x456e <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    454e:	89 85       	ldd	r24, Y+9	; 0x09
    4550:	9a 85       	ldd	r25, Y+10	; 0x0a
    4552:	00 97       	sbiw	r24, 0x00	; 0
    4554:	61 f0       	breq	.+24     	; 0x456e <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    4556:	e9 85       	ldd	r30, Y+9	; 0x09
    4558:	fa 85       	ldd	r31, Y+10	; 0x0a
    455a:	81 e0       	ldi	r24, 0x01	; 1
    455c:	80 83       	st	Z, r24
    455e:	07 c0       	rjmp	.+14     	; 0x456e <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4560:	e9 81       	ldd	r30, Y+1	; 0x01
    4562:	fa 81       	ldd	r31, Y+2	; 0x02
    4564:	85 8d       	ldd	r24, Z+29	; 0x1d
    4566:	8f 5f       	subi	r24, 0xFF	; 255
    4568:	e9 81       	ldd	r30, Y+1	; 0x01
    456a:	fa 81       	ldd	r31, Y+2	; 0x02
    456c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    456e:	81 e0       	ldi	r24, 0x01	; 1
    4570:	8c 83       	std	Y+4, r24	; 0x04
    4572:	01 c0       	rjmp	.+2      	; 0x4576 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    4574:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4576:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4578:	2a 96       	adiw	r28, 0x0a	; 10
    457a:	0f b6       	in	r0, 0x3f	; 63
    457c:	f8 94       	cli
    457e:	de bf       	out	0x3e, r29	; 62
    4580:	0f be       	out	0x3f, r0	; 63
    4582:	cd bf       	out	0x3d, r28	; 61
    4584:	cf 91       	pop	r28
    4586:	df 91       	pop	r29
    4588:	08 95       	ret

0000458a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    458a:	df 93       	push	r29
    458c:	cf 93       	push	r28
    458e:	cd b7       	in	r28, 0x3d	; 61
    4590:	de b7       	in	r29, 0x3e	; 62
    4592:	2a 97       	sbiw	r28, 0x0a	; 10
    4594:	0f b6       	in	r0, 0x3f	; 63
    4596:	f8 94       	cli
    4598:	de bf       	out	0x3e, r29	; 62
    459a:	0f be       	out	0x3f, r0	; 63
    459c:	cd bf       	out	0x3d, r28	; 61
    459e:	98 87       	std	Y+8, r25	; 0x08
    45a0:	8f 83       	std	Y+7, r24	; 0x07
    45a2:	7a 87       	std	Y+10, r23	; 0x0a
    45a4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    45a6:	8f 81       	ldd	r24, Y+7	; 0x07
    45a8:	98 85       	ldd	r25, Y+8	; 0x08
    45aa:	9a 83       	std	Y+2, r25	; 0x02
    45ac:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    45ae:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    45b0:	e9 81       	ldd	r30, Y+1	; 0x01
    45b2:	fa 81       	ldd	r31, Y+2	; 0x02
    45b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    45b6:	88 23       	and	r24, r24
    45b8:	b1 f0       	breq	.+44     	; 0x45e6 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    45ba:	e9 81       	ldd	r30, Y+1	; 0x01
    45bc:	fa 81       	ldd	r31, Y+2	; 0x02
    45be:	86 81       	ldd	r24, Z+6	; 0x06
    45c0:	97 81       	ldd	r25, Z+7	; 0x07
    45c2:	9c 83       	std	Y+4, r25	; 0x04
    45c4:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    45c6:	89 81       	ldd	r24, Y+1	; 0x01
    45c8:	9a 81       	ldd	r25, Y+2	; 0x02
    45ca:	29 85       	ldd	r18, Y+9	; 0x09
    45cc:	3a 85       	ldd	r19, Y+10	; 0x0a
    45ce:	b9 01       	movw	r22, r18
    45d0:	0e 94 2a 24 	call	0x4854	; 0x4854 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    45d4:	e9 81       	ldd	r30, Y+1	; 0x01
    45d6:	fa 81       	ldd	r31, Y+2	; 0x02
    45d8:	8b 81       	ldd	r24, Y+3	; 0x03
    45da:	9c 81       	ldd	r25, Y+4	; 0x04
    45dc:	97 83       	std	Z+7, r25	; 0x07
    45de:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    45e0:	81 e0       	ldi	r24, 0x01	; 1
    45e2:	8e 83       	std	Y+6, r24	; 0x06
    45e4:	01 c0       	rjmp	.+2      	; 0x45e8 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    45e6:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    45e8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    45ea:	2a 96       	adiw	r28, 0x0a	; 10
    45ec:	0f b6       	in	r0, 0x3f	; 63
    45ee:	f8 94       	cli
    45f0:	de bf       	out	0x3e, r29	; 62
    45f2:	0f be       	out	0x3f, r0	; 63
    45f4:	cd bf       	out	0x3d, r28	; 61
    45f6:	cf 91       	pop	r28
    45f8:	df 91       	pop	r29
    45fa:	08 95       	ret

000045fc <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    45fc:	df 93       	push	r29
    45fe:	cf 93       	push	r28
    4600:	00 d0       	rcall	.+0      	; 0x4602 <uxQueueMessagesWaiting+0x6>
    4602:	0f 92       	push	r0
    4604:	cd b7       	in	r28, 0x3d	; 61
    4606:	de b7       	in	r29, 0x3e	; 62
    4608:	9b 83       	std	Y+3, r25	; 0x03
    460a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    460c:	0f b6       	in	r0, 0x3f	; 63
    460e:	f8 94       	cli
    4610:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4612:	ea 81       	ldd	r30, Y+2	; 0x02
    4614:	fb 81       	ldd	r31, Y+3	; 0x03
    4616:	82 8d       	ldd	r24, Z+26	; 0x1a
    4618:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    461a:	0f 90       	pop	r0
    461c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    461e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4620:	0f 90       	pop	r0
    4622:	0f 90       	pop	r0
    4624:	0f 90       	pop	r0
    4626:	cf 91       	pop	r28
    4628:	df 91       	pop	r29
    462a:	08 95       	ret

0000462c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    462c:	df 93       	push	r29
    462e:	cf 93       	push	r28
    4630:	00 d0       	rcall	.+0      	; 0x4632 <uxQueueSpacesAvailable+0x6>
    4632:	00 d0       	rcall	.+0      	; 0x4634 <uxQueueSpacesAvailable+0x8>
    4634:	0f 92       	push	r0
    4636:	cd b7       	in	r28, 0x3d	; 61
    4638:	de b7       	in	r29, 0x3e	; 62
    463a:	9d 83       	std	Y+5, r25	; 0x05
    463c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    463e:	8c 81       	ldd	r24, Y+4	; 0x04
    4640:	9d 81       	ldd	r25, Y+5	; 0x05
    4642:	9a 83       	std	Y+2, r25	; 0x02
    4644:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4646:	0f b6       	in	r0, 0x3f	; 63
    4648:	f8 94       	cli
    464a:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    464c:	e9 81       	ldd	r30, Y+1	; 0x01
    464e:	fa 81       	ldd	r31, Y+2	; 0x02
    4650:	93 8d       	ldd	r25, Z+27	; 0x1b
    4652:	e9 81       	ldd	r30, Y+1	; 0x01
    4654:	fa 81       	ldd	r31, Y+2	; 0x02
    4656:	82 8d       	ldd	r24, Z+26	; 0x1a
    4658:	29 2f       	mov	r18, r25
    465a:	28 1b       	sub	r18, r24
    465c:	82 2f       	mov	r24, r18
    465e:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    4660:	0f 90       	pop	r0
    4662:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4664:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4666:	0f 90       	pop	r0
    4668:	0f 90       	pop	r0
    466a:	0f 90       	pop	r0
    466c:	0f 90       	pop	r0
    466e:	0f 90       	pop	r0
    4670:	cf 91       	pop	r28
    4672:	df 91       	pop	r29
    4674:	08 95       	ret

00004676 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4676:	df 93       	push	r29
    4678:	cf 93       	push	r28
    467a:	00 d0       	rcall	.+0      	; 0x467c <uxQueueMessagesWaitingFromISR+0x6>
    467c:	0f 92       	push	r0
    467e:	cd b7       	in	r28, 0x3d	; 61
    4680:	de b7       	in	r29, 0x3e	; 62
    4682:	9b 83       	std	Y+3, r25	; 0x03
    4684:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4686:	ea 81       	ldd	r30, Y+2	; 0x02
    4688:	fb 81       	ldd	r31, Y+3	; 0x03
    468a:	82 8d       	ldd	r24, Z+26	; 0x1a
    468c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    468e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4690:	0f 90       	pop	r0
    4692:	0f 90       	pop	r0
    4694:	0f 90       	pop	r0
    4696:	cf 91       	pop	r28
    4698:	df 91       	pop	r29
    469a:	08 95       	ret

0000469c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    469c:	df 93       	push	r29
    469e:	cf 93       	push	r28
    46a0:	00 d0       	rcall	.+0      	; 0x46a2 <vQueueDelete+0x6>
    46a2:	00 d0       	rcall	.+0      	; 0x46a4 <vQueueDelete+0x8>
    46a4:	cd b7       	in	r28, 0x3d	; 61
    46a6:	de b7       	in	r29, 0x3e	; 62
    46a8:	9c 83       	std	Y+4, r25	; 0x04
    46aa:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    46ac:	8b 81       	ldd	r24, Y+3	; 0x03
    46ae:	9c 81       	ldd	r25, Y+4	; 0x04
    46b0:	9a 83       	std	Y+2, r25	; 0x02
    46b2:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    46b4:	e9 81       	ldd	r30, Y+1	; 0x01
    46b6:	fa 81       	ldd	r31, Y+2	; 0x02
    46b8:	80 81       	ld	r24, Z
    46ba:	91 81       	ldd	r25, Z+1	; 0x01
    46bc:	00 97       	sbiw	r24, 0x00	; 0
    46be:	31 f0       	breq	.+12     	; 0x46cc <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    46c0:	e9 81       	ldd	r30, Y+1	; 0x01
    46c2:	fa 81       	ldd	r31, Y+2	; 0x02
    46c4:	80 81       	ld	r24, Z
    46c6:	91 81       	ldd	r25, Z+1	; 0x01
    46c8:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
	}
	vPortFree( pxQueue );
    46cc:	89 81       	ldd	r24, Y+1	; 0x01
    46ce:	9a 81       	ldd	r25, Y+2	; 0x02
    46d0:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
}
    46d4:	0f 90       	pop	r0
    46d6:	0f 90       	pop	r0
    46d8:	0f 90       	pop	r0
    46da:	0f 90       	pop	r0
    46dc:	cf 91       	pop	r28
    46de:	df 91       	pop	r29
    46e0:	08 95       	ret

000046e2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    46e2:	df 93       	push	r29
    46e4:	cf 93       	push	r28
    46e6:	00 d0       	rcall	.+0      	; 0x46e8 <prvCopyDataToQueue+0x6>
    46e8:	00 d0       	rcall	.+0      	; 0x46ea <prvCopyDataToQueue+0x8>
    46ea:	00 d0       	rcall	.+0      	; 0x46ec <prvCopyDataToQueue+0xa>
    46ec:	cd b7       	in	r28, 0x3d	; 61
    46ee:	de b7       	in	r29, 0x3e	; 62
    46f0:	9b 83       	std	Y+3, r25	; 0x03
    46f2:	8a 83       	std	Y+2, r24	; 0x02
    46f4:	7d 83       	std	Y+5, r23	; 0x05
    46f6:	6c 83       	std	Y+4, r22	; 0x04
    46f8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    46fa:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    46fc:	ea 81       	ldd	r30, Y+2	; 0x02
    46fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4700:	84 8d       	ldd	r24, Z+28	; 0x1c
    4702:	88 23       	and	r24, r24
    4704:	99 f4       	brne	.+38     	; 0x472c <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4706:	ea 81       	ldd	r30, Y+2	; 0x02
    4708:	fb 81       	ldd	r31, Y+3	; 0x03
    470a:	80 81       	ld	r24, Z
    470c:	91 81       	ldd	r25, Z+1	; 0x01
    470e:	00 97       	sbiw	r24, 0x00	; 0
    4710:	09 f0       	breq	.+2      	; 0x4714 <prvCopyDataToQueue+0x32>
    4712:	8f c0       	rjmp	.+286    	; 0x4832 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    4714:	ea 81       	ldd	r30, Y+2	; 0x02
    4716:	fb 81       	ldd	r31, Y+3	; 0x03
    4718:	82 81       	ldd	r24, Z+2	; 0x02
    471a:	93 81       	ldd	r25, Z+3	; 0x03
    471c:	0e 94 fc 31 	call	0x63f8	; 0x63f8 <xTaskPriorityDisinherit>
    4720:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    4722:	ea 81       	ldd	r30, Y+2	; 0x02
    4724:	fb 81       	ldd	r31, Y+3	; 0x03
    4726:	13 82       	std	Z+3, r1	; 0x03
    4728:	12 82       	std	Z+2, r1	; 0x02
    472a:	83 c0       	rjmp	.+262    	; 0x4832 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    472c:	8e 81       	ldd	r24, Y+6	; 0x06
    472e:	88 23       	and	r24, r24
    4730:	99 f5       	brne	.+102    	; 0x4798 <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    4732:	ea 81       	ldd	r30, Y+2	; 0x02
    4734:	fb 81       	ldd	r31, Y+3	; 0x03
    4736:	64 81       	ldd	r22, Z+4	; 0x04
    4738:	75 81       	ldd	r23, Z+5	; 0x05
    473a:	ea 81       	ldd	r30, Y+2	; 0x02
    473c:	fb 81       	ldd	r31, Y+3	; 0x03
    473e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4740:	48 2f       	mov	r20, r24
    4742:	50 e0       	ldi	r21, 0x00	; 0
    4744:	2c 81       	ldd	r18, Y+4	; 0x04
    4746:	3d 81       	ldd	r19, Y+5	; 0x05
    4748:	cb 01       	movw	r24, r22
    474a:	b9 01       	movw	r22, r18
    474c:	0e 94 cd 33 	call	0x679a	; 0x679a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4750:	ea 81       	ldd	r30, Y+2	; 0x02
    4752:	fb 81       	ldd	r31, Y+3	; 0x03
    4754:	24 81       	ldd	r18, Z+4	; 0x04
    4756:	35 81       	ldd	r19, Z+5	; 0x05
    4758:	ea 81       	ldd	r30, Y+2	; 0x02
    475a:	fb 81       	ldd	r31, Y+3	; 0x03
    475c:	84 8d       	ldd	r24, Z+28	; 0x1c
    475e:	88 2f       	mov	r24, r24
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	82 0f       	add	r24, r18
    4764:	93 1f       	adc	r25, r19
    4766:	ea 81       	ldd	r30, Y+2	; 0x02
    4768:	fb 81       	ldd	r31, Y+3	; 0x03
    476a:	95 83       	std	Z+5, r25	; 0x05
    476c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    476e:	ea 81       	ldd	r30, Y+2	; 0x02
    4770:	fb 81       	ldd	r31, Y+3	; 0x03
    4772:	24 81       	ldd	r18, Z+4	; 0x04
    4774:	35 81       	ldd	r19, Z+5	; 0x05
    4776:	ea 81       	ldd	r30, Y+2	; 0x02
    4778:	fb 81       	ldd	r31, Y+3	; 0x03
    477a:	82 81       	ldd	r24, Z+2	; 0x02
    477c:	93 81       	ldd	r25, Z+3	; 0x03
    477e:	28 17       	cp	r18, r24
    4780:	39 07       	cpc	r19, r25
    4782:	08 f4       	brcc	.+2      	; 0x4786 <prvCopyDataToQueue+0xa4>
    4784:	56 c0       	rjmp	.+172    	; 0x4832 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4786:	ea 81       	ldd	r30, Y+2	; 0x02
    4788:	fb 81       	ldd	r31, Y+3	; 0x03
    478a:	80 81       	ld	r24, Z
    478c:	91 81       	ldd	r25, Z+1	; 0x01
    478e:	ea 81       	ldd	r30, Y+2	; 0x02
    4790:	fb 81       	ldd	r31, Y+3	; 0x03
    4792:	95 83       	std	Z+5, r25	; 0x05
    4794:	84 83       	std	Z+4, r24	; 0x04
    4796:	4d c0       	rjmp	.+154    	; 0x4832 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4798:	ea 81       	ldd	r30, Y+2	; 0x02
    479a:	fb 81       	ldd	r31, Y+3	; 0x03
    479c:	66 81       	ldd	r22, Z+6	; 0x06
    479e:	77 81       	ldd	r23, Z+7	; 0x07
    47a0:	ea 81       	ldd	r30, Y+2	; 0x02
    47a2:	fb 81       	ldd	r31, Y+3	; 0x03
    47a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    47a6:	48 2f       	mov	r20, r24
    47a8:	50 e0       	ldi	r21, 0x00	; 0
    47aa:	2c 81       	ldd	r18, Y+4	; 0x04
    47ac:	3d 81       	ldd	r19, Y+5	; 0x05
    47ae:	cb 01       	movw	r24, r22
    47b0:	b9 01       	movw	r22, r18
    47b2:	0e 94 cd 33 	call	0x679a	; 0x679a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    47b6:	ea 81       	ldd	r30, Y+2	; 0x02
    47b8:	fb 81       	ldd	r31, Y+3	; 0x03
    47ba:	26 81       	ldd	r18, Z+6	; 0x06
    47bc:	37 81       	ldd	r19, Z+7	; 0x07
    47be:	ea 81       	ldd	r30, Y+2	; 0x02
    47c0:	fb 81       	ldd	r31, Y+3	; 0x03
    47c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    47c4:	88 2f       	mov	r24, r24
    47c6:	90 e0       	ldi	r25, 0x00	; 0
    47c8:	90 95       	com	r25
    47ca:	81 95       	neg	r24
    47cc:	9f 4f       	sbci	r25, 0xFF	; 255
    47ce:	82 0f       	add	r24, r18
    47d0:	93 1f       	adc	r25, r19
    47d2:	ea 81       	ldd	r30, Y+2	; 0x02
    47d4:	fb 81       	ldd	r31, Y+3	; 0x03
    47d6:	97 83       	std	Z+7, r25	; 0x07
    47d8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    47da:	ea 81       	ldd	r30, Y+2	; 0x02
    47dc:	fb 81       	ldd	r31, Y+3	; 0x03
    47de:	26 81       	ldd	r18, Z+6	; 0x06
    47e0:	37 81       	ldd	r19, Z+7	; 0x07
    47e2:	ea 81       	ldd	r30, Y+2	; 0x02
    47e4:	fb 81       	ldd	r31, Y+3	; 0x03
    47e6:	80 81       	ld	r24, Z
    47e8:	91 81       	ldd	r25, Z+1	; 0x01
    47ea:	28 17       	cp	r18, r24
    47ec:	39 07       	cpc	r19, r25
    47ee:	90 f4       	brcc	.+36     	; 0x4814 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    47f0:	ea 81       	ldd	r30, Y+2	; 0x02
    47f2:	fb 81       	ldd	r31, Y+3	; 0x03
    47f4:	22 81       	ldd	r18, Z+2	; 0x02
    47f6:	33 81       	ldd	r19, Z+3	; 0x03
    47f8:	ea 81       	ldd	r30, Y+2	; 0x02
    47fa:	fb 81       	ldd	r31, Y+3	; 0x03
    47fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    47fe:	88 2f       	mov	r24, r24
    4800:	90 e0       	ldi	r25, 0x00	; 0
    4802:	90 95       	com	r25
    4804:	81 95       	neg	r24
    4806:	9f 4f       	sbci	r25, 0xFF	; 255
    4808:	82 0f       	add	r24, r18
    480a:	93 1f       	adc	r25, r19
    480c:	ea 81       	ldd	r30, Y+2	; 0x02
    480e:	fb 81       	ldd	r31, Y+3	; 0x03
    4810:	97 83       	std	Z+7, r25	; 0x07
    4812:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    4814:	8e 81       	ldd	r24, Y+6	; 0x06
    4816:	82 30       	cpi	r24, 0x02	; 2
    4818:	61 f4       	brne	.+24     	; 0x4832 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    481a:	ea 81       	ldd	r30, Y+2	; 0x02
    481c:	fb 81       	ldd	r31, Y+3	; 0x03
    481e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4820:	88 23       	and	r24, r24
    4822:	39 f0       	breq	.+14     	; 0x4832 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    4824:	ea 81       	ldd	r30, Y+2	; 0x02
    4826:	fb 81       	ldd	r31, Y+3	; 0x03
    4828:	82 8d       	ldd	r24, Z+26	; 0x1a
    482a:	81 50       	subi	r24, 0x01	; 1
    482c:	ea 81       	ldd	r30, Y+2	; 0x02
    482e:	fb 81       	ldd	r31, Y+3	; 0x03
    4830:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4832:	ea 81       	ldd	r30, Y+2	; 0x02
    4834:	fb 81       	ldd	r31, Y+3	; 0x03
    4836:	82 8d       	ldd	r24, Z+26	; 0x1a
    4838:	8f 5f       	subi	r24, 0xFF	; 255
    483a:	ea 81       	ldd	r30, Y+2	; 0x02
    483c:	fb 81       	ldd	r31, Y+3	; 0x03
    483e:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    4840:	89 81       	ldd	r24, Y+1	; 0x01
}
    4842:	26 96       	adiw	r28, 0x06	; 6
    4844:	0f b6       	in	r0, 0x3f	; 63
    4846:	f8 94       	cli
    4848:	de bf       	out	0x3e, r29	; 62
    484a:	0f be       	out	0x3f, r0	; 63
    484c:	cd bf       	out	0x3d, r28	; 61
    484e:	cf 91       	pop	r28
    4850:	df 91       	pop	r29
    4852:	08 95       	ret

00004854 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    4854:	df 93       	push	r29
    4856:	cf 93       	push	r28
    4858:	00 d0       	rcall	.+0      	; 0x485a <prvCopyDataFromQueue+0x6>
    485a:	00 d0       	rcall	.+0      	; 0x485c <prvCopyDataFromQueue+0x8>
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	9a 83       	std	Y+2, r25	; 0x02
    4862:	89 83       	std	Y+1, r24	; 0x01
    4864:	7c 83       	std	Y+4, r23	; 0x04
    4866:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    4868:	e9 81       	ldd	r30, Y+1	; 0x01
    486a:	fa 81       	ldd	r31, Y+2	; 0x02
    486c:	84 8d       	ldd	r24, Z+28	; 0x1c
    486e:	88 23       	and	r24, r24
    4870:	89 f1       	breq	.+98     	; 0x48d4 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4872:	e9 81       	ldd	r30, Y+1	; 0x01
    4874:	fa 81       	ldd	r31, Y+2	; 0x02
    4876:	26 81       	ldd	r18, Z+6	; 0x06
    4878:	37 81       	ldd	r19, Z+7	; 0x07
    487a:	e9 81       	ldd	r30, Y+1	; 0x01
    487c:	fa 81       	ldd	r31, Y+2	; 0x02
    487e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4880:	88 2f       	mov	r24, r24
    4882:	90 e0       	ldi	r25, 0x00	; 0
    4884:	82 0f       	add	r24, r18
    4886:	93 1f       	adc	r25, r19
    4888:	e9 81       	ldd	r30, Y+1	; 0x01
    488a:	fa 81       	ldd	r31, Y+2	; 0x02
    488c:	97 83       	std	Z+7, r25	; 0x07
    488e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4890:	e9 81       	ldd	r30, Y+1	; 0x01
    4892:	fa 81       	ldd	r31, Y+2	; 0x02
    4894:	26 81       	ldd	r18, Z+6	; 0x06
    4896:	37 81       	ldd	r19, Z+7	; 0x07
    4898:	e9 81       	ldd	r30, Y+1	; 0x01
    489a:	fa 81       	ldd	r31, Y+2	; 0x02
    489c:	82 81       	ldd	r24, Z+2	; 0x02
    489e:	93 81       	ldd	r25, Z+3	; 0x03
    48a0:	28 17       	cp	r18, r24
    48a2:	39 07       	cpc	r19, r25
    48a4:	40 f0       	brcs	.+16     	; 0x48b6 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    48a6:	e9 81       	ldd	r30, Y+1	; 0x01
    48a8:	fa 81       	ldd	r31, Y+2	; 0x02
    48aa:	80 81       	ld	r24, Z
    48ac:	91 81       	ldd	r25, Z+1	; 0x01
    48ae:	e9 81       	ldd	r30, Y+1	; 0x01
    48b0:	fa 81       	ldd	r31, Y+2	; 0x02
    48b2:	97 83       	std	Z+7, r25	; 0x07
    48b4:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    48b6:	e9 81       	ldd	r30, Y+1	; 0x01
    48b8:	fa 81       	ldd	r31, Y+2	; 0x02
    48ba:	46 81       	ldd	r20, Z+6	; 0x06
    48bc:	57 81       	ldd	r21, Z+7	; 0x07
    48be:	e9 81       	ldd	r30, Y+1	; 0x01
    48c0:	fa 81       	ldd	r31, Y+2	; 0x02
    48c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    48c4:	28 2f       	mov	r18, r24
    48c6:	30 e0       	ldi	r19, 0x00	; 0
    48c8:	8b 81       	ldd	r24, Y+3	; 0x03
    48ca:	9c 81       	ldd	r25, Y+4	; 0x04
    48cc:	ba 01       	movw	r22, r20
    48ce:	a9 01       	movw	r20, r18
    48d0:	0e 94 cd 33 	call	0x679a	; 0x679a <memcpy>
	}
}
    48d4:	0f 90       	pop	r0
    48d6:	0f 90       	pop	r0
    48d8:	0f 90       	pop	r0
    48da:	0f 90       	pop	r0
    48dc:	cf 91       	pop	r28
    48de:	df 91       	pop	r29
    48e0:	08 95       	ret

000048e2 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    48e2:	df 93       	push	r29
    48e4:	cf 93       	push	r28
    48e6:	00 d0       	rcall	.+0      	; 0x48e8 <prvUnlockQueue+0x6>
    48e8:	cd b7       	in	r28, 0x3d	; 61
    48ea:	de b7       	in	r29, 0x3e	; 62
    48ec:	9a 83       	std	Y+2, r25	; 0x02
    48ee:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    48f0:	0f b6       	in	r0, 0x3f	; 63
    48f2:	f8 94       	cli
    48f4:	0f 92       	push	r0
    48f6:	15 c0       	rjmp	.+42     	; 0x4922 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    48f8:	e9 81       	ldd	r30, Y+1	; 0x01
    48fa:	fa 81       	ldd	r31, Y+2	; 0x02
    48fc:	81 89       	ldd	r24, Z+17	; 0x11
    48fe:	88 23       	and	r24, r24
    4900:	a9 f0       	breq	.+42     	; 0x492c <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4902:	89 81       	ldd	r24, Y+1	; 0x01
    4904:	9a 81       	ldd	r25, Y+2	; 0x02
    4906:	41 96       	adiw	r24, 0x11	; 17
    4908:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    490c:	88 23       	and	r24, r24
    490e:	11 f0       	breq	.+4      	; 0x4914 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    4910:	0e 94 7d 2f 	call	0x5efa	; 0x5efa <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4914:	e9 81       	ldd	r30, Y+1	; 0x01
    4916:	fa 81       	ldd	r31, Y+2	; 0x02
    4918:	86 8d       	ldd	r24, Z+30	; 0x1e
    491a:	81 50       	subi	r24, 0x01	; 1
    491c:	e9 81       	ldd	r30, Y+1	; 0x01
    491e:	fa 81       	ldd	r31, Y+2	; 0x02
    4920:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4922:	e9 81       	ldd	r30, Y+1	; 0x01
    4924:	fa 81       	ldd	r31, Y+2	; 0x02
    4926:	86 8d       	ldd	r24, Z+30	; 0x1e
    4928:	18 16       	cp	r1, r24
    492a:	34 f3       	brlt	.-52     	; 0x48f8 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    492c:	e9 81       	ldd	r30, Y+1	; 0x01
    492e:	fa 81       	ldd	r31, Y+2	; 0x02
    4930:	8f ef       	ldi	r24, 0xFF	; 255
    4932:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4934:	0f 90       	pop	r0
    4936:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4938:	0f b6       	in	r0, 0x3f	; 63
    493a:	f8 94       	cli
    493c:	0f 92       	push	r0
    493e:	15 c0       	rjmp	.+42     	; 0x496a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4940:	e9 81       	ldd	r30, Y+1	; 0x01
    4942:	fa 81       	ldd	r31, Y+2	; 0x02
    4944:	80 85       	ldd	r24, Z+8	; 0x08
    4946:	88 23       	and	r24, r24
    4948:	a9 f0       	breq	.+42     	; 0x4974 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    494a:	89 81       	ldd	r24, Y+1	; 0x01
    494c:	9a 81       	ldd	r25, Y+2	; 0x02
    494e:	08 96       	adiw	r24, 0x08	; 8
    4950:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <xTaskRemoveFromEventList>
    4954:	88 23       	and	r24, r24
    4956:	11 f0       	breq	.+4      	; 0x495c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4958:	0e 94 7d 2f 	call	0x5efa	; 0x5efa <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    495c:	e9 81       	ldd	r30, Y+1	; 0x01
    495e:	fa 81       	ldd	r31, Y+2	; 0x02
    4960:	85 8d       	ldd	r24, Z+29	; 0x1d
    4962:	81 50       	subi	r24, 0x01	; 1
    4964:	e9 81       	ldd	r30, Y+1	; 0x01
    4966:	fa 81       	ldd	r31, Y+2	; 0x02
    4968:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    496a:	e9 81       	ldd	r30, Y+1	; 0x01
    496c:	fa 81       	ldd	r31, Y+2	; 0x02
    496e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4970:	18 16       	cp	r1, r24
    4972:	34 f3       	brlt	.-52     	; 0x4940 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4974:	e9 81       	ldd	r30, Y+1	; 0x01
    4976:	fa 81       	ldd	r31, Y+2	; 0x02
    4978:	8f ef       	ldi	r24, 0xFF	; 255
    497a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    497c:	0f 90       	pop	r0
    497e:	0f be       	out	0x3f, r0	; 63
}
    4980:	0f 90       	pop	r0
    4982:	0f 90       	pop	r0
    4984:	cf 91       	pop	r28
    4986:	df 91       	pop	r29
    4988:	08 95       	ret

0000498a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    498a:	df 93       	push	r29
    498c:	cf 93       	push	r28
    498e:	00 d0       	rcall	.+0      	; 0x4990 <prvIsQueueEmpty+0x6>
    4990:	0f 92       	push	r0
    4992:	cd b7       	in	r28, 0x3d	; 61
    4994:	de b7       	in	r29, 0x3e	; 62
    4996:	9b 83       	std	Y+3, r25	; 0x03
    4998:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    499a:	0f b6       	in	r0, 0x3f	; 63
    499c:	f8 94       	cli
    499e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    49a0:	ea 81       	ldd	r30, Y+2	; 0x02
    49a2:	fb 81       	ldd	r31, Y+3	; 0x03
    49a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    49a6:	88 23       	and	r24, r24
    49a8:	19 f4       	brne	.+6      	; 0x49b0 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    49aa:	81 e0       	ldi	r24, 0x01	; 1
    49ac:	89 83       	std	Y+1, r24	; 0x01
    49ae:	01 c0       	rjmp	.+2      	; 0x49b2 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    49b0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    49b2:	0f 90       	pop	r0
    49b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    49b8:	0f 90       	pop	r0
    49ba:	0f 90       	pop	r0
    49bc:	0f 90       	pop	r0
    49be:	cf 91       	pop	r28
    49c0:	df 91       	pop	r29
    49c2:	08 95       	ret

000049c4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    49c4:	df 93       	push	r29
    49c6:	cf 93       	push	r28
    49c8:	00 d0       	rcall	.+0      	; 0x49ca <xQueueIsQueueEmptyFromISR+0x6>
    49ca:	0f 92       	push	r0
    49cc:	cd b7       	in	r28, 0x3d	; 61
    49ce:	de b7       	in	r29, 0x3e	; 62
    49d0:	9b 83       	std	Y+3, r25	; 0x03
    49d2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    49d4:	ea 81       	ldd	r30, Y+2	; 0x02
    49d6:	fb 81       	ldd	r31, Y+3	; 0x03
    49d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    49da:	88 23       	and	r24, r24
    49dc:	19 f4       	brne	.+6      	; 0x49e4 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    49de:	81 e0       	ldi	r24, 0x01	; 1
    49e0:	89 83       	std	Y+1, r24	; 0x01
    49e2:	01 c0       	rjmp	.+2      	; 0x49e6 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    49e4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    49e6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    49e8:	0f 90       	pop	r0
    49ea:	0f 90       	pop	r0
    49ec:	0f 90       	pop	r0
    49ee:	cf 91       	pop	r28
    49f0:	df 91       	pop	r29
    49f2:	08 95       	ret

000049f4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    49f4:	df 93       	push	r29
    49f6:	cf 93       	push	r28
    49f8:	00 d0       	rcall	.+0      	; 0x49fa <prvIsQueueFull+0x6>
    49fa:	0f 92       	push	r0
    49fc:	cd b7       	in	r28, 0x3d	; 61
    49fe:	de b7       	in	r29, 0x3e	; 62
    4a00:	9b 83       	std	Y+3, r25	; 0x03
    4a02:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4a04:	0f b6       	in	r0, 0x3f	; 63
    4a06:	f8 94       	cli
    4a08:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4a0a:	ea 81       	ldd	r30, Y+2	; 0x02
    4a0c:	fb 81       	ldd	r31, Y+3	; 0x03
    4a0e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a10:	ea 81       	ldd	r30, Y+2	; 0x02
    4a12:	fb 81       	ldd	r31, Y+3	; 0x03
    4a14:	83 8d       	ldd	r24, Z+27	; 0x1b
    4a16:	98 17       	cp	r25, r24
    4a18:	19 f4       	brne	.+6      	; 0x4a20 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    4a1a:	81 e0       	ldi	r24, 0x01	; 1
    4a1c:	89 83       	std	Y+1, r24	; 0x01
    4a1e:	01 c0       	rjmp	.+2      	; 0x4a22 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    4a20:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4a22:	0f 90       	pop	r0
    4a24:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4a26:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a28:	0f 90       	pop	r0
    4a2a:	0f 90       	pop	r0
    4a2c:	0f 90       	pop	r0
    4a2e:	cf 91       	pop	r28
    4a30:	df 91       	pop	r29
    4a32:	08 95       	ret

00004a34 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4a34:	df 93       	push	r29
    4a36:	cf 93       	push	r28
    4a38:	00 d0       	rcall	.+0      	; 0x4a3a <xQueueIsQueueFullFromISR+0x6>
    4a3a:	0f 92       	push	r0
    4a3c:	cd b7       	in	r28, 0x3d	; 61
    4a3e:	de b7       	in	r29, 0x3e	; 62
    4a40:	9b 83       	std	Y+3, r25	; 0x03
    4a42:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    4a44:	ea 81       	ldd	r30, Y+2	; 0x02
    4a46:	fb 81       	ldd	r31, Y+3	; 0x03
    4a48:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a4a:	ea 81       	ldd	r30, Y+2	; 0x02
    4a4c:	fb 81       	ldd	r31, Y+3	; 0x03
    4a4e:	83 8d       	ldd	r24, Z+27	; 0x1b
    4a50:	98 17       	cp	r25, r24
    4a52:	19 f4       	brne	.+6      	; 0x4a5a <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    4a54:	81 e0       	ldi	r24, 0x01	; 1
    4a56:	89 83       	std	Y+1, r24	; 0x01
    4a58:	01 c0       	rjmp	.+2      	; 0x4a5c <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    4a5a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4a5c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4a5e:	0f 90       	pop	r0
    4a60:	0f 90       	pop	r0
    4a62:	0f 90       	pop	r0
    4a64:	cf 91       	pop	r28
    4a66:	df 91       	pop	r29
    4a68:	08 95       	ret

00004a6a <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    4a6a:	df 93       	push	r29
    4a6c:	cf 93       	push	r28
    4a6e:	cd b7       	in	r28, 0x3d	; 61
    4a70:	de b7       	in	r29, 0x3e	; 62
    4a72:	2a 97       	sbiw	r28, 0x0a	; 10
    4a74:	0f b6       	in	r0, 0x3f	; 63
    4a76:	f8 94       	cli
    4a78:	de bf       	out	0x3e, r29	; 62
    4a7a:	0f be       	out	0x3f, r0	; 63
    4a7c:	cd bf       	out	0x3d, r28	; 61
    4a7e:	9d 83       	std	Y+5, r25	; 0x05
    4a80:	8c 83       	std	Y+4, r24	; 0x04
    4a82:	7f 83       	std	Y+7, r23	; 0x07
    4a84:	6e 83       	std	Y+6, r22	; 0x06
    4a86:	59 87       	std	Y+9, r21	; 0x09
    4a88:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    4a8e:	9a 83       	std	Y+2, r25	; 0x02
    4a90:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    4a92:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4a94:	89 81       	ldd	r24, Y+1	; 0x01
    4a96:	9a 81       	ldd	r25, Y+2	; 0x02
    4a98:	0e 94 fa 24 	call	0x49f4	; 0x49f4 <prvIsQueueFull>
    4a9c:	88 23       	and	r24, r24
    4a9e:	a9 f0       	breq	.+42     	; 0x4aca <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    4aa0:	88 85       	ldd	r24, Y+8	; 0x08
    4aa2:	99 85       	ldd	r25, Y+9	; 0x09
    4aa4:	00 97       	sbiw	r24, 0x00	; 0
    4aa6:	71 f0       	breq	.+28     	; 0x4ac4 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    4aa8:	89 81       	ldd	r24, Y+1	; 0x01
    4aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    4aac:	9c 01       	movw	r18, r24
    4aae:	28 5f       	subi	r18, 0xF8	; 248
    4ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ab2:	88 85       	ldd	r24, Y+8	; 0x08
    4ab4:	99 85       	ldd	r25, Y+9	; 0x09
    4ab6:	b9 01       	movw	r22, r18
    4ab8:	0e 94 52 14 	call	0x28a4	; 0x28a4 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    4abc:	78 94       	sei
					return errQUEUE_BLOCKED;
    4abe:	8c ef       	ldi	r24, 0xFC	; 252
    4ac0:	8a 87       	std	Y+10, r24	; 0x0a
    4ac2:	2a c0       	rjmp	.+84     	; 0x4b18 <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    4ac4:	78 94       	sei
					return errQUEUE_FULL;
    4ac6:	1a 86       	std	Y+10, r1	; 0x0a
    4ac8:	27 c0       	rjmp	.+78     	; 0x4b18 <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    4aca:	78 94       	sei

		portDISABLE_INTERRUPTS();
    4acc:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4ace:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad2:	92 8d       	ldd	r25, Z+26	; 0x1a
    4ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad8:	83 8d       	ldd	r24, Z+27	; 0x1b
    4ada:	98 17       	cp	r25, r24
    4adc:	c8 f4       	brcc	.+50     	; 0x4b10 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae2:	2e 81       	ldd	r18, Y+6	; 0x06
    4ae4:	3f 81       	ldd	r19, Y+7	; 0x07
    4ae6:	b9 01       	movw	r22, r18
    4ae8:	40 e0       	ldi	r20, 0x00	; 0
    4aea:	0e 94 71 23 	call	0x46e2	; 0x46e2 <prvCopyDataToQueue>
				xReturn = pdPASS;
    4aee:	81 e0       	ldi	r24, 0x01	; 1
    4af0:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4af2:	e9 81       	ldd	r30, Y+1	; 0x01
    4af4:	fa 81       	ldd	r31, Y+2	; 0x02
    4af6:	81 89       	ldd	r24, Z+17	; 0x11
    4af8:	88 23       	and	r24, r24
    4afa:	59 f0       	breq	.+22     	; 0x4b12 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4afc:	89 81       	ldd	r24, Y+1	; 0x01
    4afe:	9a 81       	ldd	r25, Y+2	; 0x02
    4b00:	41 96       	adiw	r24, 0x11	; 17
    4b02:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xCoRoutineRemoveFromEventList>
    4b06:	88 23       	and	r24, r24
    4b08:	21 f0       	breq	.+8      	; 0x4b12 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    4b0a:	8b ef       	ldi	r24, 0xFB	; 251
    4b0c:	8b 83       	std	Y+3, r24	; 0x03
    4b0e:	01 c0       	rjmp	.+2      	; 0x4b12 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    4b10:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4b12:	78 94       	sei

		return xReturn;
    4b14:	8b 81       	ldd	r24, Y+3	; 0x03
    4b16:	8a 87       	std	Y+10, r24	; 0x0a
    4b18:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    4b1a:	2a 96       	adiw	r28, 0x0a	; 10
    4b1c:	0f b6       	in	r0, 0x3f	; 63
    4b1e:	f8 94       	cli
    4b20:	de bf       	out	0x3e, r29	; 62
    4b22:	0f be       	out	0x3f, r0	; 63
    4b24:	cd bf       	out	0x3d, r28	; 61
    4b26:	cf 91       	pop	r28
    4b28:	df 91       	pop	r29
    4b2a:	08 95       	ret

00004b2c <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    4b2c:	df 93       	push	r29
    4b2e:	cf 93       	push	r28
    4b30:	cd b7       	in	r28, 0x3d	; 61
    4b32:	de b7       	in	r29, 0x3e	; 62
    4b34:	2a 97       	sbiw	r28, 0x0a	; 10
    4b36:	0f b6       	in	r0, 0x3f	; 63
    4b38:	f8 94       	cli
    4b3a:	de bf       	out	0x3e, r29	; 62
    4b3c:	0f be       	out	0x3f, r0	; 63
    4b3e:	cd bf       	out	0x3d, r28	; 61
    4b40:	9d 83       	std	Y+5, r25	; 0x05
    4b42:	8c 83       	std	Y+4, r24	; 0x04
    4b44:	7f 83       	std	Y+7, r23	; 0x07
    4b46:	6e 83       	std	Y+6, r22	; 0x06
    4b48:	59 87       	std	Y+9, r21	; 0x09
    4b4a:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4b4c:	8c 81       	ldd	r24, Y+4	; 0x04
    4b4e:	9d 81       	ldd	r25, Y+5	; 0x05
    4b50:	9a 83       	std	Y+2, r25	; 0x02
    4b52:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    4b54:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4b56:	e9 81       	ldd	r30, Y+1	; 0x01
    4b58:	fa 81       	ldd	r31, Y+2	; 0x02
    4b5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b5c:	88 23       	and	r24, r24
    4b5e:	a9 f4       	brne	.+42     	; 0x4b8a <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    4b60:	88 85       	ldd	r24, Y+8	; 0x08
    4b62:	99 85       	ldd	r25, Y+9	; 0x09
    4b64:	00 97       	sbiw	r24, 0x00	; 0
    4b66:	71 f0       	breq	.+28     	; 0x4b84 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    4b68:	89 81       	ldd	r24, Y+1	; 0x01
    4b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b6c:	9c 01       	movw	r18, r24
    4b6e:	2f 5e       	subi	r18, 0xEF	; 239
    4b70:	3f 4f       	sbci	r19, 0xFF	; 255
    4b72:	88 85       	ldd	r24, Y+8	; 0x08
    4b74:	99 85       	ldd	r25, Y+9	; 0x09
    4b76:	b9 01       	movw	r22, r18
    4b78:	0e 94 52 14 	call	0x28a4	; 0x28a4 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    4b7c:	78 94       	sei
					return errQUEUE_BLOCKED;
    4b7e:	8c ef       	ldi	r24, 0xFC	; 252
    4b80:	8a 87       	std	Y+10, r24	; 0x0a
    4b82:	58 c0       	rjmp	.+176    	; 0x4c34 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    4b84:	78 94       	sei
					return errQUEUE_FULL;
    4b86:	1a 86       	std	Y+10, r1	; 0x0a
    4b88:	55 c0       	rjmp	.+170    	; 0x4c34 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    4b8a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    4b8c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b90:	fa 81       	ldd	r31, Y+2	; 0x02
    4b92:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b94:	88 23       	and	r24, r24
    4b96:	09 f4       	brne	.+2      	; 0x4b9a <xQueueCRReceive+0x6e>
    4b98:	49 c0       	rjmp	.+146    	; 0x4c2c <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b9e:	26 81       	ldd	r18, Z+6	; 0x06
    4ba0:	37 81       	ldd	r19, Z+7	; 0x07
    4ba2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ba4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ba6:	84 8d       	ldd	r24, Z+28	; 0x1c
    4ba8:	88 2f       	mov	r24, r24
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	82 0f       	add	r24, r18
    4bae:	93 1f       	adc	r25, r19
    4bb0:	e9 81       	ldd	r30, Y+1	; 0x01
    4bb2:	fa 81       	ldd	r31, Y+2	; 0x02
    4bb4:	97 83       	std	Z+7, r25	; 0x07
    4bb6:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    4bb8:	e9 81       	ldd	r30, Y+1	; 0x01
    4bba:	fa 81       	ldd	r31, Y+2	; 0x02
    4bbc:	26 81       	ldd	r18, Z+6	; 0x06
    4bbe:	37 81       	ldd	r19, Z+7	; 0x07
    4bc0:	e9 81       	ldd	r30, Y+1	; 0x01
    4bc2:	fa 81       	ldd	r31, Y+2	; 0x02
    4bc4:	82 81       	ldd	r24, Z+2	; 0x02
    4bc6:	93 81       	ldd	r25, Z+3	; 0x03
    4bc8:	28 17       	cp	r18, r24
    4bca:	39 07       	cpc	r19, r25
    4bcc:	40 f0       	brcs	.+16     	; 0x4bde <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4bce:	e9 81       	ldd	r30, Y+1	; 0x01
    4bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    4bd2:	80 81       	ld	r24, Z
    4bd4:	91 81       	ldd	r25, Z+1	; 0x01
    4bd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4bd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4bda:	97 83       	std	Z+7, r25	; 0x07
    4bdc:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    4bde:	e9 81       	ldd	r30, Y+1	; 0x01
    4be0:	fa 81       	ldd	r31, Y+2	; 0x02
    4be2:	82 8d       	ldd	r24, Z+26	; 0x1a
    4be4:	81 50       	subi	r24, 0x01	; 1
    4be6:	e9 81       	ldd	r30, Y+1	; 0x01
    4be8:	fa 81       	ldd	r31, Y+2	; 0x02
    4bea:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4bec:	e9 81       	ldd	r30, Y+1	; 0x01
    4bee:	fa 81       	ldd	r31, Y+2	; 0x02
    4bf0:	46 81       	ldd	r20, Z+6	; 0x06
    4bf2:	57 81       	ldd	r21, Z+7	; 0x07
    4bf4:	e9 81       	ldd	r30, Y+1	; 0x01
    4bf6:	fa 81       	ldd	r31, Y+2	; 0x02
    4bf8:	84 8d       	ldd	r24, Z+28	; 0x1c
    4bfa:	28 2f       	mov	r18, r24
    4bfc:	30 e0       	ldi	r19, 0x00	; 0
    4bfe:	8e 81       	ldd	r24, Y+6	; 0x06
    4c00:	9f 81       	ldd	r25, Y+7	; 0x07
    4c02:	ba 01       	movw	r22, r20
    4c04:	a9 01       	movw	r20, r18
    4c06:	0e 94 cd 33 	call	0x679a	; 0x679a <memcpy>

				xReturn = pdPASS;
    4c0a:	81 e0       	ldi	r24, 0x01	; 1
    4c0c:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c10:	fa 81       	ldd	r31, Y+2	; 0x02
    4c12:	80 85       	ldd	r24, Z+8	; 0x08
    4c14:	88 23       	and	r24, r24
    4c16:	59 f0       	breq	.+22     	; 0x4c2e <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4c18:	89 81       	ldd	r24, Y+1	; 0x01
    4c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c1c:	08 96       	adiw	r24, 0x08	; 8
    4c1e:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xCoRoutineRemoveFromEventList>
    4c22:	88 23       	and	r24, r24
    4c24:	21 f0       	breq	.+8      	; 0x4c2e <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    4c26:	8b ef       	ldi	r24, 0xFB	; 251
    4c28:	8b 83       	std	Y+3, r24	; 0x03
    4c2a:	01 c0       	rjmp	.+2      	; 0x4c2e <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    4c2c:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4c2e:	78 94       	sei

		return xReturn;
    4c30:	8b 81       	ldd	r24, Y+3	; 0x03
    4c32:	8a 87       	std	Y+10, r24	; 0x0a
    4c34:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    4c36:	2a 96       	adiw	r28, 0x0a	; 10
    4c38:	0f b6       	in	r0, 0x3f	; 63
    4c3a:	f8 94       	cli
    4c3c:	de bf       	out	0x3e, r29	; 62
    4c3e:	0f be       	out	0x3f, r0	; 63
    4c40:	cd bf       	out	0x3d, r28	; 61
    4c42:	cf 91       	pop	r28
    4c44:	df 91       	pop	r29
    4c46:	08 95       	ret

00004c48 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    4c48:	df 93       	push	r29
    4c4a:	cf 93       	push	r28
    4c4c:	cd b7       	in	r28, 0x3d	; 61
    4c4e:	de b7       	in	r29, 0x3e	; 62
    4c50:	28 97       	sbiw	r28, 0x08	; 8
    4c52:	0f b6       	in	r0, 0x3f	; 63
    4c54:	f8 94       	cli
    4c56:	de bf       	out	0x3e, r29	; 62
    4c58:	0f be       	out	0x3f, r0	; 63
    4c5a:	cd bf       	out	0x3d, r28	; 61
    4c5c:	9c 83       	std	Y+4, r25	; 0x04
    4c5e:	8b 83       	std	Y+3, r24	; 0x03
    4c60:	7e 83       	std	Y+6, r23	; 0x06
    4c62:	6d 83       	std	Y+5, r22	; 0x05
    4c64:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4c66:	8b 81       	ldd	r24, Y+3	; 0x03
    4c68:	9c 81       	ldd	r25, Y+4	; 0x04
    4c6a:	9a 83       	std	Y+2, r25	; 0x02
    4c6c:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c70:	fa 81       	ldd	r31, Y+2	; 0x02
    4c72:	92 8d       	ldd	r25, Z+26	; 0x1a
    4c74:	e9 81       	ldd	r30, Y+1	; 0x01
    4c76:	fa 81       	ldd	r31, Y+2	; 0x02
    4c78:	83 8d       	ldd	r24, Z+27	; 0x1b
    4c7a:	98 17       	cp	r25, r24
    4c7c:	d0 f4       	brcc	.+52     	; 0x4cb2 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4c7e:	89 81       	ldd	r24, Y+1	; 0x01
    4c80:	9a 81       	ldd	r25, Y+2	; 0x02
    4c82:	2d 81       	ldd	r18, Y+5	; 0x05
    4c84:	3e 81       	ldd	r19, Y+6	; 0x06
    4c86:	b9 01       	movw	r22, r18
    4c88:	40 e0       	ldi	r20, 0x00	; 0
    4c8a:	0e 94 71 23 	call	0x46e2	; 0x46e2 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    4c8e:	8f 81       	ldd	r24, Y+7	; 0x07
    4c90:	88 23       	and	r24, r24
    4c92:	79 f4       	brne	.+30     	; 0x4cb2 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4c94:	e9 81       	ldd	r30, Y+1	; 0x01
    4c96:	fa 81       	ldd	r31, Y+2	; 0x02
    4c98:	81 89       	ldd	r24, Z+17	; 0x11
    4c9a:	88 23       	and	r24, r24
    4c9c:	51 f0       	breq	.+20     	; 0x4cb2 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4c9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ca0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca2:	41 96       	adiw	r24, 0x11	; 17
    4ca4:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xCoRoutineRemoveFromEventList>
    4ca8:	88 23       	and	r24, r24
    4caa:	19 f0       	breq	.+6      	; 0x4cb2 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    4cac:	81 e0       	ldi	r24, 0x01	; 1
    4cae:	88 87       	std	Y+8, r24	; 0x08
    4cb0:	02 c0       	rjmp	.+4      	; 0x4cb6 <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    4cb2:	8f 81       	ldd	r24, Y+7	; 0x07
    4cb4:	88 87       	std	Y+8, r24	; 0x08
    4cb6:	88 85       	ldd	r24, Y+8	; 0x08
	}
    4cb8:	28 96       	adiw	r28, 0x08	; 8
    4cba:	0f b6       	in	r0, 0x3f	; 63
    4cbc:	f8 94       	cli
    4cbe:	de bf       	out	0x3e, r29	; 62
    4cc0:	0f be       	out	0x3f, r0	; 63
    4cc2:	cd bf       	out	0x3d, r28	; 61
    4cc4:	cf 91       	pop	r28
    4cc6:	df 91       	pop	r29
    4cc8:	08 95       	ret

00004cca <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    4cca:	df 93       	push	r29
    4ccc:	cf 93       	push	r28
    4cce:	cd b7       	in	r28, 0x3d	; 61
    4cd0:	de b7       	in	r29, 0x3e	; 62
    4cd2:	29 97       	sbiw	r28, 0x09	; 9
    4cd4:	0f b6       	in	r0, 0x3f	; 63
    4cd6:	f8 94       	cli
    4cd8:	de bf       	out	0x3e, r29	; 62
    4cda:	0f be       	out	0x3f, r0	; 63
    4cdc:	cd bf       	out	0x3d, r28	; 61
    4cde:	9d 83       	std	Y+5, r25	; 0x05
    4ce0:	8c 83       	std	Y+4, r24	; 0x04
    4ce2:	7f 83       	std	Y+7, r23	; 0x07
    4ce4:	6e 83       	std	Y+6, r22	; 0x06
    4ce6:	59 87       	std	Y+9, r21	; 0x09
    4ce8:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4cea:	8c 81       	ldd	r24, Y+4	; 0x04
    4cec:	9d 81       	ldd	r25, Y+5	; 0x05
    4cee:	9a 83       	std	Y+2, r25	; 0x02
    4cf0:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4cf2:	e9 81       	ldd	r30, Y+1	; 0x01
    4cf4:	fa 81       	ldd	r31, Y+2	; 0x02
    4cf6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cf8:	88 23       	and	r24, r24
    4cfa:	09 f4       	brne	.+2      	; 0x4cfe <xQueueCRReceiveFromISR+0x34>
    4cfc:	50 c0       	rjmp	.+160    	; 0x4d9e <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4cfe:	e9 81       	ldd	r30, Y+1	; 0x01
    4d00:	fa 81       	ldd	r31, Y+2	; 0x02
    4d02:	26 81       	ldd	r18, Z+6	; 0x06
    4d04:	37 81       	ldd	r19, Z+7	; 0x07
    4d06:	e9 81       	ldd	r30, Y+1	; 0x01
    4d08:	fa 81       	ldd	r31, Y+2	; 0x02
    4d0a:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d0c:	88 2f       	mov	r24, r24
    4d0e:	90 e0       	ldi	r25, 0x00	; 0
    4d10:	82 0f       	add	r24, r18
    4d12:	93 1f       	adc	r25, r19
    4d14:	e9 81       	ldd	r30, Y+1	; 0x01
    4d16:	fa 81       	ldd	r31, Y+2	; 0x02
    4d18:	97 83       	std	Z+7, r25	; 0x07
    4d1a:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    4d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d20:	26 81       	ldd	r18, Z+6	; 0x06
    4d22:	37 81       	ldd	r19, Z+7	; 0x07
    4d24:	e9 81       	ldd	r30, Y+1	; 0x01
    4d26:	fa 81       	ldd	r31, Y+2	; 0x02
    4d28:	82 81       	ldd	r24, Z+2	; 0x02
    4d2a:	93 81       	ldd	r25, Z+3	; 0x03
    4d2c:	28 17       	cp	r18, r24
    4d2e:	39 07       	cpc	r19, r25
    4d30:	40 f0       	brcs	.+16     	; 0x4d42 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4d32:	e9 81       	ldd	r30, Y+1	; 0x01
    4d34:	fa 81       	ldd	r31, Y+2	; 0x02
    4d36:	80 81       	ld	r24, Z
    4d38:	91 81       	ldd	r25, Z+1	; 0x01
    4d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d3e:	97 83       	std	Z+7, r25	; 0x07
    4d40:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    4d42:	e9 81       	ldd	r30, Y+1	; 0x01
    4d44:	fa 81       	ldd	r31, Y+2	; 0x02
    4d46:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d48:	81 50       	subi	r24, 0x01	; 1
    4d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d4e:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4d50:	e9 81       	ldd	r30, Y+1	; 0x01
    4d52:	fa 81       	ldd	r31, Y+2	; 0x02
    4d54:	46 81       	ldd	r20, Z+6	; 0x06
    4d56:	57 81       	ldd	r21, Z+7	; 0x07
    4d58:	e9 81       	ldd	r30, Y+1	; 0x01
    4d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d5c:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d5e:	28 2f       	mov	r18, r24
    4d60:	30 e0       	ldi	r19, 0x00	; 0
    4d62:	8e 81       	ldd	r24, Y+6	; 0x06
    4d64:	9f 81       	ldd	r25, Y+7	; 0x07
    4d66:	ba 01       	movw	r22, r20
    4d68:	a9 01       	movw	r20, r18
    4d6a:	0e 94 cd 33 	call	0x679a	; 0x679a <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    4d6e:	e8 85       	ldd	r30, Y+8	; 0x08
    4d70:	f9 85       	ldd	r31, Y+9	; 0x09
    4d72:	80 81       	ld	r24, Z
    4d74:	88 23       	and	r24, r24
    4d76:	81 f4       	brne	.+32     	; 0x4d98 <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4d78:	e9 81       	ldd	r30, Y+1	; 0x01
    4d7a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d7c:	80 85       	ldd	r24, Z+8	; 0x08
    4d7e:	88 23       	and	r24, r24
    4d80:	59 f0       	breq	.+22     	; 0x4d98 <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	9a 81       	ldd	r25, Y+2	; 0x02
    4d86:	08 96       	adiw	r24, 0x08	; 8
    4d88:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <xCoRoutineRemoveFromEventList>
    4d8c:	88 23       	and	r24, r24
    4d8e:	21 f0       	breq	.+8      	; 0x4d98 <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    4d90:	e8 85       	ldd	r30, Y+8	; 0x08
    4d92:	f9 85       	ldd	r31, Y+9	; 0x09
    4d94:	81 e0       	ldi	r24, 0x01	; 1
    4d96:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    4d98:	81 e0       	ldi	r24, 0x01	; 1
    4d9a:	8b 83       	std	Y+3, r24	; 0x03
    4d9c:	01 c0       	rjmp	.+2      	; 0x4da0 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    4d9e:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    4da0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4da2:	29 96       	adiw	r28, 0x09	; 9
    4da4:	0f b6       	in	r0, 0x3f	; 63
    4da6:	f8 94       	cli
    4da8:	de bf       	out	0x3e, r29	; 62
    4daa:	0f be       	out	0x3f, r0	; 63
    4dac:	cd bf       	out	0x3d, r28	; 61
    4dae:	cf 91       	pop	r28
    4db0:	df 91       	pop	r29
    4db2:	08 95       	ret

00004db4 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4db4:	af 92       	push	r10
    4db6:	bf 92       	push	r11
    4db8:	cf 92       	push	r12
    4dba:	df 92       	push	r13
    4dbc:	ef 92       	push	r14
    4dbe:	ff 92       	push	r15
    4dc0:	0f 93       	push	r16
    4dc2:	1f 93       	push	r17
    4dc4:	df 93       	push	r29
    4dc6:	cf 93       	push	r28
    4dc8:	cd b7       	in	r28, 0x3d	; 61
    4dca:	de b7       	in	r29, 0x3e	; 62
    4dcc:	64 97       	sbiw	r28, 0x14	; 20
    4dce:	0f b6       	in	r0, 0x3f	; 63
    4dd0:	f8 94       	cli
    4dd2:	de bf       	out	0x3e, r29	; 62
    4dd4:	0f be       	out	0x3f, r0	; 63
    4dd6:	cd bf       	out	0x3d, r28	; 61
    4dd8:	9f 83       	std	Y+7, r25	; 0x07
    4dda:	8e 83       	std	Y+6, r24	; 0x06
    4ddc:	79 87       	std	Y+9, r23	; 0x09
    4dde:	68 87       	std	Y+8, r22	; 0x08
    4de0:	5b 87       	std	Y+11, r21	; 0x0b
    4de2:	4a 87       	std	Y+10, r20	; 0x0a
    4de4:	3d 87       	std	Y+13, r19	; 0x0d
    4de6:	2c 87       	std	Y+12, r18	; 0x0c
    4de8:	0e 87       	std	Y+14, r16	; 0x0e
    4dea:	f8 8a       	std	Y+16, r15	; 0x10
    4dec:	ef 86       	std	Y+15, r14	; 0x0f
    4dee:	da 8a       	std	Y+18, r13	; 0x12
    4df0:	c9 8a       	std	Y+17, r12	; 0x11
    4df2:	bc 8a       	std	Y+20, r11	; 0x14
    4df4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4df6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4df8:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dfa:	29 89       	ldd	r18, Y+17	; 0x11
    4dfc:	3a 89       	ldd	r19, Y+18	; 0x12
    4dfe:	b9 01       	movw	r22, r18
    4e00:	0e 94 da 30 	call	0x61b4	; 0x61b4 <prvAllocateTCBAndStack>
    4e04:	9c 83       	std	Y+4, r25	; 0x04
    4e06:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4e08:	8b 81       	ldd	r24, Y+3	; 0x03
    4e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e0c:	00 97       	sbiw	r24, 0x00	; 0
    4e0e:	09 f4       	brne	.+2      	; 0x4e12 <xTaskGenericCreate+0x5e>
    4e10:	8d c0       	rjmp	.+282    	; 0x4f2c <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    4e12:	eb 81       	ldd	r30, Y+3	; 0x03
    4e14:	fc 81       	ldd	r31, Y+4	; 0x04
    4e16:	27 89       	ldd	r18, Z+23	; 0x17
    4e18:	30 8d       	ldd	r19, Z+24	; 0x18
    4e1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e1e:	01 97       	sbiw	r24, 0x01	; 1
    4e20:	82 0f       	add	r24, r18
    4e22:	93 1f       	adc	r25, r19
    4e24:	9a 83       	std	Y+2, r25	; 0x02
    4e26:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    4e28:	8b 81       	ldd	r24, Y+3	; 0x03
    4e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e2c:	28 85       	ldd	r18, Y+8	; 0x08
    4e2e:	39 85       	ldd	r19, Y+9	; 0x09
    4e30:	eb 89       	ldd	r30, Y+19	; 0x13
    4e32:	fc 89       	ldd	r31, Y+20	; 0x14
    4e34:	aa 85       	ldd	r26, Y+10	; 0x0a
    4e36:	bb 85       	ldd	r27, Y+11	; 0x0b
    4e38:	b9 01       	movw	r22, r18
    4e3a:	4e 85       	ldd	r20, Y+14	; 0x0e
    4e3c:	9f 01       	movw	r18, r30
    4e3e:	8d 01       	movw	r16, r26
    4e40:	0e 94 97 2f 	call	0x5f2e	; 0x5f2e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4e44:	89 81       	ldd	r24, Y+1	; 0x01
    4e46:	9a 81       	ldd	r25, Y+2	; 0x02
    4e48:	2e 81       	ldd	r18, Y+6	; 0x06
    4e4a:	3f 81       	ldd	r19, Y+7	; 0x07
    4e4c:	4c 85       	ldd	r20, Y+12	; 0x0c
    4e4e:	5d 85       	ldd	r21, Y+13	; 0x0d
    4e50:	b9 01       	movw	r22, r18
    4e52:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <pxPortInitialiseStack>
    4e56:	eb 81       	ldd	r30, Y+3	; 0x03
    4e58:	fc 81       	ldd	r31, Y+4	; 0x04
    4e5a:	91 83       	std	Z+1, r25	; 0x01
    4e5c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    4e5e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4e60:	98 89       	ldd	r25, Y+16	; 0x10
    4e62:	00 97       	sbiw	r24, 0x00	; 0
    4e64:	31 f0       	breq	.+12     	; 0x4e72 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4e66:	ef 85       	ldd	r30, Y+15	; 0x0f
    4e68:	f8 89       	ldd	r31, Y+16	; 0x10
    4e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4e6e:	91 83       	std	Z+1, r25	; 0x01
    4e70:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    4e72:	0f b6       	in	r0, 0x3f	; 63
    4e74:	f8 94       	cli
    4e76:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4e78:	80 91 6b 06 	lds	r24, 0x066B
    4e7c:	8f 5f       	subi	r24, 0xFF	; 255
    4e7e:	80 93 6b 06 	sts	0x066B, r24
			if( pxCurrentTCB == NULL )
    4e82:	80 91 68 06 	lds	r24, 0x0668
    4e86:	90 91 69 06 	lds	r25, 0x0669
    4e8a:	00 97       	sbiw	r24, 0x00	; 0
    4e8c:	69 f4       	brne	.+26     	; 0x4ea8 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e90:	9c 81       	ldd	r25, Y+4	; 0x04
    4e92:	90 93 69 06 	sts	0x0669, r25
    4e96:	80 93 68 06 	sts	0x0668, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4e9a:	80 91 6b 06 	lds	r24, 0x066B
    4e9e:	81 30       	cpi	r24, 0x01	; 1
    4ea0:	a9 f4       	brne	.+42     	; 0x4ecc <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4ea2:	0e 94 11 30 	call	0x6022	; 0x6022 <prvInitialiseTaskLists>
    4ea6:	12 c0       	rjmp	.+36     	; 0x4ecc <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4ea8:	80 91 6f 06 	lds	r24, 0x066F
    4eac:	88 23       	and	r24, r24
    4eae:	71 f4       	brne	.+28     	; 0x4ecc <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4eb0:	e0 91 68 06 	lds	r30, 0x0668
    4eb4:	f0 91 69 06 	lds	r31, 0x0669
    4eb8:	96 89       	ldd	r25, Z+22	; 0x16
    4eba:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ebc:	89 17       	cp	r24, r25
    4ebe:	30 f0       	brcs	.+12     	; 0x4ecc <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec4:	90 93 69 06 	sts	0x0669, r25
    4ec8:	80 93 68 06 	sts	0x0668, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    4ecc:	80 91 73 06 	lds	r24, 0x0673
    4ed0:	8f 5f       	subi	r24, 0xFF	; 255
    4ed2:	80 93 73 06 	sts	0x0673, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    4ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eda:	96 89       	ldd	r25, Z+22	; 0x16
    4edc:	80 91 6e 06 	lds	r24, 0x066E
    4ee0:	89 17       	cp	r24, r25
    4ee2:	28 f4       	brcc	.+10     	; 0x4eee <xTaskGenericCreate+0x13a>
    4ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ee8:	86 89       	ldd	r24, Z+22	; 0x16
    4eea:	80 93 6e 06 	sts	0x066E, r24
    4eee:	eb 81       	ldd	r30, Y+3	; 0x03
    4ef0:	fc 81       	ldd	r31, Y+4	; 0x04
    4ef2:	86 89       	ldd	r24, Z+22	; 0x16
    4ef4:	28 2f       	mov	r18, r24
    4ef6:	30 e0       	ldi	r19, 0x00	; 0
    4ef8:	c9 01       	movw	r24, r18
    4efa:	88 0f       	add	r24, r24
    4efc:	99 1f       	adc	r25, r25
    4efe:	88 0f       	add	r24, r24
    4f00:	99 1f       	adc	r25, r25
    4f02:	88 0f       	add	r24, r24
    4f04:	99 1f       	adc	r25, r25
    4f06:	82 0f       	add	r24, r18
    4f08:	93 1f       	adc	r25, r19
    4f0a:	ac 01       	movw	r20, r24
    4f0c:	4b 58       	subi	r20, 0x8B	; 139
    4f0e:	59 4f       	sbci	r21, 0xF9	; 249
    4f10:	8b 81       	ldd	r24, Y+3	; 0x03
    4f12:	9c 81       	ldd	r25, Y+4	; 0x04
    4f14:	9c 01       	movw	r18, r24
    4f16:	2e 5f       	subi	r18, 0xFE	; 254
    4f18:	3f 4f       	sbci	r19, 0xFF	; 255
    4f1a:	ca 01       	movw	r24, r20
    4f1c:	b9 01       	movw	r22, r18
    4f1e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

			xReturn = pdPASS;
    4f22:	81 e0       	ldi	r24, 0x01	; 1
    4f24:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4f26:	0f 90       	pop	r0
    4f28:	0f be       	out	0x3f, r0	; 63
    4f2a:	02 c0       	rjmp	.+4      	; 0x4f30 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4f2c:	8f ef       	ldi	r24, 0xFF	; 255
    4f2e:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4f30:	8d 81       	ldd	r24, Y+5	; 0x05
    4f32:	81 30       	cpi	r24, 0x01	; 1
    4f34:	71 f4       	brne	.+28     	; 0x4f52 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    4f36:	80 91 6f 06 	lds	r24, 0x066F
    4f3a:	88 23       	and	r24, r24
    4f3c:	51 f0       	breq	.+20     	; 0x4f52 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4f3e:	e0 91 68 06 	lds	r30, 0x0668
    4f42:	f0 91 69 06 	lds	r31, 0x0669
    4f46:	96 89       	ldd	r25, Z+22	; 0x16
    4f48:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f4a:	98 17       	cp	r25, r24
    4f4c:	10 f4       	brcc	.+4      	; 0x4f52 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    4f4e:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    4f52:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4f54:	64 96       	adiw	r28, 0x14	; 20
    4f56:	0f b6       	in	r0, 0x3f	; 63
    4f58:	f8 94       	cli
    4f5a:	de bf       	out	0x3e, r29	; 62
    4f5c:	0f be       	out	0x3f, r0	; 63
    4f5e:	cd bf       	out	0x3d, r28	; 61
    4f60:	cf 91       	pop	r28
    4f62:	df 91       	pop	r29
    4f64:	1f 91       	pop	r17
    4f66:	0f 91       	pop	r16
    4f68:	ff 90       	pop	r15
    4f6a:	ef 90       	pop	r14
    4f6c:	df 90       	pop	r13
    4f6e:	cf 90       	pop	r12
    4f70:	bf 90       	pop	r11
    4f72:	af 90       	pop	r10
    4f74:	08 95       	ret

00004f76 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4f76:	df 93       	push	r29
    4f78:	cf 93       	push	r28
    4f7a:	00 d0       	rcall	.+0      	; 0x4f7c <vTaskDelete+0x6>
    4f7c:	00 d0       	rcall	.+0      	; 0x4f7e <vTaskDelete+0x8>
    4f7e:	00 d0       	rcall	.+0      	; 0x4f80 <vTaskDelete+0xa>
    4f80:	cd b7       	in	r28, 0x3d	; 61
    4f82:	de b7       	in	r29, 0x3e	; 62
    4f84:	9c 83       	std	Y+4, r25	; 0x04
    4f86:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4f88:	0f b6       	in	r0, 0x3f	; 63
    4f8a:	f8 94       	cli
    4f8c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4f8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f90:	9c 81       	ldd	r25, Y+4	; 0x04
    4f92:	00 97       	sbiw	r24, 0x00	; 0
    4f94:	39 f4       	brne	.+14     	; 0x4fa4 <vTaskDelete+0x2e>
    4f96:	80 91 68 06 	lds	r24, 0x0668
    4f9a:	90 91 69 06 	lds	r25, 0x0669
    4f9e:	9e 83       	std	Y+6, r25	; 0x06
    4fa0:	8d 83       	std	Y+5, r24	; 0x05
    4fa2:	04 c0       	rjmp	.+8      	; 0x4fac <vTaskDelete+0x36>
    4fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    4fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    4fa8:	9e 83       	std	Y+6, r25	; 0x06
    4faa:	8d 83       	std	Y+5, r24	; 0x05
    4fac:	8d 81       	ldd	r24, Y+5	; 0x05
    4fae:	9e 81       	ldd	r25, Y+6	; 0x06
    4fb0:	9a 83       	std	Y+2, r25	; 0x02
    4fb2:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4fb4:	89 81       	ldd	r24, Y+1	; 0x01
    4fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb8:	02 96       	adiw	r24, 0x02	; 2
    4fba:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    4fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fc2:	84 89       	ldd	r24, Z+20	; 0x14
    4fc4:	95 89       	ldd	r25, Z+21	; 0x15
    4fc6:	00 97       	sbiw	r24, 0x00	; 0
    4fc8:	29 f0       	breq	.+10     	; 0x4fd4 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4fca:	89 81       	ldd	r24, Y+1	; 0x01
    4fcc:	9a 81       	ldd	r25, Y+2	; 0x02
    4fce:	0c 96       	adiw	r24, 0x0c	; 12
    4fd0:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4fd4:	89 81       	ldd	r24, Y+1	; 0x01
    4fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fd8:	9c 01       	movw	r18, r24
    4fda:	2e 5f       	subi	r18, 0xFE	; 254
    4fdc:	3f 4f       	sbci	r19, 0xFF	; 255
    4fde:	88 eb       	ldi	r24, 0xB8	; 184
    4fe0:	96 e0       	ldi	r25, 0x06	; 6
    4fe2:	b9 01       	movw	r22, r18
    4fe4:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4fe8:	80 91 6a 06 	lds	r24, 0x066A
    4fec:	8f 5f       	subi	r24, 0xFF	; 255
    4fee:	80 93 6a 06 	sts	0x066A, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4ff2:	80 91 73 06 	lds	r24, 0x0673
    4ff6:	8f 5f       	subi	r24, 0xFF	; 255
    4ff8:	80 93 73 06 	sts	0x0673, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4ffc:	0f 90       	pop	r0
    4ffe:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    5000:	80 91 6f 06 	lds	r24, 0x066F
    5004:	88 23       	and	r24, r24
    5006:	99 f0       	breq	.+38     	; 0x502e <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    5008:	20 91 68 06 	lds	r18, 0x0668
    500c:	30 91 69 06 	lds	r19, 0x0669
    5010:	89 81       	ldd	r24, Y+1	; 0x01
    5012:	9a 81       	ldd	r25, Y+2	; 0x02
    5014:	82 17       	cp	r24, r18
    5016:	93 07       	cpc	r25, r19
    5018:	19 f4       	brne	.+6      	; 0x5020 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    501a:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    501e:	07 c0       	rjmp	.+14     	; 0x502e <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    5020:	0f b6       	in	r0, 0x3f	; 63
    5022:	f8 94       	cli
    5024:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    5026:	0e 94 34 31 	call	0x6268	; 0x6268 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    502a:	0f 90       	pop	r0
    502c:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    502e:	26 96       	adiw	r28, 0x06	; 6
    5030:	0f b6       	in	r0, 0x3f	; 63
    5032:	f8 94       	cli
    5034:	de bf       	out	0x3e, r29	; 62
    5036:	0f be       	out	0x3f, r0	; 63
    5038:	cd bf       	out	0x3d, r28	; 61
    503a:	cf 91       	pop	r28
    503c:	df 91       	pop	r29
    503e:	08 95       	ret

00005040 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    5040:	df 93       	push	r29
    5042:	cf 93       	push	r28
    5044:	cd b7       	in	r28, 0x3d	; 61
    5046:	de b7       	in	r29, 0x3e	; 62
    5048:	2a 97       	sbiw	r28, 0x0a	; 10
    504a:	0f b6       	in	r0, 0x3f	; 63
    504c:	f8 94       	cli
    504e:	de bf       	out	0x3e, r29	; 62
    5050:	0f be       	out	0x3f, r0	; 63
    5052:	cd bf       	out	0x3d, r28	; 61
    5054:	98 87       	std	Y+8, r25	; 0x08
    5056:	8f 83       	std	Y+7, r24	; 0x07
    5058:	7a 87       	std	Y+10, r23	; 0x0a
    505a:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    505c:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    505e:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    5062:	80 91 6c 06 	lds	r24, 0x066C
    5066:	90 91 6d 06 	lds	r25, 0x066D
    506a:	9a 83       	std	Y+2, r25	; 0x02
    506c:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    506e:	ef 81       	ldd	r30, Y+7	; 0x07
    5070:	f8 85       	ldd	r31, Y+8	; 0x08
    5072:	20 81       	ld	r18, Z
    5074:	31 81       	ldd	r19, Z+1	; 0x01
    5076:	89 85       	ldd	r24, Y+9	; 0x09
    5078:	9a 85       	ldd	r25, Y+10	; 0x0a
    507a:	82 0f       	add	r24, r18
    507c:	93 1f       	adc	r25, r19
    507e:	9e 83       	std	Y+6, r25	; 0x06
    5080:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    5082:	ef 81       	ldd	r30, Y+7	; 0x07
    5084:	f8 85       	ldd	r31, Y+8	; 0x08
    5086:	20 81       	ld	r18, Z
    5088:	31 81       	ldd	r19, Z+1	; 0x01
    508a:	89 81       	ldd	r24, Y+1	; 0x01
    508c:	9a 81       	ldd	r25, Y+2	; 0x02
    508e:	82 17       	cp	r24, r18
    5090:	93 07       	cpc	r25, r19
    5092:	98 f4       	brcc	.+38     	; 0x50ba <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    5094:	ef 81       	ldd	r30, Y+7	; 0x07
    5096:	f8 85       	ldd	r31, Y+8	; 0x08
    5098:	20 81       	ld	r18, Z
    509a:	31 81       	ldd	r19, Z+1	; 0x01
    509c:	8d 81       	ldd	r24, Y+5	; 0x05
    509e:	9e 81       	ldd	r25, Y+6	; 0x06
    50a0:	82 17       	cp	r24, r18
    50a2:	93 07       	cpc	r25, r19
    50a4:	e0 f4       	brcc	.+56     	; 0x50de <vTaskDelayUntil+0x9e>
    50a6:	2d 81       	ldd	r18, Y+5	; 0x05
    50a8:	3e 81       	ldd	r19, Y+6	; 0x06
    50aa:	89 81       	ldd	r24, Y+1	; 0x01
    50ac:	9a 81       	ldd	r25, Y+2	; 0x02
    50ae:	82 17       	cp	r24, r18
    50b0:	93 07       	cpc	r25, r19
    50b2:	a8 f4       	brcc	.+42     	; 0x50de <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    50b4:	81 e0       	ldi	r24, 0x01	; 1
    50b6:	8b 83       	std	Y+3, r24	; 0x03
    50b8:	12 c0       	rjmp	.+36     	; 0x50de <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    50ba:	ef 81       	ldd	r30, Y+7	; 0x07
    50bc:	f8 85       	ldd	r31, Y+8	; 0x08
    50be:	20 81       	ld	r18, Z
    50c0:	31 81       	ldd	r19, Z+1	; 0x01
    50c2:	8d 81       	ldd	r24, Y+5	; 0x05
    50c4:	9e 81       	ldd	r25, Y+6	; 0x06
    50c6:	82 17       	cp	r24, r18
    50c8:	93 07       	cpc	r25, r19
    50ca:	38 f0       	brcs	.+14     	; 0x50da <vTaskDelayUntil+0x9a>
    50cc:	2d 81       	ldd	r18, Y+5	; 0x05
    50ce:	3e 81       	ldd	r19, Y+6	; 0x06
    50d0:	89 81       	ldd	r24, Y+1	; 0x01
    50d2:	9a 81       	ldd	r25, Y+2	; 0x02
    50d4:	82 17       	cp	r24, r18
    50d6:	93 07       	cpc	r25, r19
    50d8:	10 f4       	brcc	.+4      	; 0x50de <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    50da:	81 e0       	ldi	r24, 0x01	; 1
    50dc:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    50de:	ef 81       	ldd	r30, Y+7	; 0x07
    50e0:	f8 85       	ldd	r31, Y+8	; 0x08
    50e2:	8d 81       	ldd	r24, Y+5	; 0x05
    50e4:	9e 81       	ldd	r25, Y+6	; 0x06
    50e6:	91 83       	std	Z+1, r25	; 0x01
    50e8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    50ea:	8b 81       	ldd	r24, Y+3	; 0x03
    50ec:	88 23       	and	r24, r24
    50ee:	59 f0       	breq	.+22     	; 0x5106 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    50f0:	80 91 68 06 	lds	r24, 0x0668
    50f4:	90 91 69 06 	lds	r25, 0x0669
    50f8:	02 96       	adiw	r24, 0x02	; 2
    50fa:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    50fe:	8d 81       	ldd	r24, Y+5	; 0x05
    5100:	9e 81       	ldd	r25, Y+6	; 0x06
    5102:	0e 94 91 30 	call	0x6122	; 0x6122 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    5106:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    510a:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    510c:	8c 81       	ldd	r24, Y+4	; 0x04
    510e:	88 23       	and	r24, r24
    5110:	11 f4       	brne	.+4      	; 0x5116 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    5112:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5116:	2a 96       	adiw	r28, 0x0a	; 10
    5118:	0f b6       	in	r0, 0x3f	; 63
    511a:	f8 94       	cli
    511c:	de bf       	out	0x3e, r29	; 62
    511e:	0f be       	out	0x3f, r0	; 63
    5120:	cd bf       	out	0x3d, r28	; 61
    5122:	cf 91       	pop	r28
    5124:	df 91       	pop	r29
    5126:	08 95       	ret

00005128 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    5128:	df 93       	push	r29
    512a:	cf 93       	push	r28
    512c:	00 d0       	rcall	.+0      	; 0x512e <vTaskDelay+0x6>
    512e:	00 d0       	rcall	.+0      	; 0x5130 <vTaskDelay+0x8>
    5130:	0f 92       	push	r0
    5132:	cd b7       	in	r28, 0x3d	; 61
    5134:	de b7       	in	r29, 0x3e	; 62
    5136:	9d 83       	std	Y+5, r25	; 0x05
    5138:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    513a:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    513c:	8c 81       	ldd	r24, Y+4	; 0x04
    513e:	9d 81       	ldd	r25, Y+5	; 0x05
    5140:	00 97       	sbiw	r24, 0x00	; 0
    5142:	d1 f0       	breq	.+52     	; 0x5178 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    5144:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5148:	20 91 6c 06 	lds	r18, 0x066C
    514c:	30 91 6d 06 	lds	r19, 0x066D
    5150:	8c 81       	ldd	r24, Y+4	; 0x04
    5152:	9d 81       	ldd	r25, Y+5	; 0x05
    5154:	82 0f       	add	r24, r18
    5156:	93 1f       	adc	r25, r19
    5158:	9b 83       	std	Y+3, r25	; 0x03
    515a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    515c:	80 91 68 06 	lds	r24, 0x0668
    5160:	90 91 69 06 	lds	r25, 0x0669
    5164:	02 96       	adiw	r24, 0x02	; 2
    5166:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    516a:	8a 81       	ldd	r24, Y+2	; 0x02
    516c:	9b 81       	ldd	r25, Y+3	; 0x03
    516e:	0e 94 91 30 	call	0x6122	; 0x6122 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5172:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>
    5176:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5178:	89 81       	ldd	r24, Y+1	; 0x01
    517a:	88 23       	and	r24, r24
    517c:	11 f4       	brne	.+4      	; 0x5182 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    517e:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5182:	0f 90       	pop	r0
    5184:	0f 90       	pop	r0
    5186:	0f 90       	pop	r0
    5188:	0f 90       	pop	r0
    518a:	0f 90       	pop	r0
    518c:	cf 91       	pop	r28
    518e:	df 91       	pop	r29
    5190:	08 95       	ret

00005192 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    5192:	df 93       	push	r29
    5194:	cf 93       	push	r28
    5196:	cd b7       	in	r28, 0x3d	; 61
    5198:	de b7       	in	r29, 0x3e	; 62
    519a:	27 97       	sbiw	r28, 0x07	; 7
    519c:	0f b6       	in	r0, 0x3f	; 63
    519e:	f8 94       	cli
    51a0:	de bf       	out	0x3e, r29	; 62
    51a2:	0f be       	out	0x3f, r0	; 63
    51a4:	cd bf       	out	0x3d, r28	; 61
    51a6:	9d 83       	std	Y+5, r25	; 0x05
    51a8:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    51aa:	0f b6       	in	r0, 0x3f	; 63
    51ac:	f8 94       	cli
    51ae:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    51b0:	8c 81       	ldd	r24, Y+4	; 0x04
    51b2:	9d 81       	ldd	r25, Y+5	; 0x05
    51b4:	00 97       	sbiw	r24, 0x00	; 0
    51b6:	39 f4       	brne	.+14     	; 0x51c6 <uxTaskPriorityGet+0x34>
    51b8:	80 91 68 06 	lds	r24, 0x0668
    51bc:	90 91 69 06 	lds	r25, 0x0669
    51c0:	9f 83       	std	Y+7, r25	; 0x07
    51c2:	8e 83       	std	Y+6, r24	; 0x06
    51c4:	04 c0       	rjmp	.+8      	; 0x51ce <uxTaskPriorityGet+0x3c>
    51c6:	8c 81       	ldd	r24, Y+4	; 0x04
    51c8:	9d 81       	ldd	r25, Y+5	; 0x05
    51ca:	9f 83       	std	Y+7, r25	; 0x07
    51cc:	8e 83       	std	Y+6, r24	; 0x06
    51ce:	8e 81       	ldd	r24, Y+6	; 0x06
    51d0:	9f 81       	ldd	r25, Y+7	; 0x07
    51d2:	9b 83       	std	Y+3, r25	; 0x03
    51d4:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    51d6:	ea 81       	ldd	r30, Y+2	; 0x02
    51d8:	fb 81       	ldd	r31, Y+3	; 0x03
    51da:	86 89       	ldd	r24, Z+22	; 0x16
    51dc:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    51de:	0f 90       	pop	r0
    51e0:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    51e2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    51e4:	27 96       	adiw	r28, 0x07	; 7
    51e6:	0f b6       	in	r0, 0x3f	; 63
    51e8:	f8 94       	cli
    51ea:	de bf       	out	0x3e, r29	; 62
    51ec:	0f be       	out	0x3f, r0	; 63
    51ee:	cd bf       	out	0x3d, r28	; 61
    51f0:	cf 91       	pop	r28
    51f2:	df 91       	pop	r29
    51f4:	08 95       	ret

000051f6 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    51f6:	df 93       	push	r29
    51f8:	cf 93       	push	r28
    51fa:	cd b7       	in	r28, 0x3d	; 61
    51fc:	de b7       	in	r29, 0x3e	; 62
    51fe:	2a 97       	sbiw	r28, 0x0a	; 10
    5200:	0f b6       	in	r0, 0x3f	; 63
    5202:	f8 94       	cli
    5204:	de bf       	out	0x3e, r29	; 62
    5206:	0f be       	out	0x3f, r0	; 63
    5208:	cd bf       	out	0x3d, r28	; 61
    520a:	9f 83       	std	Y+7, r25	; 0x07
    520c:	8e 83       	std	Y+6, r24	; 0x06
    520e:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    5210:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5212:	88 85       	ldd	r24, Y+8	; 0x08
    5214:	84 30       	cpi	r24, 0x04	; 4
    5216:	10 f0       	brcs	.+4      	; 0x521c <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5218:	83 e0       	ldi	r24, 0x03	; 3
    521a:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    521c:	0f b6       	in	r0, 0x3f	; 63
    521e:	f8 94       	cli
    5220:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    5222:	8e 81       	ldd	r24, Y+6	; 0x06
    5224:	9f 81       	ldd	r25, Y+7	; 0x07
    5226:	00 97       	sbiw	r24, 0x00	; 0
    5228:	39 f4       	brne	.+14     	; 0x5238 <vTaskPrioritySet+0x42>
    522a:	80 91 68 06 	lds	r24, 0x0668
    522e:	90 91 69 06 	lds	r25, 0x0669
    5232:	9a 87       	std	Y+10, r25	; 0x0a
    5234:	89 87       	std	Y+9, r24	; 0x09
    5236:	04 c0       	rjmp	.+8      	; 0x5240 <vTaskPrioritySet+0x4a>
    5238:	8e 81       	ldd	r24, Y+6	; 0x06
    523a:	9f 81       	ldd	r25, Y+7	; 0x07
    523c:	9a 87       	std	Y+10, r25	; 0x0a
    523e:	89 87       	std	Y+9, r24	; 0x09
    5240:	89 85       	ldd	r24, Y+9	; 0x09
    5242:	9a 85       	ldd	r25, Y+10	; 0x0a
    5244:	9d 83       	std	Y+5, r25	; 0x05
    5246:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    5248:	ec 81       	ldd	r30, Y+4	; 0x04
    524a:	fd 81       	ldd	r31, Y+5	; 0x05
    524c:	85 a5       	ldd	r24, Z+45	; 0x2d
    524e:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    5250:	9b 81       	ldd	r25, Y+3	; 0x03
    5252:	88 85       	ldd	r24, Y+8	; 0x08
    5254:	98 17       	cp	r25, r24
    5256:	09 f4       	brne	.+2      	; 0x525a <vTaskPrioritySet+0x64>
    5258:	8d c0       	rjmp	.+282    	; 0x5374 <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    525a:	98 85       	ldd	r25, Y+8	; 0x08
    525c:	8b 81       	ldd	r24, Y+3	; 0x03
    525e:	89 17       	cp	r24, r25
    5260:	a0 f4       	brcc	.+40     	; 0x528a <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    5262:	20 91 68 06 	lds	r18, 0x0668
    5266:	30 91 69 06 	lds	r19, 0x0669
    526a:	8c 81       	ldd	r24, Y+4	; 0x04
    526c:	9d 81       	ldd	r25, Y+5	; 0x05
    526e:	82 17       	cp	r24, r18
    5270:	93 07       	cpc	r25, r19
    5272:	b1 f0       	breq	.+44     	; 0x52a0 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    5274:	e0 91 68 06 	lds	r30, 0x0668
    5278:	f0 91 69 06 	lds	r31, 0x0669
    527c:	96 89       	ldd	r25, Z+22	; 0x16
    527e:	88 85       	ldd	r24, Y+8	; 0x08
    5280:	89 17       	cp	r24, r25
    5282:	70 f0       	brcs	.+28     	; 0x52a0 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    5284:	81 e0       	ldi	r24, 0x01	; 1
    5286:	89 83       	std	Y+1, r24	; 0x01
    5288:	0b c0       	rjmp	.+22     	; 0x52a0 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    528a:	20 91 68 06 	lds	r18, 0x0668
    528e:	30 91 69 06 	lds	r19, 0x0669
    5292:	8c 81       	ldd	r24, Y+4	; 0x04
    5294:	9d 81       	ldd	r25, Y+5	; 0x05
    5296:	82 17       	cp	r24, r18
    5298:	93 07       	cpc	r25, r19
    529a:	11 f4       	brne	.+4      	; 0x52a0 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    529c:	81 e0       	ldi	r24, 0x01	; 1
    529e:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    52a0:	ec 81       	ldd	r30, Y+4	; 0x04
    52a2:	fd 81       	ldd	r31, Y+5	; 0x05
    52a4:	86 89       	ldd	r24, Z+22	; 0x16
    52a6:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    52a8:	ec 81       	ldd	r30, Y+4	; 0x04
    52aa:	fd 81       	ldd	r31, Y+5	; 0x05
    52ac:	95 a5       	ldd	r25, Z+45	; 0x2d
    52ae:	ec 81       	ldd	r30, Y+4	; 0x04
    52b0:	fd 81       	ldd	r31, Y+5	; 0x05
    52b2:	86 89       	ldd	r24, Z+22	; 0x16
    52b4:	98 17       	cp	r25, r24
    52b6:	21 f4       	brne	.+8      	; 0x52c0 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    52b8:	ec 81       	ldd	r30, Y+4	; 0x04
    52ba:	fd 81       	ldd	r31, Y+5	; 0x05
    52bc:	88 85       	ldd	r24, Y+8	; 0x08
    52be:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    52c0:	ec 81       	ldd	r30, Y+4	; 0x04
    52c2:	fd 81       	ldd	r31, Y+5	; 0x05
    52c4:	88 85       	ldd	r24, Y+8	; 0x08
    52c6:	85 a7       	std	Z+45, r24	; 0x2d
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    52c8:	ec 81       	ldd	r30, Y+4	; 0x04
    52ca:	fd 81       	ldd	r31, Y+5	; 0x05
    52cc:	84 85       	ldd	r24, Z+12	; 0x0c
    52ce:	95 85       	ldd	r25, Z+13	; 0x0d
    52d0:	99 23       	and	r25, r25
    52d2:	5c f0       	brlt	.+22     	; 0x52ea <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    52d4:	88 85       	ldd	r24, Y+8	; 0x08
    52d6:	28 2f       	mov	r18, r24
    52d8:	30 e0       	ldi	r19, 0x00	; 0
    52da:	84 e0       	ldi	r24, 0x04	; 4
    52dc:	90 e0       	ldi	r25, 0x00	; 0
    52de:	82 1b       	sub	r24, r18
    52e0:	93 0b       	sbc	r25, r19
    52e2:	ec 81       	ldd	r30, Y+4	; 0x04
    52e4:	fd 81       	ldd	r31, Y+5	; 0x05
    52e6:	95 87       	std	Z+13, r25	; 0x0d
    52e8:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    52ea:	ec 81       	ldd	r30, Y+4	; 0x04
    52ec:	fd 81       	ldd	r31, Y+5	; 0x05
    52ee:	42 85       	ldd	r20, Z+10	; 0x0a
    52f0:	53 85       	ldd	r21, Z+11	; 0x0b
    52f2:	8a 81       	ldd	r24, Y+2	; 0x02
    52f4:	28 2f       	mov	r18, r24
    52f6:	30 e0       	ldi	r19, 0x00	; 0
    52f8:	c9 01       	movw	r24, r18
    52fa:	88 0f       	add	r24, r24
    52fc:	99 1f       	adc	r25, r25
    52fe:	88 0f       	add	r24, r24
    5300:	99 1f       	adc	r25, r25
    5302:	88 0f       	add	r24, r24
    5304:	99 1f       	adc	r25, r25
    5306:	82 0f       	add	r24, r18
    5308:	93 1f       	adc	r25, r19
    530a:	8b 58       	subi	r24, 0x8B	; 139
    530c:	99 4f       	sbci	r25, 0xF9	; 249
    530e:	48 17       	cp	r20, r24
    5310:	59 07       	cpc	r21, r25
    5312:	59 f5       	brne	.+86     	; 0x536a <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5314:	8c 81       	ldd	r24, Y+4	; 0x04
    5316:	9d 81       	ldd	r25, Y+5	; 0x05
    5318:	02 96       	adiw	r24, 0x02	; 2
    531a:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    531e:	ec 81       	ldd	r30, Y+4	; 0x04
    5320:	fd 81       	ldd	r31, Y+5	; 0x05
    5322:	96 89       	ldd	r25, Z+22	; 0x16
    5324:	80 91 6e 06 	lds	r24, 0x066E
    5328:	89 17       	cp	r24, r25
    532a:	28 f4       	brcc	.+10     	; 0x5336 <vTaskPrioritySet+0x140>
    532c:	ec 81       	ldd	r30, Y+4	; 0x04
    532e:	fd 81       	ldd	r31, Y+5	; 0x05
    5330:	86 89       	ldd	r24, Z+22	; 0x16
    5332:	80 93 6e 06 	sts	0x066E, r24
    5336:	ec 81       	ldd	r30, Y+4	; 0x04
    5338:	fd 81       	ldd	r31, Y+5	; 0x05
    533a:	86 89       	ldd	r24, Z+22	; 0x16
    533c:	28 2f       	mov	r18, r24
    533e:	30 e0       	ldi	r19, 0x00	; 0
    5340:	c9 01       	movw	r24, r18
    5342:	88 0f       	add	r24, r24
    5344:	99 1f       	adc	r25, r25
    5346:	88 0f       	add	r24, r24
    5348:	99 1f       	adc	r25, r25
    534a:	88 0f       	add	r24, r24
    534c:	99 1f       	adc	r25, r25
    534e:	82 0f       	add	r24, r18
    5350:	93 1f       	adc	r25, r19
    5352:	ac 01       	movw	r20, r24
    5354:	4b 58       	subi	r20, 0x8B	; 139
    5356:	59 4f       	sbci	r21, 0xF9	; 249
    5358:	8c 81       	ldd	r24, Y+4	; 0x04
    535a:	9d 81       	ldd	r25, Y+5	; 0x05
    535c:	9c 01       	movw	r18, r24
    535e:	2e 5f       	subi	r18, 0xFE	; 254
    5360:	3f 4f       	sbci	r19, 0xFF	; 255
    5362:	ca 01       	movw	r24, r20
    5364:	b9 01       	movw	r22, r18
    5366:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    536a:	89 81       	ldd	r24, Y+1	; 0x01
    536c:	81 30       	cpi	r24, 0x01	; 1
    536e:	11 f4       	brne	.+4      	; 0x5374 <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    5370:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    5374:	0f 90       	pop	r0
    5376:	0f be       	out	0x3f, r0	; 63
	}
    5378:	2a 96       	adiw	r28, 0x0a	; 10
    537a:	0f b6       	in	r0, 0x3f	; 63
    537c:	f8 94       	cli
    537e:	de bf       	out	0x3e, r29	; 62
    5380:	0f be       	out	0x3f, r0	; 63
    5382:	cd bf       	out	0x3d, r28	; 61
    5384:	cf 91       	pop	r28
    5386:	df 91       	pop	r29
    5388:	08 95       	ret

0000538a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    538a:	df 93       	push	r29
    538c:	cf 93       	push	r28
    538e:	00 d0       	rcall	.+0      	; 0x5390 <vTaskSuspend+0x6>
    5390:	00 d0       	rcall	.+0      	; 0x5392 <vTaskSuspend+0x8>
    5392:	00 d0       	rcall	.+0      	; 0x5394 <vTaskSuspend+0xa>
    5394:	cd b7       	in	r28, 0x3d	; 61
    5396:	de b7       	in	r29, 0x3e	; 62
    5398:	9c 83       	std	Y+4, r25	; 0x04
    539a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    539c:	0f b6       	in	r0, 0x3f	; 63
    539e:	f8 94       	cli
    53a0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    53a2:	8b 81       	ldd	r24, Y+3	; 0x03
    53a4:	9c 81       	ldd	r25, Y+4	; 0x04
    53a6:	00 97       	sbiw	r24, 0x00	; 0
    53a8:	39 f4       	brne	.+14     	; 0x53b8 <vTaskSuspend+0x2e>
    53aa:	80 91 68 06 	lds	r24, 0x0668
    53ae:	90 91 69 06 	lds	r25, 0x0669
    53b2:	9e 83       	std	Y+6, r25	; 0x06
    53b4:	8d 83       	std	Y+5, r24	; 0x05
    53b6:	04 c0       	rjmp	.+8      	; 0x53c0 <vTaskSuspend+0x36>
    53b8:	8b 81       	ldd	r24, Y+3	; 0x03
    53ba:	9c 81       	ldd	r25, Y+4	; 0x04
    53bc:	9e 83       	std	Y+6, r25	; 0x06
    53be:	8d 83       	std	Y+5, r24	; 0x05
    53c0:	8d 81       	ldd	r24, Y+5	; 0x05
    53c2:	9e 81       	ldd	r25, Y+6	; 0x06
    53c4:	9a 83       	std	Y+2, r25	; 0x02
    53c6:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    53c8:	89 81       	ldd	r24, Y+1	; 0x01
    53ca:	9a 81       	ldd	r25, Y+2	; 0x02
    53cc:	02 96       	adiw	r24, 0x02	; 2
    53ce:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    53d2:	e9 81       	ldd	r30, Y+1	; 0x01
    53d4:	fa 81       	ldd	r31, Y+2	; 0x02
    53d6:	84 89       	ldd	r24, Z+20	; 0x14
    53d8:	95 89       	ldd	r25, Z+21	; 0x15
    53da:	00 97       	sbiw	r24, 0x00	; 0
    53dc:	29 f0       	breq	.+10     	; 0x53e8 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53de:	89 81       	ldd	r24, Y+1	; 0x01
    53e0:	9a 81       	ldd	r25, Y+2	; 0x02
    53e2:	0c 96       	adiw	r24, 0x0c	; 12
    53e4:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    53e8:	89 81       	ldd	r24, Y+1	; 0x01
    53ea:	9a 81       	ldd	r25, Y+2	; 0x02
    53ec:	9c 01       	movw	r18, r24
    53ee:	2e 5f       	subi	r18, 0xFE	; 254
    53f0:	3f 4f       	sbci	r19, 0xFF	; 255
    53f2:	81 ec       	ldi	r24, 0xC1	; 193
    53f4:	96 e0       	ldi	r25, 0x06	; 6
    53f6:	b9 01       	movw	r22, r18
    53f8:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    53fc:	0f 90       	pop	r0
    53fe:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    5400:	20 91 68 06 	lds	r18, 0x0668
    5404:	30 91 69 06 	lds	r19, 0x0669
    5408:	89 81       	ldd	r24, Y+1	; 0x01
    540a:	9a 81       	ldd	r25, Y+2	; 0x02
    540c:	82 17       	cp	r24, r18
    540e:	93 07       	cpc	r25, r19
    5410:	a9 f4       	brne	.+42     	; 0x543c <vTaskSuspend+0xb2>
		{
			if( xSchedulerRunning != pdFALSE )
    5412:	80 91 6f 06 	lds	r24, 0x066F
    5416:	88 23       	and	r24, r24
    5418:	19 f0       	breq	.+6      	; 0x5420 <vTaskSuspend+0x96>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    541a:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    541e:	19 c0       	rjmp	.+50     	; 0x5452 <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    5420:	90 91 c1 06 	lds	r25, 0x06C1
    5424:	80 91 6b 06 	lds	r24, 0x066B
    5428:	98 17       	cp	r25, r24
    542a:	29 f4       	brne	.+10     	; 0x5436 <vTaskSuspend+0xac>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    542c:	10 92 69 06 	sts	0x0669, r1
    5430:	10 92 68 06 	sts	0x0668, r1
    5434:	0e c0       	rjmp	.+28     	; 0x5452 <vTaskSuspend+0xc8>
				}
				else
				{
					vTaskSwitchContext();
    5436:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <vTaskSwitchContext>
    543a:	0b c0       	rjmp	.+22     	; 0x5452 <vTaskSuspend+0xc8>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    543c:	80 91 6f 06 	lds	r24, 0x066F
    5440:	88 23       	and	r24, r24
    5442:	39 f0       	breq	.+14     	; 0x5452 <vTaskSuspend+0xc8>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    5444:	0f b6       	in	r0, 0x3f	; 63
    5446:	f8 94       	cli
    5448:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    544a:	0e 94 34 31 	call	0x6268	; 0x6268 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    544e:	0f 90       	pop	r0
    5450:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    5452:	26 96       	adiw	r28, 0x06	; 6
    5454:	0f b6       	in	r0, 0x3f	; 63
    5456:	f8 94       	cli
    5458:	de bf       	out	0x3e, r29	; 62
    545a:	0f be       	out	0x3f, r0	; 63
    545c:	cd bf       	out	0x3d, r28	; 61
    545e:	cf 91       	pop	r28
    5460:	df 91       	pop	r29
    5462:	08 95       	ret

00005464 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    5464:	df 93       	push	r29
    5466:	cf 93       	push	r28
    5468:	00 d0       	rcall	.+0      	; 0x546a <prvTaskIsTaskSuspended+0x6>
    546a:	00 d0       	rcall	.+0      	; 0x546c <prvTaskIsTaskSuspended+0x8>
    546c:	0f 92       	push	r0
    546e:	cd b7       	in	r28, 0x3d	; 61
    5470:	de b7       	in	r29, 0x3e	; 62
    5472:	9d 83       	std	Y+5, r25	; 0x05
    5474:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    5476:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    5478:	8c 81       	ldd	r24, Y+4	; 0x04
    547a:	9d 81       	ldd	r25, Y+5	; 0x05
    547c:	9a 83       	std	Y+2, r25	; 0x02
    547e:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    5480:	e9 81       	ldd	r30, Y+1	; 0x01
    5482:	fa 81       	ldd	r31, Y+2	; 0x02
    5484:	82 85       	ldd	r24, Z+10	; 0x0a
    5486:	93 85       	ldd	r25, Z+11	; 0x0b
    5488:	26 e0       	ldi	r18, 0x06	; 6
    548a:	81 3c       	cpi	r24, 0xC1	; 193
    548c:	92 07       	cpc	r25, r18
    548e:	81 f4       	brne	.+32     	; 0x54b0 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    5490:	e9 81       	ldd	r30, Y+1	; 0x01
    5492:	fa 81       	ldd	r31, Y+2	; 0x02
    5494:	84 89       	ldd	r24, Z+20	; 0x14
    5496:	95 89       	ldd	r25, Z+21	; 0x15
    5498:	26 e0       	ldi	r18, 0x06	; 6
    549a:	8f 3a       	cpi	r24, 0xAF	; 175
    549c:	92 07       	cpc	r25, r18
    549e:	41 f0       	breq	.+16     	; 0x54b0 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    54a0:	e9 81       	ldd	r30, Y+1	; 0x01
    54a2:	fa 81       	ldd	r31, Y+2	; 0x02
    54a4:	84 89       	ldd	r24, Z+20	; 0x14
    54a6:	95 89       	ldd	r25, Z+21	; 0x15
    54a8:	00 97       	sbiw	r24, 0x00	; 0
    54aa:	11 f4       	brne	.+4      	; 0x54b0 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    54ac:	81 e0       	ldi	r24, 0x01	; 1
    54ae:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    54b0:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    54b2:	0f 90       	pop	r0
    54b4:	0f 90       	pop	r0
    54b6:	0f 90       	pop	r0
    54b8:	0f 90       	pop	r0
    54ba:	0f 90       	pop	r0
    54bc:	cf 91       	pop	r28
    54be:	df 91       	pop	r29
    54c0:	08 95       	ret

000054c2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    54c2:	df 93       	push	r29
    54c4:	cf 93       	push	r28
    54c6:	00 d0       	rcall	.+0      	; 0x54c8 <vTaskResume+0x6>
    54c8:	00 d0       	rcall	.+0      	; 0x54ca <vTaskResume+0x8>
    54ca:	cd b7       	in	r28, 0x3d	; 61
    54cc:	de b7       	in	r29, 0x3e	; 62
    54ce:	9c 83       	std	Y+4, r25	; 0x04
    54d0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    54d2:	8b 81       	ldd	r24, Y+3	; 0x03
    54d4:	9c 81       	ldd	r25, Y+4	; 0x04
    54d6:	9a 83       	std	Y+2, r25	; 0x02
    54d8:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    54da:	89 81       	ldd	r24, Y+1	; 0x01
    54dc:	9a 81       	ldd	r25, Y+2	; 0x02
    54de:	00 97       	sbiw	r24, 0x00	; 0
    54e0:	09 f4       	brne	.+2      	; 0x54e4 <vTaskResume+0x22>
    54e2:	4c c0       	rjmp	.+152    	; 0x557c <vTaskResume+0xba>
    54e4:	20 91 68 06 	lds	r18, 0x0668
    54e8:	30 91 69 06 	lds	r19, 0x0669
    54ec:	89 81       	ldd	r24, Y+1	; 0x01
    54ee:	9a 81       	ldd	r25, Y+2	; 0x02
    54f0:	82 17       	cp	r24, r18
    54f2:	93 07       	cpc	r25, r19
    54f4:	09 f4       	brne	.+2      	; 0x54f8 <vTaskResume+0x36>
    54f6:	42 c0       	rjmp	.+132    	; 0x557c <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    54f8:	0f b6       	in	r0, 0x3f	; 63
    54fa:	f8 94       	cli
    54fc:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    54fe:	89 81       	ldd	r24, Y+1	; 0x01
    5500:	9a 81       	ldd	r25, Y+2	; 0x02
    5502:	0e 94 32 2a 	call	0x5464	; 0x5464 <prvTaskIsTaskSuspended>
    5506:	81 30       	cpi	r24, 0x01	; 1
    5508:	b9 f5       	brne	.+110    	; 0x5578 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    550a:	89 81       	ldd	r24, Y+1	; 0x01
    550c:	9a 81       	ldd	r25, Y+2	; 0x02
    550e:	02 96       	adiw	r24, 0x02	; 2
    5510:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5514:	e9 81       	ldd	r30, Y+1	; 0x01
    5516:	fa 81       	ldd	r31, Y+2	; 0x02
    5518:	96 89       	ldd	r25, Z+22	; 0x16
    551a:	80 91 6e 06 	lds	r24, 0x066E
    551e:	89 17       	cp	r24, r25
    5520:	28 f4       	brcc	.+10     	; 0x552c <vTaskResume+0x6a>
    5522:	e9 81       	ldd	r30, Y+1	; 0x01
    5524:	fa 81       	ldd	r31, Y+2	; 0x02
    5526:	86 89       	ldd	r24, Z+22	; 0x16
    5528:	80 93 6e 06 	sts	0x066E, r24
    552c:	e9 81       	ldd	r30, Y+1	; 0x01
    552e:	fa 81       	ldd	r31, Y+2	; 0x02
    5530:	86 89       	ldd	r24, Z+22	; 0x16
    5532:	28 2f       	mov	r18, r24
    5534:	30 e0       	ldi	r19, 0x00	; 0
    5536:	c9 01       	movw	r24, r18
    5538:	88 0f       	add	r24, r24
    553a:	99 1f       	adc	r25, r25
    553c:	88 0f       	add	r24, r24
    553e:	99 1f       	adc	r25, r25
    5540:	88 0f       	add	r24, r24
    5542:	99 1f       	adc	r25, r25
    5544:	82 0f       	add	r24, r18
    5546:	93 1f       	adc	r25, r19
    5548:	ac 01       	movw	r20, r24
    554a:	4b 58       	subi	r20, 0x8B	; 139
    554c:	59 4f       	sbci	r21, 0xF9	; 249
    554e:	89 81       	ldd	r24, Y+1	; 0x01
    5550:	9a 81       	ldd	r25, Y+2	; 0x02
    5552:	9c 01       	movw	r18, r24
    5554:	2e 5f       	subi	r18, 0xFE	; 254
    5556:	3f 4f       	sbci	r19, 0xFF	; 255
    5558:	ca 01       	movw	r24, r20
    555a:	b9 01       	movw	r22, r18
    555c:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5560:	e9 81       	ldd	r30, Y+1	; 0x01
    5562:	fa 81       	ldd	r31, Y+2	; 0x02
    5564:	96 89       	ldd	r25, Z+22	; 0x16
    5566:	e0 91 68 06 	lds	r30, 0x0668
    556a:	f0 91 69 06 	lds	r31, 0x0669
    556e:	86 89       	ldd	r24, Z+22	; 0x16
    5570:	98 17       	cp	r25, r24
    5572:	10 f0       	brcs	.+4      	; 0x5578 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    5574:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5578:	0f 90       	pop	r0
    557a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    557c:	0f 90       	pop	r0
    557e:	0f 90       	pop	r0
    5580:	0f 90       	pop	r0
    5582:	0f 90       	pop	r0
    5584:	cf 91       	pop	r28
    5586:	df 91       	pop	r29
    5588:	08 95       	ret

0000558a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    558a:	df 93       	push	r29
    558c:	cf 93       	push	r28
    558e:	00 d0       	rcall	.+0      	; 0x5590 <xTaskResumeFromISR+0x6>
    5590:	00 d0       	rcall	.+0      	; 0x5592 <xTaskResumeFromISR+0x8>
    5592:	00 d0       	rcall	.+0      	; 0x5594 <xTaskResumeFromISR+0xa>
    5594:	cd b7       	in	r28, 0x3d	; 61
    5596:	de b7       	in	r29, 0x3e	; 62
    5598:	9e 83       	std	Y+6, r25	; 0x06
    559a:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    559c:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    559e:	8d 81       	ldd	r24, Y+5	; 0x05
    55a0:	9e 81       	ldd	r25, Y+6	; 0x06
    55a2:	9b 83       	std	Y+3, r25	; 0x03
    55a4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    55a6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    55a8:	8a 81       	ldd	r24, Y+2	; 0x02
    55aa:	9b 81       	ldd	r25, Y+3	; 0x03
    55ac:	0e 94 32 2a 	call	0x5464	; 0x5464 <prvTaskIsTaskSuspended>
    55b0:	81 30       	cpi	r24, 0x01	; 1
    55b2:	09 f0       	breq	.+2      	; 0x55b6 <xTaskResumeFromISR+0x2c>
    55b4:	46 c0       	rjmp	.+140    	; 0x5642 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    55b6:	80 91 74 06 	lds	r24, 0x0674
    55ba:	88 23       	and	r24, r24
    55bc:	c1 f5       	brne	.+112    	; 0x562e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    55be:	ea 81       	ldd	r30, Y+2	; 0x02
    55c0:	fb 81       	ldd	r31, Y+3	; 0x03
    55c2:	96 89       	ldd	r25, Z+22	; 0x16
    55c4:	e0 91 68 06 	lds	r30, 0x0668
    55c8:	f0 91 69 06 	lds	r31, 0x0669
    55cc:	86 89       	ldd	r24, Z+22	; 0x16
    55ce:	98 17       	cp	r25, r24
    55d0:	10 f0       	brcs	.+4      	; 0x55d6 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    55d2:	81 e0       	ldi	r24, 0x01	; 1
    55d4:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    55d6:	8a 81       	ldd	r24, Y+2	; 0x02
    55d8:	9b 81       	ldd	r25, Y+3	; 0x03
    55da:	02 96       	adiw	r24, 0x02	; 2
    55dc:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    55e0:	ea 81       	ldd	r30, Y+2	; 0x02
    55e2:	fb 81       	ldd	r31, Y+3	; 0x03
    55e4:	96 89       	ldd	r25, Z+22	; 0x16
    55e6:	80 91 6e 06 	lds	r24, 0x066E
    55ea:	89 17       	cp	r24, r25
    55ec:	28 f4       	brcc	.+10     	; 0x55f8 <xTaskResumeFromISR+0x6e>
    55ee:	ea 81       	ldd	r30, Y+2	; 0x02
    55f0:	fb 81       	ldd	r31, Y+3	; 0x03
    55f2:	86 89       	ldd	r24, Z+22	; 0x16
    55f4:	80 93 6e 06 	sts	0x066E, r24
    55f8:	ea 81       	ldd	r30, Y+2	; 0x02
    55fa:	fb 81       	ldd	r31, Y+3	; 0x03
    55fc:	86 89       	ldd	r24, Z+22	; 0x16
    55fe:	28 2f       	mov	r18, r24
    5600:	30 e0       	ldi	r19, 0x00	; 0
    5602:	c9 01       	movw	r24, r18
    5604:	88 0f       	add	r24, r24
    5606:	99 1f       	adc	r25, r25
    5608:	88 0f       	add	r24, r24
    560a:	99 1f       	adc	r25, r25
    560c:	88 0f       	add	r24, r24
    560e:	99 1f       	adc	r25, r25
    5610:	82 0f       	add	r24, r18
    5612:	93 1f       	adc	r25, r19
    5614:	ac 01       	movw	r20, r24
    5616:	4b 58       	subi	r20, 0x8B	; 139
    5618:	59 4f       	sbci	r21, 0xF9	; 249
    561a:	8a 81       	ldd	r24, Y+2	; 0x02
    561c:	9b 81       	ldd	r25, Y+3	; 0x03
    561e:	9c 01       	movw	r18, r24
    5620:	2e 5f       	subi	r18, 0xFE	; 254
    5622:	3f 4f       	sbci	r19, 0xFF	; 255
    5624:	ca 01       	movw	r24, r20
    5626:	b9 01       	movw	r22, r18
    5628:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
    562c:	0a c0       	rjmp	.+20     	; 0x5642 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    562e:	8a 81       	ldd	r24, Y+2	; 0x02
    5630:	9b 81       	ldd	r25, Y+3	; 0x03
    5632:	9c 01       	movw	r18, r24
    5634:	24 5f       	subi	r18, 0xF4	; 244
    5636:	3f 4f       	sbci	r19, 0xFF	; 255
    5638:	8f ea       	ldi	r24, 0xAF	; 175
    563a:	96 e0       	ldi	r25, 0x06	; 6
    563c:	b9 01       	movw	r22, r18
    563e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    5642:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    5644:	26 96       	adiw	r28, 0x06	; 6
    5646:	0f b6       	in	r0, 0x3f	; 63
    5648:	f8 94       	cli
    564a:	de bf       	out	0x3e, r29	; 62
    564c:	0f be       	out	0x3f, r0	; 63
    564e:	cd bf       	out	0x3d, r28	; 61
    5650:	cf 91       	pop	r28
    5652:	df 91       	pop	r29
    5654:	08 95       	ret

00005656 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5656:	af 92       	push	r10
    5658:	bf 92       	push	r11
    565a:	cf 92       	push	r12
    565c:	df 92       	push	r13
    565e:	ef 92       	push	r14
    5660:	ff 92       	push	r15
    5662:	0f 93       	push	r16
    5664:	df 93       	push	r29
    5666:	cf 93       	push	r28
    5668:	0f 92       	push	r0
    566a:	cd b7       	in	r28, 0x3d	; 61
    566c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    566e:	87 e8       	ldi	r24, 0x87	; 135
    5670:	9f e2       	ldi	r25, 0x2F	; 47
    5672:	28 e7       	ldi	r18, 0x78	; 120
    5674:	30 e0       	ldi	r19, 0x00	; 0
    5676:	b9 01       	movw	r22, r18
    5678:	45 e5       	ldi	r20, 0x55	; 85
    567a:	50 e0       	ldi	r21, 0x00	; 0
    567c:	20 e0       	ldi	r18, 0x00	; 0
    567e:	30 e0       	ldi	r19, 0x00	; 0
    5680:	00 e0       	ldi	r16, 0x00	; 0
    5682:	ee 24       	eor	r14, r14
    5684:	ff 24       	eor	r15, r15
    5686:	cc 24       	eor	r12, r12
    5688:	dd 24       	eor	r13, r13
    568a:	aa 24       	eor	r10, r10
    568c:	bb 24       	eor	r11, r11
    568e:	0e 94 da 26 	call	0x4db4	; 0x4db4 <xTaskGenericCreate>
    5692:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5694:	89 81       	ldd	r24, Y+1	; 0x01
    5696:	81 30       	cpi	r24, 0x01	; 1
    5698:	51 f4       	brne	.+20     	; 0x56ae <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    569a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    569c:	81 e0       	ldi	r24, 0x01	; 1
    569e:	80 93 6f 06 	sts	0x066F, r24
		xTickCount = ( TickType_t ) 0U;
    56a2:	10 92 6d 06 	sts	0x066D, r1
    56a6:	10 92 6c 06 	sts	0x066C, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    56aa:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    56ae:	0f 90       	pop	r0
    56b0:	cf 91       	pop	r28
    56b2:	df 91       	pop	r29
    56b4:	0f 91       	pop	r16
    56b6:	ff 90       	pop	r15
    56b8:	ef 90       	pop	r14
    56ba:	df 90       	pop	r13
    56bc:	cf 90       	pop	r12
    56be:	bf 90       	pop	r11
    56c0:	af 90       	pop	r10
    56c2:	08 95       	ret

000056c4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    56c4:	df 93       	push	r29
    56c6:	cf 93       	push	r28
    56c8:	cd b7       	in	r28, 0x3d	; 61
    56ca:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    56cc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    56ce:	10 92 6f 06 	sts	0x066F, r1
	vPortEndScheduler();
    56d2:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <vPortEndScheduler>
}
    56d6:	cf 91       	pop	r28
    56d8:	df 91       	pop	r29
    56da:	08 95       	ret

000056dc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    56dc:	df 93       	push	r29
    56de:	cf 93       	push	r28
    56e0:	cd b7       	in	r28, 0x3d	; 61
    56e2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    56e4:	80 91 74 06 	lds	r24, 0x0674
    56e8:	8f 5f       	subi	r24, 0xFF	; 255
    56ea:	80 93 74 06 	sts	0x0674, r24
}
    56ee:	cf 91       	pop	r28
    56f0:	df 91       	pop	r29
    56f2:	08 95       	ret

000056f4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    56f4:	df 93       	push	r29
    56f6:	cf 93       	push	r28
    56f8:	00 d0       	rcall	.+0      	; 0x56fa <xTaskResumeAll+0x6>
    56fa:	0f 92       	push	r0
    56fc:	cd b7       	in	r28, 0x3d	; 61
    56fe:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    5700:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5702:	0f b6       	in	r0, 0x3f	; 63
    5704:	f8 94       	cli
    5706:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5708:	80 91 74 06 	lds	r24, 0x0674
    570c:	81 50       	subi	r24, 0x01	; 1
    570e:	80 93 74 06 	sts	0x0674, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5712:	80 91 74 06 	lds	r24, 0x0674
    5716:	88 23       	and	r24, r24
    5718:	09 f0       	breq	.+2      	; 0x571c <xTaskResumeAll+0x28>
    571a:	6d c0       	rjmp	.+218    	; 0x57f6 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    571c:	80 91 6b 06 	lds	r24, 0x066B
    5720:	88 23       	and	r24, r24
    5722:	09 f4       	brne	.+2      	; 0x5726 <xTaskResumeAll+0x32>
    5724:	68 c0       	rjmp	.+208    	; 0x57f6 <xTaskResumeAll+0x102>
    5726:	45 c0       	rjmp	.+138    	; 0x57b2 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    5728:	e0 91 b4 06 	lds	r30, 0x06B4
    572c:	f0 91 b5 06 	lds	r31, 0x06B5
    5730:	86 81       	ldd	r24, Z+6	; 0x06
    5732:	97 81       	ldd	r25, Z+7	; 0x07
    5734:	9b 83       	std	Y+3, r25	; 0x03
    5736:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5738:	8a 81       	ldd	r24, Y+2	; 0x02
    573a:	9b 81       	ldd	r25, Y+3	; 0x03
    573c:	0c 96       	adiw	r24, 0x0c	; 12
    573e:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5742:	8a 81       	ldd	r24, Y+2	; 0x02
    5744:	9b 81       	ldd	r25, Y+3	; 0x03
    5746:	02 96       	adiw	r24, 0x02	; 2
    5748:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    574c:	ea 81       	ldd	r30, Y+2	; 0x02
    574e:	fb 81       	ldd	r31, Y+3	; 0x03
    5750:	96 89       	ldd	r25, Z+22	; 0x16
    5752:	80 91 6e 06 	lds	r24, 0x066E
    5756:	89 17       	cp	r24, r25
    5758:	28 f4       	brcc	.+10     	; 0x5764 <xTaskResumeAll+0x70>
    575a:	ea 81       	ldd	r30, Y+2	; 0x02
    575c:	fb 81       	ldd	r31, Y+3	; 0x03
    575e:	86 89       	ldd	r24, Z+22	; 0x16
    5760:	80 93 6e 06 	sts	0x066E, r24
    5764:	ea 81       	ldd	r30, Y+2	; 0x02
    5766:	fb 81       	ldd	r31, Y+3	; 0x03
    5768:	86 89       	ldd	r24, Z+22	; 0x16
    576a:	28 2f       	mov	r18, r24
    576c:	30 e0       	ldi	r19, 0x00	; 0
    576e:	c9 01       	movw	r24, r18
    5770:	88 0f       	add	r24, r24
    5772:	99 1f       	adc	r25, r25
    5774:	88 0f       	add	r24, r24
    5776:	99 1f       	adc	r25, r25
    5778:	88 0f       	add	r24, r24
    577a:	99 1f       	adc	r25, r25
    577c:	82 0f       	add	r24, r18
    577e:	93 1f       	adc	r25, r19
    5780:	ac 01       	movw	r20, r24
    5782:	4b 58       	subi	r20, 0x8B	; 139
    5784:	59 4f       	sbci	r21, 0xF9	; 249
    5786:	8a 81       	ldd	r24, Y+2	; 0x02
    5788:	9b 81       	ldd	r25, Y+3	; 0x03
    578a:	9c 01       	movw	r18, r24
    578c:	2e 5f       	subi	r18, 0xFE	; 254
    578e:	3f 4f       	sbci	r19, 0xFF	; 255
    5790:	ca 01       	movw	r24, r20
    5792:	b9 01       	movw	r22, r18
    5794:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5798:	ea 81       	ldd	r30, Y+2	; 0x02
    579a:	fb 81       	ldd	r31, Y+3	; 0x03
    579c:	96 89       	ldd	r25, Z+22	; 0x16
    579e:	e0 91 68 06 	lds	r30, 0x0668
    57a2:	f0 91 69 06 	lds	r31, 0x0669
    57a6:	86 89       	ldd	r24, Z+22	; 0x16
    57a8:	98 17       	cp	r25, r24
    57aa:	18 f0       	brcs	.+6      	; 0x57b2 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    57ac:	81 e0       	ldi	r24, 0x01	; 1
    57ae:	80 93 71 06 	sts	0x0671, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    57b2:	80 91 af 06 	lds	r24, 0x06AF
    57b6:	88 23       	and	r24, r24
    57b8:	09 f0       	breq	.+2      	; 0x57bc <xTaskResumeAll+0xc8>
    57ba:	b6 cf       	rjmp	.-148    	; 0x5728 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    57bc:	80 91 70 06 	lds	r24, 0x0670
    57c0:	88 23       	and	r24, r24
    57c2:	89 f0       	breq	.+34     	; 0x57e6 <xTaskResumeAll+0xf2>
    57c4:	0c c0       	rjmp	.+24     	; 0x57de <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    57c6:	0e 94 39 2c 	call	0x5872	; 0x5872 <xTaskIncrementTick>
    57ca:	88 23       	and	r24, r24
    57cc:	19 f0       	breq	.+6      	; 0x57d4 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    57ce:	81 e0       	ldi	r24, 0x01	; 1
    57d0:	80 93 71 06 	sts	0x0671, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    57d4:	80 91 70 06 	lds	r24, 0x0670
    57d8:	81 50       	subi	r24, 0x01	; 1
    57da:	80 93 70 06 	sts	0x0670, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    57de:	80 91 70 06 	lds	r24, 0x0670
    57e2:	88 23       	and	r24, r24
    57e4:	81 f7       	brne	.-32     	; 0x57c6 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    57e6:	80 91 71 06 	lds	r24, 0x0671
    57ea:	81 30       	cpi	r24, 0x01	; 1
    57ec:	21 f4       	brne	.+8      	; 0x57f6 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    57ee:	81 e0       	ldi	r24, 0x01	; 1
    57f0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    57f2:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    57f6:	0f 90       	pop	r0
    57f8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    57fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    57fc:	0f 90       	pop	r0
    57fe:	0f 90       	pop	r0
    5800:	0f 90       	pop	r0
    5802:	cf 91       	pop	r28
    5804:	df 91       	pop	r29
    5806:	08 95       	ret

00005808 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5808:	df 93       	push	r29
    580a:	cf 93       	push	r28
    580c:	00 d0       	rcall	.+0      	; 0x580e <xTaskGetTickCount+0x6>
    580e:	cd b7       	in	r28, 0x3d	; 61
    5810:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    5812:	0f b6       	in	r0, 0x3f	; 63
    5814:	f8 94       	cli
    5816:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5818:	80 91 6c 06 	lds	r24, 0x066C
    581c:	90 91 6d 06 	lds	r25, 0x066D
    5820:	9a 83       	std	Y+2, r25	; 0x02
    5822:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5824:	0f 90       	pop	r0
    5826:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5828:	89 81       	ldd	r24, Y+1	; 0x01
    582a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    582c:	0f 90       	pop	r0
    582e:	0f 90       	pop	r0
    5830:	cf 91       	pop	r28
    5832:	df 91       	pop	r29
    5834:	08 95       	ret

00005836 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5836:	df 93       	push	r29
    5838:	cf 93       	push	r28
    583a:	00 d0       	rcall	.+0      	; 0x583c <xTaskGetTickCountFromISR+0x6>
    583c:	0f 92       	push	r0
    583e:	cd b7       	in	r28, 0x3d	; 61
    5840:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5842:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    5844:	80 91 6c 06 	lds	r24, 0x066C
    5848:	90 91 6d 06 	lds	r25, 0x066D
    584c:	9b 83       	std	Y+3, r25	; 0x03
    584e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5850:	8a 81       	ldd	r24, Y+2	; 0x02
    5852:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5854:	0f 90       	pop	r0
    5856:	0f 90       	pop	r0
    5858:	0f 90       	pop	r0
    585a:	cf 91       	pop	r28
    585c:	df 91       	pop	r29
    585e:	08 95       	ret

00005860 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5860:	df 93       	push	r29
    5862:	cf 93       	push	r28
    5864:	cd b7       	in	r28, 0x3d	; 61
    5866:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    5868:	80 91 6b 06 	lds	r24, 0x066B
}
    586c:	cf 91       	pop	r28
    586e:	df 91       	pop	r29
    5870:	08 95       	ret

00005872 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5872:	df 93       	push	r29
    5874:	cf 93       	push	r28
    5876:	cd b7       	in	r28, 0x3d	; 61
    5878:	de b7       	in	r29, 0x3e	; 62
    587a:	29 97       	sbiw	r28, 0x09	; 9
    587c:	0f b6       	in	r0, 0x3f	; 63
    587e:	f8 94       	cli
    5880:	de bf       	out	0x3e, r29	; 62
    5882:	0f be       	out	0x3f, r0	; 63
    5884:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5886:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5888:	80 91 74 06 	lds	r24, 0x0674
    588c:	88 23       	and	r24, r24
    588e:	09 f0       	breq	.+2      	; 0x5892 <xTaskIncrementTick+0x20>
    5890:	c2 c0       	rjmp	.+388    	; 0x5a16 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    5892:	80 91 6c 06 	lds	r24, 0x066C
    5896:	90 91 6d 06 	lds	r25, 0x066D
    589a:	01 96       	adiw	r24, 0x01	; 1
    589c:	90 93 6d 06 	sts	0x066D, r25
    58a0:	80 93 6c 06 	sts	0x066C, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    58a4:	80 91 6c 06 	lds	r24, 0x066C
    58a8:	90 91 6d 06 	lds	r25, 0x066D
    58ac:	9c 83       	std	Y+4, r25	; 0x04
    58ae:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    58b0:	8b 81       	ldd	r24, Y+3	; 0x03
    58b2:	9c 81       	ldd	r25, Y+4	; 0x04
    58b4:	00 97       	sbiw	r24, 0x00	; 0
    58b6:	d9 f4       	brne	.+54     	; 0x58ee <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    58b8:	80 91 ab 06 	lds	r24, 0x06AB
    58bc:	90 91 ac 06 	lds	r25, 0x06AC
    58c0:	9a 83       	std	Y+2, r25	; 0x02
    58c2:	89 83       	std	Y+1, r24	; 0x01
    58c4:	80 91 ad 06 	lds	r24, 0x06AD
    58c8:	90 91 ae 06 	lds	r25, 0x06AE
    58cc:	90 93 ac 06 	sts	0x06AC, r25
    58d0:	80 93 ab 06 	sts	0x06AB, r24
    58d4:	89 81       	ldd	r24, Y+1	; 0x01
    58d6:	9a 81       	ldd	r25, Y+2	; 0x02
    58d8:	90 93 ae 06 	sts	0x06AE, r25
    58dc:	80 93 ad 06 	sts	0x06AD, r24
    58e0:	80 91 72 06 	lds	r24, 0x0672
    58e4:	8f 5f       	subi	r24, 0xFF	; 255
    58e6:	80 93 72 06 	sts	0x0672, r24
    58ea:	0e 94 34 31 	call	0x6268	; 0x6268 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    58ee:	20 91 95 01 	lds	r18, 0x0195
    58f2:	30 91 96 01 	lds	r19, 0x0196
    58f6:	8b 81       	ldd	r24, Y+3	; 0x03
    58f8:	9c 81       	ldd	r25, Y+4	; 0x04
    58fa:	82 17       	cp	r24, r18
    58fc:	93 07       	cpc	r25, r19
    58fe:	08 f4       	brcc	.+2      	; 0x5902 <xTaskIncrementTick+0x90>
    5900:	71 c0       	rjmp	.+226    	; 0x59e4 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5902:	e0 91 ab 06 	lds	r30, 0x06AB
    5906:	f0 91 ac 06 	lds	r31, 0x06AC
    590a:	80 81       	ld	r24, Z
    590c:	88 23       	and	r24, r24
    590e:	39 f4       	brne	.+14     	; 0x591e <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    5910:	8f ef       	ldi	r24, 0xFF	; 255
    5912:	9f ef       	ldi	r25, 0xFF	; 255
    5914:	90 93 96 01 	sts	0x0196, r25
    5918:	80 93 95 01 	sts	0x0195, r24
    591c:	63 c0       	rjmp	.+198    	; 0x59e4 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    591e:	e0 91 ab 06 	lds	r30, 0x06AB
    5922:	f0 91 ac 06 	lds	r31, 0x06AC
    5926:	05 80       	ldd	r0, Z+5	; 0x05
    5928:	f6 81       	ldd	r31, Z+6	; 0x06
    592a:	e0 2d       	mov	r30, r0
    592c:	86 81       	ldd	r24, Z+6	; 0x06
    592e:	97 81       	ldd	r25, Z+7	; 0x07
    5930:	99 87       	std	Y+9, r25	; 0x09
    5932:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5934:	e8 85       	ldd	r30, Y+8	; 0x08
    5936:	f9 85       	ldd	r31, Y+9	; 0x09
    5938:	82 81       	ldd	r24, Z+2	; 0x02
    593a:	93 81       	ldd	r25, Z+3	; 0x03
    593c:	9f 83       	std	Y+7, r25	; 0x07
    593e:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    5940:	2b 81       	ldd	r18, Y+3	; 0x03
    5942:	3c 81       	ldd	r19, Y+4	; 0x04
    5944:	8e 81       	ldd	r24, Y+6	; 0x06
    5946:	9f 81       	ldd	r25, Y+7	; 0x07
    5948:	28 17       	cp	r18, r24
    594a:	39 07       	cpc	r19, r25
    594c:	38 f4       	brcc	.+14     	; 0x595c <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    594e:	8e 81       	ldd	r24, Y+6	; 0x06
    5950:	9f 81       	ldd	r25, Y+7	; 0x07
    5952:	90 93 96 01 	sts	0x0196, r25
    5956:	80 93 95 01 	sts	0x0195, r24
    595a:	44 c0       	rjmp	.+136    	; 0x59e4 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    595c:	88 85       	ldd	r24, Y+8	; 0x08
    595e:	99 85       	ldd	r25, Y+9	; 0x09
    5960:	02 96       	adiw	r24, 0x02	; 2
    5962:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5966:	e8 85       	ldd	r30, Y+8	; 0x08
    5968:	f9 85       	ldd	r31, Y+9	; 0x09
    596a:	84 89       	ldd	r24, Z+20	; 0x14
    596c:	95 89       	ldd	r25, Z+21	; 0x15
    596e:	00 97       	sbiw	r24, 0x00	; 0
    5970:	29 f0       	breq	.+10     	; 0x597c <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5972:	88 85       	ldd	r24, Y+8	; 0x08
    5974:	99 85       	ldd	r25, Y+9	; 0x09
    5976:	0c 96       	adiw	r24, 0x0c	; 12
    5978:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    597c:	e8 85       	ldd	r30, Y+8	; 0x08
    597e:	f9 85       	ldd	r31, Y+9	; 0x09
    5980:	96 89       	ldd	r25, Z+22	; 0x16
    5982:	80 91 6e 06 	lds	r24, 0x066E
    5986:	89 17       	cp	r24, r25
    5988:	28 f4       	brcc	.+10     	; 0x5994 <xTaskIncrementTick+0x122>
    598a:	e8 85       	ldd	r30, Y+8	; 0x08
    598c:	f9 85       	ldd	r31, Y+9	; 0x09
    598e:	86 89       	ldd	r24, Z+22	; 0x16
    5990:	80 93 6e 06 	sts	0x066E, r24
    5994:	e8 85       	ldd	r30, Y+8	; 0x08
    5996:	f9 85       	ldd	r31, Y+9	; 0x09
    5998:	86 89       	ldd	r24, Z+22	; 0x16
    599a:	28 2f       	mov	r18, r24
    599c:	30 e0       	ldi	r19, 0x00	; 0
    599e:	c9 01       	movw	r24, r18
    59a0:	88 0f       	add	r24, r24
    59a2:	99 1f       	adc	r25, r25
    59a4:	88 0f       	add	r24, r24
    59a6:	99 1f       	adc	r25, r25
    59a8:	88 0f       	add	r24, r24
    59aa:	99 1f       	adc	r25, r25
    59ac:	82 0f       	add	r24, r18
    59ae:	93 1f       	adc	r25, r19
    59b0:	ac 01       	movw	r20, r24
    59b2:	4b 58       	subi	r20, 0x8B	; 139
    59b4:	59 4f       	sbci	r21, 0xF9	; 249
    59b6:	88 85       	ldd	r24, Y+8	; 0x08
    59b8:	99 85       	ldd	r25, Y+9	; 0x09
    59ba:	9c 01       	movw	r18, r24
    59bc:	2e 5f       	subi	r18, 0xFE	; 254
    59be:	3f 4f       	sbci	r19, 0xFF	; 255
    59c0:	ca 01       	movw	r24, r20
    59c2:	b9 01       	movw	r22, r18
    59c4:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    59c8:	e8 85       	ldd	r30, Y+8	; 0x08
    59ca:	f9 85       	ldd	r31, Y+9	; 0x09
    59cc:	96 89       	ldd	r25, Z+22	; 0x16
    59ce:	e0 91 68 06 	lds	r30, 0x0668
    59d2:	f0 91 69 06 	lds	r31, 0x0669
    59d6:	86 89       	ldd	r24, Z+22	; 0x16
    59d8:	98 17       	cp	r25, r24
    59da:	08 f4       	brcc	.+2      	; 0x59de <xTaskIncrementTick+0x16c>
    59dc:	92 cf       	rjmp	.-220    	; 0x5902 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    59de:	81 e0       	ldi	r24, 0x01	; 1
    59e0:	8d 83       	std	Y+5, r24	; 0x05
    59e2:	8f cf       	rjmp	.-226    	; 0x5902 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    59e4:	e0 91 68 06 	lds	r30, 0x0668
    59e8:	f0 91 69 06 	lds	r31, 0x0669
    59ec:	86 89       	ldd	r24, Z+22	; 0x16
    59ee:	28 2f       	mov	r18, r24
    59f0:	30 e0       	ldi	r19, 0x00	; 0
    59f2:	c9 01       	movw	r24, r18
    59f4:	88 0f       	add	r24, r24
    59f6:	99 1f       	adc	r25, r25
    59f8:	88 0f       	add	r24, r24
    59fa:	99 1f       	adc	r25, r25
    59fc:	88 0f       	add	r24, r24
    59fe:	99 1f       	adc	r25, r25
    5a00:	82 0f       	add	r24, r18
    5a02:	93 1f       	adc	r25, r19
    5a04:	fc 01       	movw	r30, r24
    5a06:	eb 58       	subi	r30, 0x8B	; 139
    5a08:	f9 4f       	sbci	r31, 0xF9	; 249
    5a0a:	80 81       	ld	r24, Z
    5a0c:	82 30       	cpi	r24, 0x02	; 2
    5a0e:	40 f0       	brcs	.+16     	; 0x5a20 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    5a10:	81 e0       	ldi	r24, 0x01	; 1
    5a12:	8d 83       	std	Y+5, r24	; 0x05
    5a14:	05 c0       	rjmp	.+10     	; 0x5a20 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5a16:	80 91 70 06 	lds	r24, 0x0670
    5a1a:	8f 5f       	subi	r24, 0xFF	; 255
    5a1c:	80 93 70 06 	sts	0x0670, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5a20:	80 91 71 06 	lds	r24, 0x0671
    5a24:	88 23       	and	r24, r24
    5a26:	11 f0       	breq	.+4      	; 0x5a2c <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    5a28:	81 e0       	ldi	r24, 0x01	; 1
    5a2a:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    5a2c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5a2e:	29 96       	adiw	r28, 0x09	; 9
    5a30:	0f b6       	in	r0, 0x3f	; 63
    5a32:	f8 94       	cli
    5a34:	de bf       	out	0x3e, r29	; 62
    5a36:	0f be       	out	0x3f, r0	; 63
    5a38:	cd bf       	out	0x3d, r28	; 61
    5a3a:	cf 91       	pop	r28
    5a3c:	df 91       	pop	r29
    5a3e:	08 95       	ret

00005a40 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5a40:	df 93       	push	r29
    5a42:	cf 93       	push	r28
    5a44:	00 d0       	rcall	.+0      	; 0x5a46 <vTaskSwitchContext+0x6>
    5a46:	cd b7       	in	r28, 0x3d	; 61
    5a48:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5a4a:	80 91 74 06 	lds	r24, 0x0674
    5a4e:	88 23       	and	r24, r24
    5a50:	21 f0       	breq	.+8      	; 0x5a5a <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	80 93 71 06 	sts	0x0671, r24
    5a58:	57 c0       	rjmp	.+174    	; 0x5b08 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    5a5a:	10 92 71 06 	sts	0x0671, r1
    5a5e:	05 c0       	rjmp	.+10     	; 0x5a6a <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    5a60:	80 91 6e 06 	lds	r24, 0x066E
    5a64:	81 50       	subi	r24, 0x01	; 1
    5a66:	80 93 6e 06 	sts	0x066E, r24
    5a6a:	80 91 6e 06 	lds	r24, 0x066E
    5a6e:	28 2f       	mov	r18, r24
    5a70:	30 e0       	ldi	r19, 0x00	; 0
    5a72:	c9 01       	movw	r24, r18
    5a74:	88 0f       	add	r24, r24
    5a76:	99 1f       	adc	r25, r25
    5a78:	88 0f       	add	r24, r24
    5a7a:	99 1f       	adc	r25, r25
    5a7c:	88 0f       	add	r24, r24
    5a7e:	99 1f       	adc	r25, r25
    5a80:	82 0f       	add	r24, r18
    5a82:	93 1f       	adc	r25, r19
    5a84:	fc 01       	movw	r30, r24
    5a86:	eb 58       	subi	r30, 0x8B	; 139
    5a88:	f9 4f       	sbci	r31, 0xF9	; 249
    5a8a:	80 81       	ld	r24, Z
    5a8c:	88 23       	and	r24, r24
    5a8e:	41 f3       	breq	.-48     	; 0x5a60 <vTaskSwitchContext+0x20>
    5a90:	80 91 6e 06 	lds	r24, 0x066E
    5a94:	28 2f       	mov	r18, r24
    5a96:	30 e0       	ldi	r19, 0x00	; 0
    5a98:	c9 01       	movw	r24, r18
    5a9a:	88 0f       	add	r24, r24
    5a9c:	99 1f       	adc	r25, r25
    5a9e:	88 0f       	add	r24, r24
    5aa0:	99 1f       	adc	r25, r25
    5aa2:	88 0f       	add	r24, r24
    5aa4:	99 1f       	adc	r25, r25
    5aa6:	82 0f       	add	r24, r18
    5aa8:	93 1f       	adc	r25, r19
    5aaa:	8b 58       	subi	r24, 0x8B	; 139
    5aac:	99 4f       	sbci	r25, 0xF9	; 249
    5aae:	9a 83       	std	Y+2, r25	; 0x02
    5ab0:	89 83       	std	Y+1, r24	; 0x01
    5ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab6:	01 80       	ldd	r0, Z+1	; 0x01
    5ab8:	f2 81       	ldd	r31, Z+2	; 0x02
    5aba:	e0 2d       	mov	r30, r0
    5abc:	82 81       	ldd	r24, Z+2	; 0x02
    5abe:	93 81       	ldd	r25, Z+3	; 0x03
    5ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    5ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    5ac4:	92 83       	std	Z+2, r25	; 0x02
    5ac6:	81 83       	std	Z+1, r24	; 0x01
    5ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    5aca:	fa 81       	ldd	r31, Y+2	; 0x02
    5acc:	21 81       	ldd	r18, Z+1	; 0x01
    5ace:	32 81       	ldd	r19, Z+2	; 0x02
    5ad0:	89 81       	ldd	r24, Y+1	; 0x01
    5ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ad4:	03 96       	adiw	r24, 0x03	; 3
    5ad6:	28 17       	cp	r18, r24
    5ad8:	39 07       	cpc	r19, r25
    5ada:	59 f4       	brne	.+22     	; 0x5af2 <vTaskSwitchContext+0xb2>
    5adc:	e9 81       	ldd	r30, Y+1	; 0x01
    5ade:	fa 81       	ldd	r31, Y+2	; 0x02
    5ae0:	01 80       	ldd	r0, Z+1	; 0x01
    5ae2:	f2 81       	ldd	r31, Z+2	; 0x02
    5ae4:	e0 2d       	mov	r30, r0
    5ae6:	82 81       	ldd	r24, Z+2	; 0x02
    5ae8:	93 81       	ldd	r25, Z+3	; 0x03
    5aea:	e9 81       	ldd	r30, Y+1	; 0x01
    5aec:	fa 81       	ldd	r31, Y+2	; 0x02
    5aee:	92 83       	std	Z+2, r25	; 0x02
    5af0:	81 83       	std	Z+1, r24	; 0x01
    5af2:	e9 81       	ldd	r30, Y+1	; 0x01
    5af4:	fa 81       	ldd	r31, Y+2	; 0x02
    5af6:	01 80       	ldd	r0, Z+1	; 0x01
    5af8:	f2 81       	ldd	r31, Z+2	; 0x02
    5afa:	e0 2d       	mov	r30, r0
    5afc:	86 81       	ldd	r24, Z+6	; 0x06
    5afe:	97 81       	ldd	r25, Z+7	; 0x07
    5b00:	90 93 69 06 	sts	0x0669, r25
    5b04:	80 93 68 06 	sts	0x0668, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5b08:	0f 90       	pop	r0
    5b0a:	0f 90       	pop	r0
    5b0c:	cf 91       	pop	r28
    5b0e:	df 91       	pop	r29
    5b10:	08 95       	ret

00005b12 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5b12:	df 93       	push	r29
    5b14:	cf 93       	push	r28
    5b16:	00 d0       	rcall	.+0      	; 0x5b18 <vTaskPlaceOnEventList+0x6>
    5b18:	00 d0       	rcall	.+0      	; 0x5b1a <vTaskPlaceOnEventList+0x8>
    5b1a:	00 d0       	rcall	.+0      	; 0x5b1c <vTaskPlaceOnEventList+0xa>
    5b1c:	cd b7       	in	r28, 0x3d	; 61
    5b1e:	de b7       	in	r29, 0x3e	; 62
    5b20:	9c 83       	std	Y+4, r25	; 0x04
    5b22:	8b 83       	std	Y+3, r24	; 0x03
    5b24:	7e 83       	std	Y+6, r23	; 0x06
    5b26:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5b28:	80 91 68 06 	lds	r24, 0x0668
    5b2c:	90 91 69 06 	lds	r25, 0x0669
    5b30:	9c 01       	movw	r18, r24
    5b32:	24 5f       	subi	r18, 0xF4	; 244
    5b34:	3f 4f       	sbci	r19, 0xFF	; 255
    5b36:	8b 81       	ldd	r24, Y+3	; 0x03
    5b38:	9c 81       	ldd	r25, Y+4	; 0x04
    5b3a:	b9 01       	movw	r22, r18
    5b3c:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5b40:	80 91 68 06 	lds	r24, 0x0668
    5b44:	90 91 69 06 	lds	r25, 0x0669
    5b48:	02 96       	adiw	r24, 0x02	; 2
    5b4a:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    5b4e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b50:	9e 81       	ldd	r25, Y+6	; 0x06
    5b52:	2f ef       	ldi	r18, 0xFF	; 255
    5b54:	8f 3f       	cpi	r24, 0xFF	; 255
    5b56:	92 07       	cpc	r25, r18
    5b58:	69 f4       	brne	.+26     	; 0x5b74 <vTaskPlaceOnEventList+0x62>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5b5a:	80 91 68 06 	lds	r24, 0x0668
    5b5e:	90 91 69 06 	lds	r25, 0x0669
    5b62:	9c 01       	movw	r18, r24
    5b64:	2e 5f       	subi	r18, 0xFE	; 254
    5b66:	3f 4f       	sbci	r19, 0xFF	; 255
    5b68:	81 ec       	ldi	r24, 0xC1	; 193
    5b6a:	96 e0       	ldi	r25, 0x06	; 6
    5b6c:	b9 01       	movw	r22, r18
    5b6e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
    5b72:	0e c0       	rjmp	.+28     	; 0x5b90 <vTaskPlaceOnEventList+0x7e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    5b74:	20 91 6c 06 	lds	r18, 0x066C
    5b78:	30 91 6d 06 	lds	r19, 0x066D
    5b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    5b7e:	9e 81       	ldd	r25, Y+6	; 0x06
    5b80:	82 0f       	add	r24, r18
    5b82:	93 1f       	adc	r25, r19
    5b84:	9a 83       	std	Y+2, r25	; 0x02
    5b86:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5b88:	89 81       	ldd	r24, Y+1	; 0x01
    5b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    5b8c:	0e 94 91 30 	call	0x6122	; 0x6122 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5b90:	26 96       	adiw	r28, 0x06	; 6
    5b92:	0f b6       	in	r0, 0x3f	; 63
    5b94:	f8 94       	cli
    5b96:	de bf       	out	0x3e, r29	; 62
    5b98:	0f be       	out	0x3f, r0	; 63
    5b9a:	cd bf       	out	0x3d, r28	; 61
    5b9c:	cf 91       	pop	r28
    5b9e:	df 91       	pop	r29
    5ba0:	08 95       	ret

00005ba2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5ba2:	df 93       	push	r29
    5ba4:	cf 93       	push	r28
    5ba6:	cd b7       	in	r28, 0x3d	; 61
    5ba8:	de b7       	in	r29, 0x3e	; 62
    5baa:	28 97       	sbiw	r28, 0x08	; 8
    5bac:	0f b6       	in	r0, 0x3f	; 63
    5bae:	f8 94       	cli
    5bb0:	de bf       	out	0x3e, r29	; 62
    5bb2:	0f be       	out	0x3f, r0	; 63
    5bb4:	cd bf       	out	0x3d, r28	; 61
    5bb6:	9c 83       	std	Y+4, r25	; 0x04
    5bb8:	8b 83       	std	Y+3, r24	; 0x03
    5bba:	7e 83       	std	Y+6, r23	; 0x06
    5bbc:	6d 83       	std	Y+5, r22	; 0x05
    5bbe:	58 87       	std	Y+8, r21	; 0x08
    5bc0:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5bc2:	e0 91 68 06 	lds	r30, 0x0668
    5bc6:	f0 91 69 06 	lds	r31, 0x0669
    5bca:	8d 81       	ldd	r24, Y+5	; 0x05
    5bcc:	9e 81       	ldd	r25, Y+6	; 0x06
    5bce:	90 68       	ori	r25, 0x80	; 128
    5bd0:	95 87       	std	Z+13, r25	; 0x0d
    5bd2:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5bd4:	80 91 68 06 	lds	r24, 0x0668
    5bd8:	90 91 69 06 	lds	r25, 0x0669
    5bdc:	9c 01       	movw	r18, r24
    5bde:	24 5f       	subi	r18, 0xF4	; 244
    5be0:	3f 4f       	sbci	r19, 0xFF	; 255
    5be2:	8b 81       	ldd	r24, Y+3	; 0x03
    5be4:	9c 81       	ldd	r25, Y+4	; 0x04
    5be6:	b9 01       	movw	r22, r18
    5be8:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5bec:	80 91 68 06 	lds	r24, 0x0668
    5bf0:	90 91 69 06 	lds	r25, 0x0669
    5bf4:	02 96       	adiw	r24, 0x02	; 2
    5bf6:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    5bfa:	8f 81       	ldd	r24, Y+7	; 0x07
    5bfc:	98 85       	ldd	r25, Y+8	; 0x08
    5bfe:	2f ef       	ldi	r18, 0xFF	; 255
    5c00:	8f 3f       	cpi	r24, 0xFF	; 255
    5c02:	92 07       	cpc	r25, r18
    5c04:	69 f4       	brne	.+26     	; 0x5c20 <vTaskPlaceOnUnorderedEventList+0x7e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5c06:	80 91 68 06 	lds	r24, 0x0668
    5c0a:	90 91 69 06 	lds	r25, 0x0669
    5c0e:	9c 01       	movw	r18, r24
    5c10:	2e 5f       	subi	r18, 0xFE	; 254
    5c12:	3f 4f       	sbci	r19, 0xFF	; 255
    5c14:	81 ec       	ldi	r24, 0xC1	; 193
    5c16:	96 e0       	ldi	r25, 0x06	; 6
    5c18:	b9 01       	movw	r22, r18
    5c1a:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
    5c1e:	0e c0       	rjmp	.+28     	; 0x5c3c <vTaskPlaceOnUnorderedEventList+0x9a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    5c20:	20 91 6c 06 	lds	r18, 0x066C
    5c24:	30 91 6d 06 	lds	r19, 0x066D
    5c28:	8f 81       	ldd	r24, Y+7	; 0x07
    5c2a:	98 85       	ldd	r25, Y+8	; 0x08
    5c2c:	82 0f       	add	r24, r18
    5c2e:	93 1f       	adc	r25, r19
    5c30:	9a 83       	std	Y+2, r25	; 0x02
    5c32:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5c34:	89 81       	ldd	r24, Y+1	; 0x01
    5c36:	9a 81       	ldd	r25, Y+2	; 0x02
    5c38:	0e 94 91 30 	call	0x6122	; 0x6122 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5c3c:	28 96       	adiw	r28, 0x08	; 8
    5c3e:	0f b6       	in	r0, 0x3f	; 63
    5c40:	f8 94       	cli
    5c42:	de bf       	out	0x3e, r29	; 62
    5c44:	0f be       	out	0x3f, r0	; 63
    5c46:	cd bf       	out	0x3d, r28	; 61
    5c48:	cf 91       	pop	r28
    5c4a:	df 91       	pop	r29
    5c4c:	08 95       	ret

00005c4e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5c4e:	df 93       	push	r29
    5c50:	cf 93       	push	r28
    5c52:	00 d0       	rcall	.+0      	; 0x5c54 <xTaskRemoveFromEventList+0x6>
    5c54:	00 d0       	rcall	.+0      	; 0x5c56 <xTaskRemoveFromEventList+0x8>
    5c56:	0f 92       	push	r0
    5c58:	cd b7       	in	r28, 0x3d	; 61
    5c5a:	de b7       	in	r29, 0x3e	; 62
    5c5c:	9d 83       	std	Y+5, r25	; 0x05
    5c5e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5c60:	ec 81       	ldd	r30, Y+4	; 0x04
    5c62:	fd 81       	ldd	r31, Y+5	; 0x05
    5c64:	05 80       	ldd	r0, Z+5	; 0x05
    5c66:	f6 81       	ldd	r31, Z+6	; 0x06
    5c68:	e0 2d       	mov	r30, r0
    5c6a:	86 81       	ldd	r24, Z+6	; 0x06
    5c6c:	97 81       	ldd	r25, Z+7	; 0x07
    5c6e:	9b 83       	std	Y+3, r25	; 0x03
    5c70:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5c72:	8a 81       	ldd	r24, Y+2	; 0x02
    5c74:	9b 81       	ldd	r25, Y+3	; 0x03
    5c76:	0c 96       	adiw	r24, 0x0c	; 12
    5c78:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c7c:	80 91 74 06 	lds	r24, 0x0674
    5c80:	88 23       	and	r24, r24
    5c82:	61 f5       	brne	.+88     	; 0x5cdc <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5c84:	8a 81       	ldd	r24, Y+2	; 0x02
    5c86:	9b 81       	ldd	r25, Y+3	; 0x03
    5c88:	02 96       	adiw	r24, 0x02	; 2
    5c8a:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5c8e:	ea 81       	ldd	r30, Y+2	; 0x02
    5c90:	fb 81       	ldd	r31, Y+3	; 0x03
    5c92:	96 89       	ldd	r25, Z+22	; 0x16
    5c94:	80 91 6e 06 	lds	r24, 0x066E
    5c98:	89 17       	cp	r24, r25
    5c9a:	28 f4       	brcc	.+10     	; 0x5ca6 <xTaskRemoveFromEventList+0x58>
    5c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    5c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    5ca0:	86 89       	ldd	r24, Z+22	; 0x16
    5ca2:	80 93 6e 06 	sts	0x066E, r24
    5ca6:	ea 81       	ldd	r30, Y+2	; 0x02
    5ca8:	fb 81       	ldd	r31, Y+3	; 0x03
    5caa:	86 89       	ldd	r24, Z+22	; 0x16
    5cac:	28 2f       	mov	r18, r24
    5cae:	30 e0       	ldi	r19, 0x00	; 0
    5cb0:	c9 01       	movw	r24, r18
    5cb2:	88 0f       	add	r24, r24
    5cb4:	99 1f       	adc	r25, r25
    5cb6:	88 0f       	add	r24, r24
    5cb8:	99 1f       	adc	r25, r25
    5cba:	88 0f       	add	r24, r24
    5cbc:	99 1f       	adc	r25, r25
    5cbe:	82 0f       	add	r24, r18
    5cc0:	93 1f       	adc	r25, r19
    5cc2:	ac 01       	movw	r20, r24
    5cc4:	4b 58       	subi	r20, 0x8B	; 139
    5cc6:	59 4f       	sbci	r21, 0xF9	; 249
    5cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cca:	9b 81       	ldd	r25, Y+3	; 0x03
    5ccc:	9c 01       	movw	r18, r24
    5cce:	2e 5f       	subi	r18, 0xFE	; 254
    5cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd2:	ca 01       	movw	r24, r20
    5cd4:	b9 01       	movw	r22, r18
    5cd6:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
    5cda:	0a c0       	rjmp	.+20     	; 0x5cf0 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cde:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce0:	9c 01       	movw	r18, r24
    5ce2:	24 5f       	subi	r18, 0xF4	; 244
    5ce4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ce6:	8f ea       	ldi	r24, 0xAF	; 175
    5ce8:	96 e0       	ldi	r25, 0x06	; 6
    5cea:	b9 01       	movw	r22, r18
    5cec:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5cf0:	ea 81       	ldd	r30, Y+2	; 0x02
    5cf2:	fb 81       	ldd	r31, Y+3	; 0x03
    5cf4:	96 89       	ldd	r25, Z+22	; 0x16
    5cf6:	e0 91 68 06 	lds	r30, 0x0668
    5cfa:	f0 91 69 06 	lds	r31, 0x0669
    5cfe:	86 89       	ldd	r24, Z+22	; 0x16
    5d00:	89 17       	cp	r24, r25
    5d02:	30 f4       	brcc	.+12     	; 0x5d10 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5d04:	81 e0       	ldi	r24, 0x01	; 1
    5d06:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5d08:	81 e0       	ldi	r24, 0x01	; 1
    5d0a:	80 93 71 06 	sts	0x0671, r24
    5d0e:	01 c0       	rjmp	.+2      	; 0x5d12 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5d10:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5d12:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d14:	0f 90       	pop	r0
    5d16:	0f 90       	pop	r0
    5d18:	0f 90       	pop	r0
    5d1a:	0f 90       	pop	r0
    5d1c:	0f 90       	pop	r0
    5d1e:	cf 91       	pop	r28
    5d20:	df 91       	pop	r29
    5d22:	08 95       	ret

00005d24 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5d24:	df 93       	push	r29
    5d26:	cf 93       	push	r28
    5d28:	cd b7       	in	r28, 0x3d	; 61
    5d2a:	de b7       	in	r29, 0x3e	; 62
    5d2c:	27 97       	sbiw	r28, 0x07	; 7
    5d2e:	0f b6       	in	r0, 0x3f	; 63
    5d30:	f8 94       	cli
    5d32:	de bf       	out	0x3e, r29	; 62
    5d34:	0f be       	out	0x3f, r0	; 63
    5d36:	cd bf       	out	0x3d, r28	; 61
    5d38:	9d 83       	std	Y+5, r25	; 0x05
    5d3a:	8c 83       	std	Y+4, r24	; 0x04
    5d3c:	7f 83       	std	Y+7, r23	; 0x07
    5d3e:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5d40:	8e 81       	ldd	r24, Y+6	; 0x06
    5d42:	9f 81       	ldd	r25, Y+7	; 0x07
    5d44:	90 68       	ori	r25, 0x80	; 128
    5d46:	ec 81       	ldd	r30, Y+4	; 0x04
    5d48:	fd 81       	ldd	r31, Y+5	; 0x05
    5d4a:	91 83       	std	Z+1, r25	; 0x01
    5d4c:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    5d4e:	ec 81       	ldd	r30, Y+4	; 0x04
    5d50:	fd 81       	ldd	r31, Y+5	; 0x05
    5d52:	86 81       	ldd	r24, Z+6	; 0x06
    5d54:	97 81       	ldd	r25, Z+7	; 0x07
    5d56:	9b 83       	std	Y+3, r25	; 0x03
    5d58:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5d5a:	8c 81       	ldd	r24, Y+4	; 0x04
    5d5c:	9d 81       	ldd	r25, Y+5	; 0x05
    5d5e:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5d62:	8a 81       	ldd	r24, Y+2	; 0x02
    5d64:	9b 81       	ldd	r25, Y+3	; 0x03
    5d66:	02 96       	adiw	r24, 0x02	; 2
    5d68:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5d6c:	ea 81       	ldd	r30, Y+2	; 0x02
    5d6e:	fb 81       	ldd	r31, Y+3	; 0x03
    5d70:	96 89       	ldd	r25, Z+22	; 0x16
    5d72:	80 91 6e 06 	lds	r24, 0x066E
    5d76:	89 17       	cp	r24, r25
    5d78:	28 f4       	brcc	.+10     	; 0x5d84 <xTaskRemoveFromUnorderedEventList+0x60>
    5d7a:	ea 81       	ldd	r30, Y+2	; 0x02
    5d7c:	fb 81       	ldd	r31, Y+3	; 0x03
    5d7e:	86 89       	ldd	r24, Z+22	; 0x16
    5d80:	80 93 6e 06 	sts	0x066E, r24
    5d84:	ea 81       	ldd	r30, Y+2	; 0x02
    5d86:	fb 81       	ldd	r31, Y+3	; 0x03
    5d88:	86 89       	ldd	r24, Z+22	; 0x16
    5d8a:	28 2f       	mov	r18, r24
    5d8c:	30 e0       	ldi	r19, 0x00	; 0
    5d8e:	c9 01       	movw	r24, r18
    5d90:	88 0f       	add	r24, r24
    5d92:	99 1f       	adc	r25, r25
    5d94:	88 0f       	add	r24, r24
    5d96:	99 1f       	adc	r25, r25
    5d98:	88 0f       	add	r24, r24
    5d9a:	99 1f       	adc	r25, r25
    5d9c:	82 0f       	add	r24, r18
    5d9e:	93 1f       	adc	r25, r19
    5da0:	ac 01       	movw	r20, r24
    5da2:	4b 58       	subi	r20, 0x8B	; 139
    5da4:	59 4f       	sbci	r21, 0xF9	; 249
    5da6:	8a 81       	ldd	r24, Y+2	; 0x02
    5da8:	9b 81       	ldd	r25, Y+3	; 0x03
    5daa:	9c 01       	movw	r18, r24
    5dac:	2e 5f       	subi	r18, 0xFE	; 254
    5dae:	3f 4f       	sbci	r19, 0xFF	; 255
    5db0:	ca 01       	movw	r24, r20
    5db2:	b9 01       	movw	r22, r18
    5db4:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5db8:	ea 81       	ldd	r30, Y+2	; 0x02
    5dba:	fb 81       	ldd	r31, Y+3	; 0x03
    5dbc:	96 89       	ldd	r25, Z+22	; 0x16
    5dbe:	e0 91 68 06 	lds	r30, 0x0668
    5dc2:	f0 91 69 06 	lds	r31, 0x0669
    5dc6:	86 89       	ldd	r24, Z+22	; 0x16
    5dc8:	89 17       	cp	r24, r25
    5dca:	30 f4       	brcc	.+12     	; 0x5dd8 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5dcc:	81 e0       	ldi	r24, 0x01	; 1
    5dce:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	80 93 71 06 	sts	0x0671, r24
    5dd6:	01 c0       	rjmp	.+2      	; 0x5dda <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    5dd8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
}
    5ddc:	27 96       	adiw	r28, 0x07	; 7
    5dde:	0f b6       	in	r0, 0x3f	; 63
    5de0:	f8 94       	cli
    5de2:	de bf       	out	0x3e, r29	; 62
    5de4:	0f be       	out	0x3f, r0	; 63
    5de6:	cd bf       	out	0x3d, r28	; 61
    5de8:	cf 91       	pop	r28
    5dea:	df 91       	pop	r29
    5dec:	08 95       	ret

00005dee <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5dee:	df 93       	push	r29
    5df0:	cf 93       	push	r28
    5df2:	00 d0       	rcall	.+0      	; 0x5df4 <vTaskSetTimeOutState+0x6>
    5df4:	cd b7       	in	r28, 0x3d	; 61
    5df6:	de b7       	in	r29, 0x3e	; 62
    5df8:	9a 83       	std	Y+2, r25	; 0x02
    5dfa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5dfc:	80 91 72 06 	lds	r24, 0x0672
    5e00:	e9 81       	ldd	r30, Y+1	; 0x01
    5e02:	fa 81       	ldd	r31, Y+2	; 0x02
    5e04:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5e06:	80 91 6c 06 	lds	r24, 0x066C
    5e0a:	90 91 6d 06 	lds	r25, 0x066D
    5e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    5e10:	fa 81       	ldd	r31, Y+2	; 0x02
    5e12:	92 83       	std	Z+2, r25	; 0x02
    5e14:	81 83       	std	Z+1, r24	; 0x01
}
    5e16:	0f 90       	pop	r0
    5e18:	0f 90       	pop	r0
    5e1a:	cf 91       	pop	r28
    5e1c:	df 91       	pop	r29
    5e1e:	08 95       	ret

00005e20 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5e20:	df 93       	push	r29
    5e22:	cf 93       	push	r28
    5e24:	cd b7       	in	r28, 0x3d	; 61
    5e26:	de b7       	in	r29, 0x3e	; 62
    5e28:	27 97       	sbiw	r28, 0x07	; 7
    5e2a:	0f b6       	in	r0, 0x3f	; 63
    5e2c:	f8 94       	cli
    5e2e:	de bf       	out	0x3e, r29	; 62
    5e30:	0f be       	out	0x3f, r0	; 63
    5e32:	cd bf       	out	0x3d, r28	; 61
    5e34:	9d 83       	std	Y+5, r25	; 0x05
    5e36:	8c 83       	std	Y+4, r24	; 0x04
    5e38:	7f 83       	std	Y+7, r23	; 0x07
    5e3a:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5e3c:	0f b6       	in	r0, 0x3f	; 63
    5e3e:	f8 94       	cli
    5e40:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5e42:	80 91 6c 06 	lds	r24, 0x066C
    5e46:	90 91 6d 06 	lds	r25, 0x066D
    5e4a:	9a 83       	std	Y+2, r25	; 0x02
    5e4c:	89 83       	std	Y+1, r24	; 0x01

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    5e4e:	ee 81       	ldd	r30, Y+6	; 0x06
    5e50:	ff 81       	ldd	r31, Y+7	; 0x07
    5e52:	80 81       	ld	r24, Z
    5e54:	91 81       	ldd	r25, Z+1	; 0x01
    5e56:	2f ef       	ldi	r18, 0xFF	; 255
    5e58:	8f 3f       	cpi	r24, 0xFF	; 255
    5e5a:	92 07       	cpc	r25, r18
    5e5c:	11 f4       	brne	.+4      	; 0x5e62 <xTaskCheckForTimeOut+0x42>
			{
				xReturn = pdFALSE;
    5e5e:	1b 82       	std	Y+3, r1	; 0x03
    5e60:	40 c0       	rjmp	.+128    	; 0x5ee2 <xTaskCheckForTimeOut+0xc2>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5e62:	ec 81       	ldd	r30, Y+4	; 0x04
    5e64:	fd 81       	ldd	r31, Y+5	; 0x05
    5e66:	90 81       	ld	r25, Z
    5e68:	80 91 72 06 	lds	r24, 0x0672
    5e6c:	98 17       	cp	r25, r24
    5e6e:	61 f0       	breq	.+24     	; 0x5e88 <xTaskCheckForTimeOut+0x68>
    5e70:	ec 81       	ldd	r30, Y+4	; 0x04
    5e72:	fd 81       	ldd	r31, Y+5	; 0x05
    5e74:	21 81       	ldd	r18, Z+1	; 0x01
    5e76:	32 81       	ldd	r19, Z+2	; 0x02
    5e78:	89 81       	ldd	r24, Y+1	; 0x01
    5e7a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e7c:	82 17       	cp	r24, r18
    5e7e:	93 07       	cpc	r25, r19
    5e80:	18 f0       	brcs	.+6      	; 0x5e88 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5e82:	81 e0       	ldi	r24, 0x01	; 1
    5e84:	8b 83       	std	Y+3, r24	; 0x03
    5e86:	2d c0       	rjmp	.+90     	; 0x5ee2 <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    5e88:	ec 81       	ldd	r30, Y+4	; 0x04
    5e8a:	fd 81       	ldd	r31, Y+5	; 0x05
    5e8c:	21 81       	ldd	r18, Z+1	; 0x01
    5e8e:	32 81       	ldd	r19, Z+2	; 0x02
    5e90:	89 81       	ldd	r24, Y+1	; 0x01
    5e92:	9a 81       	ldd	r25, Y+2	; 0x02
    5e94:	ac 01       	movw	r20, r24
    5e96:	42 1b       	sub	r20, r18
    5e98:	53 0b       	sbc	r21, r19
    5e9a:	9a 01       	movw	r18, r20
    5e9c:	ee 81       	ldd	r30, Y+6	; 0x06
    5e9e:	ff 81       	ldd	r31, Y+7	; 0x07
    5ea0:	80 81       	ld	r24, Z
    5ea2:	91 81       	ldd	r25, Z+1	; 0x01
    5ea4:	28 17       	cp	r18, r24
    5ea6:	39 07       	cpc	r19, r25
    5ea8:	d0 f4       	brcc	.+52     	; 0x5ede <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    5eaa:	ee 81       	ldd	r30, Y+6	; 0x06
    5eac:	ff 81       	ldd	r31, Y+7	; 0x07
    5eae:	40 81       	ld	r20, Z
    5eb0:	51 81       	ldd	r21, Z+1	; 0x01
    5eb2:	ec 81       	ldd	r30, Y+4	; 0x04
    5eb4:	fd 81       	ldd	r31, Y+5	; 0x05
    5eb6:	21 81       	ldd	r18, Z+1	; 0x01
    5eb8:	32 81       	ldd	r19, Z+2	; 0x02
    5eba:	89 81       	ldd	r24, Y+1	; 0x01
    5ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    5ebe:	b9 01       	movw	r22, r18
    5ec0:	68 1b       	sub	r22, r24
    5ec2:	79 0b       	sbc	r23, r25
    5ec4:	cb 01       	movw	r24, r22
    5ec6:	84 0f       	add	r24, r20
    5ec8:	95 1f       	adc	r25, r21
    5eca:	ee 81       	ldd	r30, Y+6	; 0x06
    5ecc:	ff 81       	ldd	r31, Y+7	; 0x07
    5ece:	91 83       	std	Z+1, r25	; 0x01
    5ed0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    5ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    5ed6:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5eda:	1b 82       	std	Y+3, r1	; 0x03
    5edc:	02 c0       	rjmp	.+4      	; 0x5ee2 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    5ede:	81 e0       	ldi	r24, 0x01	; 1
    5ee0:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    5ee2:	0f 90       	pop	r0
    5ee4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5ee6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5ee8:	27 96       	adiw	r28, 0x07	; 7
    5eea:	0f b6       	in	r0, 0x3f	; 63
    5eec:	f8 94       	cli
    5eee:	de bf       	out	0x3e, r29	; 62
    5ef0:	0f be       	out	0x3f, r0	; 63
    5ef2:	cd bf       	out	0x3d, r28	; 61
    5ef4:	cf 91       	pop	r28
    5ef6:	df 91       	pop	r29
    5ef8:	08 95       	ret

00005efa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5efa:	df 93       	push	r29
    5efc:	cf 93       	push	r28
    5efe:	cd b7       	in	r28, 0x3d	; 61
    5f00:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5f02:	81 e0       	ldi	r24, 0x01	; 1
    5f04:	80 93 71 06 	sts	0x0671, r24
}
    5f08:	cf 91       	pop	r28
    5f0a:	df 91       	pop	r29
    5f0c:	08 95       	ret

00005f0e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5f0e:	df 93       	push	r29
    5f10:	cf 93       	push	r28
    5f12:	00 d0       	rcall	.+0      	; 0x5f14 <prvIdleTask+0x6>
    5f14:	cd b7       	in	r28, 0x3d	; 61
    5f16:	de b7       	in	r29, 0x3e	; 62
    5f18:	9a 83       	std	Y+2, r25	; 0x02
    5f1a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5f1c:	0e 94 52 30 	call	0x60a4	; 0x60a4 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5f20:	80 91 75 06 	lds	r24, 0x0675
    5f24:	82 30       	cpi	r24, 0x02	; 2
    5f26:	d0 f3       	brcs	.-12     	; 0x5f1c <prvIdleTask+0xe>
			{
				taskYIELD();
    5f28:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <vPortYield>
    5f2c:	f7 cf       	rjmp	.-18     	; 0x5f1c <prvIdleTask+0xe>

00005f2e <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5f2e:	0f 93       	push	r16
    5f30:	1f 93       	push	r17
    5f32:	df 93       	push	r29
    5f34:	cf 93       	push	r28
    5f36:	cd b7       	in	r28, 0x3d	; 61
    5f38:	de b7       	in	r29, 0x3e	; 62
    5f3a:	2a 97       	sbiw	r28, 0x0a	; 10
    5f3c:	0f b6       	in	r0, 0x3f	; 63
    5f3e:	f8 94       	cli
    5f40:	de bf       	out	0x3e, r29	; 62
    5f42:	0f be       	out	0x3f, r0	; 63
    5f44:	cd bf       	out	0x3d, r28	; 61
    5f46:	9b 83       	std	Y+3, r25	; 0x03
    5f48:	8a 83       	std	Y+2, r24	; 0x02
    5f4a:	7d 83       	std	Y+5, r23	; 0x05
    5f4c:	6c 83       	std	Y+4, r22	; 0x04
    5f4e:	4e 83       	std	Y+6, r20	; 0x06
    5f50:	38 87       	std	Y+8, r19	; 0x08
    5f52:	2f 83       	std	Y+7, r18	; 0x07
    5f54:	1a 87       	std	Y+10, r17	; 0x0a
    5f56:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5f58:	19 82       	std	Y+1, r1	; 0x01
    5f5a:	21 c0       	rjmp	.+66     	; 0x5f9e <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    5f5c:	89 81       	ldd	r24, Y+1	; 0x01
    5f5e:	48 2f       	mov	r20, r24
    5f60:	50 e0       	ldi	r21, 0x00	; 0
    5f62:	89 81       	ldd	r24, Y+1	; 0x01
    5f64:	28 2f       	mov	r18, r24
    5f66:	30 e0       	ldi	r19, 0x00	; 0
    5f68:	8c 81       	ldd	r24, Y+4	; 0x04
    5f6a:	9d 81       	ldd	r25, Y+5	; 0x05
    5f6c:	fc 01       	movw	r30, r24
    5f6e:	e2 0f       	add	r30, r18
    5f70:	f3 1f       	adc	r31, r19
    5f72:	20 81       	ld	r18, Z
    5f74:	8a 81       	ldd	r24, Y+2	; 0x02
    5f76:	9b 81       	ldd	r25, Y+3	; 0x03
    5f78:	84 0f       	add	r24, r20
    5f7a:	95 1f       	adc	r25, r21
    5f7c:	fc 01       	movw	r30, r24
    5f7e:	79 96       	adiw	r30, 0x19	; 25
    5f80:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5f82:	89 81       	ldd	r24, Y+1	; 0x01
    5f84:	28 2f       	mov	r18, r24
    5f86:	30 e0       	ldi	r19, 0x00	; 0
    5f88:	8c 81       	ldd	r24, Y+4	; 0x04
    5f8a:	9d 81       	ldd	r25, Y+5	; 0x05
    5f8c:	fc 01       	movw	r30, r24
    5f8e:	e2 0f       	add	r30, r18
    5f90:	f3 1f       	adc	r31, r19
    5f92:	80 81       	ld	r24, Z
    5f94:	88 23       	and	r24, r24
    5f96:	31 f0       	breq	.+12     	; 0x5fa4 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5f98:	89 81       	ldd	r24, Y+1	; 0x01
    5f9a:	8f 5f       	subi	r24, 0xFF	; 255
    5f9c:	89 83       	std	Y+1, r24	; 0x01
    5f9e:	89 81       	ldd	r24, Y+1	; 0x01
    5fa0:	84 31       	cpi	r24, 0x14	; 20
    5fa2:	e0 f2       	brcs	.-72     	; 0x5f5c <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5fa4:	ea 81       	ldd	r30, Y+2	; 0x02
    5fa6:	fb 81       	ldd	r31, Y+3	; 0x03
    5fa8:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5faa:	8e 81       	ldd	r24, Y+6	; 0x06
    5fac:	84 30       	cpi	r24, 0x04	; 4
    5fae:	10 f0       	brcs	.+4      	; 0x5fb4 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5fb0:	83 e0       	ldi	r24, 0x03	; 3
    5fb2:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    5fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    5fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    5fb8:	8e 81       	ldd	r24, Y+6	; 0x06
    5fba:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    5fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    5fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    5fc0:	8e 81       	ldd	r24, Y+6	; 0x06
    5fc2:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    5fc4:	ea 81       	ldd	r30, Y+2	; 0x02
    5fc6:	fb 81       	ldd	r31, Y+3	; 0x03
    5fc8:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    5fca:	8a 81       	ldd	r24, Y+2	; 0x02
    5fcc:	9b 81       	ldd	r25, Y+3	; 0x03
    5fce:	02 96       	adiw	r24, 0x02	; 2
    5fd0:	0e 94 4e 1b 	call	0x369c	; 0x369c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    5fd6:	9b 81       	ldd	r25, Y+3	; 0x03
    5fd8:	0c 96       	adiw	r24, 0x0c	; 12
    5fda:	0e 94 4e 1b 	call	0x369c	; 0x369c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5fde:	ea 81       	ldd	r30, Y+2	; 0x02
    5fe0:	fb 81       	ldd	r31, Y+3	; 0x03
    5fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    5fe4:	9b 81       	ldd	r25, Y+3	; 0x03
    5fe6:	91 87       	std	Z+9, r25	; 0x09
    5fe8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5fea:	8e 81       	ldd	r24, Y+6	; 0x06
    5fec:	28 2f       	mov	r18, r24
    5fee:	30 e0       	ldi	r19, 0x00	; 0
    5ff0:	84 e0       	ldi	r24, 0x04	; 4
    5ff2:	90 e0       	ldi	r25, 0x00	; 0
    5ff4:	82 1b       	sub	r24, r18
    5ff6:	93 0b       	sbc	r25, r19
    5ff8:	ea 81       	ldd	r30, Y+2	; 0x02
    5ffa:	fb 81       	ldd	r31, Y+3	; 0x03
    5ffc:	95 87       	std	Z+13, r25	; 0x0d
    5ffe:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    6000:	ea 81       	ldd	r30, Y+2	; 0x02
    6002:	fb 81       	ldd	r31, Y+3	; 0x03
    6004:	8a 81       	ldd	r24, Y+2	; 0x02
    6006:	9b 81       	ldd	r25, Y+3	; 0x03
    6008:	93 8b       	std	Z+19, r25	; 0x13
    600a:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    600c:	2a 96       	adiw	r28, 0x0a	; 10
    600e:	0f b6       	in	r0, 0x3f	; 63
    6010:	f8 94       	cli
    6012:	de bf       	out	0x3e, r29	; 62
    6014:	0f be       	out	0x3f, r0	; 63
    6016:	cd bf       	out	0x3d, r28	; 61
    6018:	cf 91       	pop	r28
    601a:	df 91       	pop	r29
    601c:	1f 91       	pop	r17
    601e:	0f 91       	pop	r16
    6020:	08 95       	ret

00006022 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    6022:	df 93       	push	r29
    6024:	cf 93       	push	r28
    6026:	0f 92       	push	r0
    6028:	cd b7       	in	r28, 0x3d	; 61
    602a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    602c:	19 82       	std	Y+1, r1	; 0x01
    602e:	13 c0       	rjmp	.+38     	; 0x6056 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6030:	89 81       	ldd	r24, Y+1	; 0x01
    6032:	28 2f       	mov	r18, r24
    6034:	30 e0       	ldi	r19, 0x00	; 0
    6036:	c9 01       	movw	r24, r18
    6038:	88 0f       	add	r24, r24
    603a:	99 1f       	adc	r25, r25
    603c:	88 0f       	add	r24, r24
    603e:	99 1f       	adc	r25, r25
    6040:	88 0f       	add	r24, r24
    6042:	99 1f       	adc	r25, r25
    6044:	82 0f       	add	r24, r18
    6046:	93 1f       	adc	r25, r19
    6048:	8b 58       	subi	r24, 0x8B	; 139
    604a:	99 4f       	sbci	r25, 0xF9	; 249
    604c:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6050:	89 81       	ldd	r24, Y+1	; 0x01
    6052:	8f 5f       	subi	r24, 0xFF	; 255
    6054:	89 83       	std	Y+1, r24	; 0x01
    6056:	89 81       	ldd	r24, Y+1	; 0x01
    6058:	84 30       	cpi	r24, 0x04	; 4
    605a:	50 f3       	brcs	.-44     	; 0x6030 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    605c:	89 e9       	ldi	r24, 0x99	; 153
    605e:	96 e0       	ldi	r25, 0x06	; 6
    6060:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    6064:	82 ea       	ldi	r24, 0xA2	; 162
    6066:	96 e0       	ldi	r25, 0x06	; 6
    6068:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    606c:	8f ea       	ldi	r24, 0xAF	; 175
    606e:	96 e0       	ldi	r25, 0x06	; 6
    6070:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    6074:	88 eb       	ldi	r24, 0xB8	; 184
    6076:	96 e0       	ldi	r25, 0x06	; 6
    6078:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    607c:	81 ec       	ldi	r24, 0xC1	; 193
    607e:	96 e0       	ldi	r25, 0x06	; 6
    6080:	0e 94 24 1b 	call	0x3648	; 0x3648 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6084:	89 e9       	ldi	r24, 0x99	; 153
    6086:	96 e0       	ldi	r25, 0x06	; 6
    6088:	90 93 ac 06 	sts	0x06AC, r25
    608c:	80 93 ab 06 	sts	0x06AB, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6090:	82 ea       	ldi	r24, 0xA2	; 162
    6092:	96 e0       	ldi	r25, 0x06	; 6
    6094:	90 93 ae 06 	sts	0x06AE, r25
    6098:	80 93 ad 06 	sts	0x06AD, r24
}
    609c:	0f 90       	pop	r0
    609e:	cf 91       	pop	r28
    60a0:	df 91       	pop	r29
    60a2:	08 95       	ret

000060a4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	00 d0       	rcall	.+0      	; 0x60aa <prvCheckTasksWaitingTermination+0x6>
    60aa:	0f 92       	push	r0
    60ac:	cd b7       	in	r28, 0x3d	; 61
    60ae:	de b7       	in	r29, 0x3e	; 62
    60b0:	2e c0       	rjmp	.+92     	; 0x610e <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    60b2:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    60b6:	80 91 b8 06 	lds	r24, 0x06B8
    60ba:	1b 82       	std	Y+3, r1	; 0x03
    60bc:	88 23       	and	r24, r24
    60be:	11 f4       	brne	.+4      	; 0x60c4 <prvCheckTasksWaitingTermination+0x20>
    60c0:	81 e0       	ldi	r24, 0x01	; 1
    60c2:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    60c4:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    60c8:	8b 81       	ldd	r24, Y+3	; 0x03
    60ca:	88 23       	and	r24, r24
    60cc:	01 f5       	brne	.+64     	; 0x610e <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    60ce:	0f b6       	in	r0, 0x3f	; 63
    60d0:	f8 94       	cli
    60d2:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    60d4:	e0 91 bd 06 	lds	r30, 0x06BD
    60d8:	f0 91 be 06 	lds	r31, 0x06BE
    60dc:	86 81       	ldd	r24, Z+6	; 0x06
    60de:	97 81       	ldd	r25, Z+7	; 0x07
    60e0:	9a 83       	std	Y+2, r25	; 0x02
    60e2:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    60e4:	89 81       	ldd	r24, Y+1	; 0x01
    60e6:	9a 81       	ldd	r25, Y+2	; 0x02
    60e8:	02 96       	adiw	r24, 0x02	; 2
    60ea:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					--uxCurrentNumberOfTasks;
    60ee:	80 91 6b 06 	lds	r24, 0x066B
    60f2:	81 50       	subi	r24, 0x01	; 1
    60f4:	80 93 6b 06 	sts	0x066B, r24
					--uxTasksDeleted;
    60f8:	80 91 6a 06 	lds	r24, 0x066A
    60fc:	81 50       	subi	r24, 0x01	; 1
    60fe:	80 93 6a 06 	sts	0x066A, r24
				}
				taskEXIT_CRITICAL();
    6102:	0f 90       	pop	r0
    6104:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6106:	89 81       	ldd	r24, Y+1	; 0x01
    6108:	9a 81       	ldd	r25, Y+2	; 0x02
    610a:	0e 94 1e 31 	call	0x623c	; 0x623c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    610e:	80 91 6a 06 	lds	r24, 0x066A
    6112:	88 23       	and	r24, r24
    6114:	71 f6       	brne	.-100    	; 0x60b2 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    6116:	0f 90       	pop	r0
    6118:	0f 90       	pop	r0
    611a:	0f 90       	pop	r0
    611c:	cf 91       	pop	r28
    611e:	df 91       	pop	r29
    6120:	08 95       	ret

00006122 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    6122:	df 93       	push	r29
    6124:	cf 93       	push	r28
    6126:	00 d0       	rcall	.+0      	; 0x6128 <prvAddCurrentTaskToDelayedList+0x6>
    6128:	cd b7       	in	r28, 0x3d	; 61
    612a:	de b7       	in	r29, 0x3e	; 62
    612c:	9a 83       	std	Y+2, r25	; 0x02
    612e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    6130:	e0 91 68 06 	lds	r30, 0x0668
    6134:	f0 91 69 06 	lds	r31, 0x0669
    6138:	89 81       	ldd	r24, Y+1	; 0x01
    613a:	9a 81       	ldd	r25, Y+2	; 0x02
    613c:	93 83       	std	Z+3, r25	; 0x03
    613e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    6140:	20 91 6c 06 	lds	r18, 0x066C
    6144:	30 91 6d 06 	lds	r19, 0x066D
    6148:	89 81       	ldd	r24, Y+1	; 0x01
    614a:	9a 81       	ldd	r25, Y+2	; 0x02
    614c:	82 17       	cp	r24, r18
    614e:	93 07       	cpc	r25, r19
    6150:	70 f4       	brcc	.+28     	; 0x616e <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    6152:	80 91 ad 06 	lds	r24, 0x06AD
    6156:	90 91 ae 06 	lds	r25, 0x06AE
    615a:	20 91 68 06 	lds	r18, 0x0668
    615e:	30 91 69 06 	lds	r19, 0x0669
    6162:	2e 5f       	subi	r18, 0xFE	; 254
    6164:	3f 4f       	sbci	r19, 0xFF	; 255
    6166:	b9 01       	movw	r22, r18
    6168:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>
    616c:	1e c0       	rjmp	.+60     	; 0x61aa <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    616e:	40 91 ab 06 	lds	r20, 0x06AB
    6172:	50 91 ac 06 	lds	r21, 0x06AC
    6176:	80 91 68 06 	lds	r24, 0x0668
    617a:	90 91 69 06 	lds	r25, 0x0669
    617e:	9c 01       	movw	r18, r24
    6180:	2e 5f       	subi	r18, 0xFE	; 254
    6182:	3f 4f       	sbci	r19, 0xFF	; 255
    6184:	ca 01       	movw	r24, r20
    6186:	b9 01       	movw	r22, r18
    6188:	0e 94 a2 1b 	call	0x3744	; 0x3744 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    618c:	20 91 95 01 	lds	r18, 0x0195
    6190:	30 91 96 01 	lds	r19, 0x0196
    6194:	89 81       	ldd	r24, Y+1	; 0x01
    6196:	9a 81       	ldd	r25, Y+2	; 0x02
    6198:	82 17       	cp	r24, r18
    619a:	93 07       	cpc	r25, r19
    619c:	30 f4       	brcc	.+12     	; 0x61aa <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    619e:	89 81       	ldd	r24, Y+1	; 0x01
    61a0:	9a 81       	ldd	r25, Y+2	; 0x02
    61a2:	90 93 96 01 	sts	0x0196, r25
    61a6:	80 93 95 01 	sts	0x0195, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    61aa:	0f 90       	pop	r0
    61ac:	0f 90       	pop	r0
    61ae:	cf 91       	pop	r28
    61b0:	df 91       	pop	r29
    61b2:	08 95       	ret

000061b4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    61b4:	df 93       	push	r29
    61b6:	cf 93       	push	r28
    61b8:	cd b7       	in	r28, 0x3d	; 61
    61ba:	de b7       	in	r29, 0x3e	; 62
    61bc:	28 97       	sbiw	r28, 0x08	; 8
    61be:	0f b6       	in	r0, 0x3f	; 63
    61c0:	f8 94       	cli
    61c2:	de bf       	out	0x3e, r29	; 62
    61c4:	0f be       	out	0x3f, r0	; 63
    61c6:	cd bf       	out	0x3d, r28	; 61
    61c8:	9c 83       	std	Y+4, r25	; 0x04
    61ca:	8b 83       	std	Y+3, r24	; 0x03
    61cc:	7e 83       	std	Y+6, r23	; 0x06
    61ce:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    61d0:	8f e2       	ldi	r24, 0x2F	; 47
    61d2:	90 e0       	ldi	r25, 0x00	; 0
    61d4:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    61d8:	9a 83       	std	Y+2, r25	; 0x02
    61da:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    61dc:	89 81       	ldd	r24, Y+1	; 0x01
    61de:	9a 81       	ldd	r25, Y+2	; 0x02
    61e0:	00 97       	sbiw	r24, 0x00	; 0
    61e2:	09 f1       	breq	.+66     	; 0x6226 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    61e4:	8d 81       	ldd	r24, Y+5	; 0x05
    61e6:	9e 81       	ldd	r25, Y+6	; 0x06
    61e8:	00 97       	sbiw	r24, 0x00	; 0
    61ea:	39 f4       	brne	.+14     	; 0x61fa <prvAllocateTCBAndStack+0x46>
    61ec:	8b 81       	ldd	r24, Y+3	; 0x03
    61ee:	9c 81       	ldd	r25, Y+4	; 0x04
    61f0:	0e 94 d6 19 	call	0x33ac	; 0x33ac <pvPortMalloc>
    61f4:	98 87       	std	Y+8, r25	; 0x08
    61f6:	8f 83       	std	Y+7, r24	; 0x07
    61f8:	04 c0       	rjmp	.+8      	; 0x6202 <prvAllocateTCBAndStack+0x4e>
    61fa:	8d 81       	ldd	r24, Y+5	; 0x05
    61fc:	9e 81       	ldd	r25, Y+6	; 0x06
    61fe:	98 87       	std	Y+8, r25	; 0x08
    6200:	8f 83       	std	Y+7, r24	; 0x07
    6202:	e9 81       	ldd	r30, Y+1	; 0x01
    6204:	fa 81       	ldd	r31, Y+2	; 0x02
    6206:	8f 81       	ldd	r24, Y+7	; 0x07
    6208:	98 85       	ldd	r25, Y+8	; 0x08
    620a:	90 8f       	std	Z+24, r25	; 0x18
    620c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    620e:	e9 81       	ldd	r30, Y+1	; 0x01
    6210:	fa 81       	ldd	r31, Y+2	; 0x02
    6212:	87 89       	ldd	r24, Z+23	; 0x17
    6214:	90 8d       	ldd	r25, Z+24	; 0x18
    6216:	00 97       	sbiw	r24, 0x00	; 0
    6218:	31 f4       	brne	.+12     	; 0x6226 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    621a:	89 81       	ldd	r24, Y+1	; 0x01
    621c:	9a 81       	ldd	r25, Y+2	; 0x02
    621e:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
			pxNewTCB = NULL;
    6222:	1a 82       	std	Y+2, r1	; 0x02
    6224:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    6226:	89 81       	ldd	r24, Y+1	; 0x01
    6228:	9a 81       	ldd	r25, Y+2	; 0x02
}
    622a:	28 96       	adiw	r28, 0x08	; 8
    622c:	0f b6       	in	r0, 0x3f	; 63
    622e:	f8 94       	cli
    6230:	de bf       	out	0x3e, r29	; 62
    6232:	0f be       	out	0x3f, r0	; 63
    6234:	cd bf       	out	0x3d, r28	; 61
    6236:	cf 91       	pop	r28
    6238:	df 91       	pop	r29
    623a:	08 95       	ret

0000623c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    623c:	df 93       	push	r29
    623e:	cf 93       	push	r28
    6240:	00 d0       	rcall	.+0      	; 0x6242 <prvDeleteTCB+0x6>
    6242:	cd b7       	in	r28, 0x3d	; 61
    6244:	de b7       	in	r29, 0x3e	; 62
    6246:	9a 83       	std	Y+2, r25	; 0x02
    6248:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    624a:	e9 81       	ldd	r30, Y+1	; 0x01
    624c:	fa 81       	ldd	r31, Y+2	; 0x02
    624e:	87 89       	ldd	r24, Z+23	; 0x17
    6250:	90 8d       	ldd	r25, Z+24	; 0x18
    6252:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
		vPortFree( pxTCB );
    6256:	89 81       	ldd	r24, Y+1	; 0x01
    6258:	9a 81       	ldd	r25, Y+2	; 0x02
    625a:	0e 94 2c 1a 	call	0x3458	; 0x3458 <vPortFree>
	}
    625e:	0f 90       	pop	r0
    6260:	0f 90       	pop	r0
    6262:	cf 91       	pop	r28
    6264:	df 91       	pop	r29
    6266:	08 95       	ret

00006268 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    6268:	df 93       	push	r29
    626a:	cf 93       	push	r28
    626c:	00 d0       	rcall	.+0      	; 0x626e <prvResetNextTaskUnblockTime+0x6>
    626e:	cd b7       	in	r28, 0x3d	; 61
    6270:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6272:	e0 91 ab 06 	lds	r30, 0x06AB
    6276:	f0 91 ac 06 	lds	r31, 0x06AC
    627a:	80 81       	ld	r24, Z
    627c:	88 23       	and	r24, r24
    627e:	39 f4       	brne	.+14     	; 0x628e <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    6280:	8f ef       	ldi	r24, 0xFF	; 255
    6282:	9f ef       	ldi	r25, 0xFF	; 255
    6284:	90 93 96 01 	sts	0x0196, r25
    6288:	80 93 95 01 	sts	0x0195, r24
    628c:	13 c0       	rjmp	.+38     	; 0x62b4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    628e:	e0 91 ab 06 	lds	r30, 0x06AB
    6292:	f0 91 ac 06 	lds	r31, 0x06AC
    6296:	05 80       	ldd	r0, Z+5	; 0x05
    6298:	f6 81       	ldd	r31, Z+6	; 0x06
    629a:	e0 2d       	mov	r30, r0
    629c:	86 81       	ldd	r24, Z+6	; 0x06
    629e:	97 81       	ldd	r25, Z+7	; 0x07
    62a0:	9a 83       	std	Y+2, r25	; 0x02
    62a2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    62a4:	e9 81       	ldd	r30, Y+1	; 0x01
    62a6:	fa 81       	ldd	r31, Y+2	; 0x02
    62a8:	82 81       	ldd	r24, Z+2	; 0x02
    62aa:	93 81       	ldd	r25, Z+3	; 0x03
    62ac:	90 93 96 01 	sts	0x0196, r25
    62b0:	80 93 95 01 	sts	0x0195, r24
	}
}
    62b4:	0f 90       	pop	r0
    62b6:	0f 90       	pop	r0
    62b8:	cf 91       	pop	r28
    62ba:	df 91       	pop	r29
    62bc:	08 95       	ret

000062be <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    62be:	df 93       	push	r29
    62c0:	cf 93       	push	r28
    62c2:	00 d0       	rcall	.+0      	; 0x62c4 <xTaskGetCurrentTaskHandle+0x6>
    62c4:	cd b7       	in	r28, 0x3d	; 61
    62c6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    62c8:	80 91 68 06 	lds	r24, 0x0668
    62cc:	90 91 69 06 	lds	r25, 0x0669
    62d0:	9a 83       	std	Y+2, r25	; 0x02
    62d2:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    62d4:	89 81       	ldd	r24, Y+1	; 0x01
    62d6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    62d8:	0f 90       	pop	r0
    62da:	0f 90       	pop	r0
    62dc:	cf 91       	pop	r28
    62de:	df 91       	pop	r29
    62e0:	08 95       	ret

000062e2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    62e2:	df 93       	push	r29
    62e4:	cf 93       	push	r28
    62e6:	00 d0       	rcall	.+0      	; 0x62e8 <vTaskPriorityInherit+0x6>
    62e8:	00 d0       	rcall	.+0      	; 0x62ea <vTaskPriorityInherit+0x8>
    62ea:	cd b7       	in	r28, 0x3d	; 61
    62ec:	de b7       	in	r29, 0x3e	; 62
    62ee:	9c 83       	std	Y+4, r25	; 0x04
    62f0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    62f2:	8b 81       	ldd	r24, Y+3	; 0x03
    62f4:	9c 81       	ldd	r25, Y+4	; 0x04
    62f6:	9a 83       	std	Y+2, r25	; 0x02
    62f8:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    62fa:	8b 81       	ldd	r24, Y+3	; 0x03
    62fc:	9c 81       	ldd	r25, Y+4	; 0x04
    62fe:	00 97       	sbiw	r24, 0x00	; 0
    6300:	09 f4       	brne	.+2      	; 0x6304 <vTaskPriorityInherit+0x22>
    6302:	73 c0       	rjmp	.+230    	; 0x63ea <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    6304:	e9 81       	ldd	r30, Y+1	; 0x01
    6306:	fa 81       	ldd	r31, Y+2	; 0x02
    6308:	96 89       	ldd	r25, Z+22	; 0x16
    630a:	e0 91 68 06 	lds	r30, 0x0668
    630e:	f0 91 69 06 	lds	r31, 0x0669
    6312:	86 89       	ldd	r24, Z+22	; 0x16
    6314:	98 17       	cp	r25, r24
    6316:	08 f0       	brcs	.+2      	; 0x631a <vTaskPriorityInherit+0x38>
    6318:	68 c0       	rjmp	.+208    	; 0x63ea <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    631a:	e9 81       	ldd	r30, Y+1	; 0x01
    631c:	fa 81       	ldd	r31, Y+2	; 0x02
    631e:	84 85       	ldd	r24, Z+12	; 0x0c
    6320:	95 85       	ldd	r25, Z+13	; 0x0d
    6322:	99 23       	and	r25, r25
    6324:	7c f0       	brlt	.+30     	; 0x6344 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6326:	e0 91 68 06 	lds	r30, 0x0668
    632a:	f0 91 69 06 	lds	r31, 0x0669
    632e:	86 89       	ldd	r24, Z+22	; 0x16
    6330:	28 2f       	mov	r18, r24
    6332:	30 e0       	ldi	r19, 0x00	; 0
    6334:	84 e0       	ldi	r24, 0x04	; 4
    6336:	90 e0       	ldi	r25, 0x00	; 0
    6338:	82 1b       	sub	r24, r18
    633a:	93 0b       	sbc	r25, r19
    633c:	e9 81       	ldd	r30, Y+1	; 0x01
    633e:	fa 81       	ldd	r31, Y+2	; 0x02
    6340:	95 87       	std	Z+13, r25	; 0x0d
    6342:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    6344:	e9 81       	ldd	r30, Y+1	; 0x01
    6346:	fa 81       	ldd	r31, Y+2	; 0x02
    6348:	42 85       	ldd	r20, Z+10	; 0x0a
    634a:	53 85       	ldd	r21, Z+11	; 0x0b
    634c:	e9 81       	ldd	r30, Y+1	; 0x01
    634e:	fa 81       	ldd	r31, Y+2	; 0x02
    6350:	86 89       	ldd	r24, Z+22	; 0x16
    6352:	28 2f       	mov	r18, r24
    6354:	30 e0       	ldi	r19, 0x00	; 0
    6356:	c9 01       	movw	r24, r18
    6358:	88 0f       	add	r24, r24
    635a:	99 1f       	adc	r25, r25
    635c:	88 0f       	add	r24, r24
    635e:	99 1f       	adc	r25, r25
    6360:	88 0f       	add	r24, r24
    6362:	99 1f       	adc	r25, r25
    6364:	82 0f       	add	r24, r18
    6366:	93 1f       	adc	r25, r19
    6368:	8b 58       	subi	r24, 0x8B	; 139
    636a:	99 4f       	sbci	r25, 0xF9	; 249
    636c:	48 17       	cp	r20, r24
    636e:	59 07       	cpc	r21, r25
    6370:	a1 f5       	brne	.+104    	; 0x63da <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    6372:	89 81       	ldd	r24, Y+1	; 0x01
    6374:	9a 81       	ldd	r25, Y+2	; 0x02
    6376:	02 96       	adiw	r24, 0x02	; 2
    6378:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    637c:	e0 91 68 06 	lds	r30, 0x0668
    6380:	f0 91 69 06 	lds	r31, 0x0669
    6384:	86 89       	ldd	r24, Z+22	; 0x16
    6386:	e9 81       	ldd	r30, Y+1	; 0x01
    6388:	fa 81       	ldd	r31, Y+2	; 0x02
    638a:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    638c:	e9 81       	ldd	r30, Y+1	; 0x01
    638e:	fa 81       	ldd	r31, Y+2	; 0x02
    6390:	96 89       	ldd	r25, Z+22	; 0x16
    6392:	80 91 6e 06 	lds	r24, 0x066E
    6396:	89 17       	cp	r24, r25
    6398:	28 f4       	brcc	.+10     	; 0x63a4 <vTaskPriorityInherit+0xc2>
    639a:	e9 81       	ldd	r30, Y+1	; 0x01
    639c:	fa 81       	ldd	r31, Y+2	; 0x02
    639e:	86 89       	ldd	r24, Z+22	; 0x16
    63a0:	80 93 6e 06 	sts	0x066E, r24
    63a4:	e9 81       	ldd	r30, Y+1	; 0x01
    63a6:	fa 81       	ldd	r31, Y+2	; 0x02
    63a8:	86 89       	ldd	r24, Z+22	; 0x16
    63aa:	28 2f       	mov	r18, r24
    63ac:	30 e0       	ldi	r19, 0x00	; 0
    63ae:	c9 01       	movw	r24, r18
    63b0:	88 0f       	add	r24, r24
    63b2:	99 1f       	adc	r25, r25
    63b4:	88 0f       	add	r24, r24
    63b6:	99 1f       	adc	r25, r25
    63b8:	88 0f       	add	r24, r24
    63ba:	99 1f       	adc	r25, r25
    63bc:	82 0f       	add	r24, r18
    63be:	93 1f       	adc	r25, r19
    63c0:	ac 01       	movw	r20, r24
    63c2:	4b 58       	subi	r20, 0x8B	; 139
    63c4:	59 4f       	sbci	r21, 0xF9	; 249
    63c6:	89 81       	ldd	r24, Y+1	; 0x01
    63c8:	9a 81       	ldd	r25, Y+2	; 0x02
    63ca:	9c 01       	movw	r18, r24
    63cc:	2e 5f       	subi	r18, 0xFE	; 254
    63ce:	3f 4f       	sbci	r19, 0xFF	; 255
    63d0:	ca 01       	movw	r24, r20
    63d2:	b9 01       	movw	r22, r18
    63d4:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>
    63d8:	08 c0       	rjmp	.+16     	; 0x63ea <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    63da:	e0 91 68 06 	lds	r30, 0x0668
    63de:	f0 91 69 06 	lds	r31, 0x0669
    63e2:	86 89       	ldd	r24, Z+22	; 0x16
    63e4:	e9 81       	ldd	r30, Y+1	; 0x01
    63e6:	fa 81       	ldd	r31, Y+2	; 0x02
    63e8:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    63ea:	0f 90       	pop	r0
    63ec:	0f 90       	pop	r0
    63ee:	0f 90       	pop	r0
    63f0:	0f 90       	pop	r0
    63f2:	cf 91       	pop	r28
    63f4:	df 91       	pop	r29
    63f6:	08 95       	ret

000063f8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    63f8:	df 93       	push	r29
    63fa:	cf 93       	push	r28
    63fc:	00 d0       	rcall	.+0      	; 0x63fe <xTaskPriorityDisinherit+0x6>
    63fe:	00 d0       	rcall	.+0      	; 0x6400 <xTaskPriorityDisinherit+0x8>
    6400:	0f 92       	push	r0
    6402:	cd b7       	in	r28, 0x3d	; 61
    6404:	de b7       	in	r29, 0x3e	; 62
    6406:	9d 83       	std	Y+5, r25	; 0x05
    6408:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    640a:	8c 81       	ldd	r24, Y+4	; 0x04
    640c:	9d 81       	ldd	r25, Y+5	; 0x05
    640e:	9b 83       	std	Y+3, r25	; 0x03
    6410:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    6412:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    6414:	8c 81       	ldd	r24, Y+4	; 0x04
    6416:	9d 81       	ldd	r25, Y+5	; 0x05
    6418:	00 97       	sbiw	r24, 0x00	; 0
    641a:	09 f4       	brne	.+2      	; 0x641e <xTaskPriorityDisinherit+0x26>
    641c:	56 c0       	rjmp	.+172    	; 0x64ca <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    641e:	ea 81       	ldd	r30, Y+2	; 0x02
    6420:	fb 81       	ldd	r31, Y+3	; 0x03
    6422:	86 a5       	ldd	r24, Z+46	; 0x2e
    6424:	81 50       	subi	r24, 0x01	; 1
    6426:	ea 81       	ldd	r30, Y+2	; 0x02
    6428:	fb 81       	ldd	r31, Y+3	; 0x03
    642a:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    642c:	ea 81       	ldd	r30, Y+2	; 0x02
    642e:	fb 81       	ldd	r31, Y+3	; 0x03
    6430:	96 89       	ldd	r25, Z+22	; 0x16
    6432:	ea 81       	ldd	r30, Y+2	; 0x02
    6434:	fb 81       	ldd	r31, Y+3	; 0x03
    6436:	85 a5       	ldd	r24, Z+45	; 0x2d
    6438:	98 17       	cp	r25, r24
    643a:	09 f4       	brne	.+2      	; 0x643e <xTaskPriorityDisinherit+0x46>
    643c:	46 c0       	rjmp	.+140    	; 0x64ca <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    643e:	ea 81       	ldd	r30, Y+2	; 0x02
    6440:	fb 81       	ldd	r31, Y+3	; 0x03
    6442:	86 a5       	ldd	r24, Z+46	; 0x2e
    6444:	88 23       	and	r24, r24
    6446:	09 f0       	breq	.+2      	; 0x644a <xTaskPriorityDisinherit+0x52>
    6448:	40 c0       	rjmp	.+128    	; 0x64ca <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    644a:	8a 81       	ldd	r24, Y+2	; 0x02
    644c:	9b 81       	ldd	r25, Y+3	; 0x03
    644e:	02 96       	adiw	r24, 0x02	; 2
    6450:	0e 94 0e 1c 	call	0x381c	; 0x381c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    6454:	ea 81       	ldd	r30, Y+2	; 0x02
    6456:	fb 81       	ldd	r31, Y+3	; 0x03
    6458:	85 a5       	ldd	r24, Z+45	; 0x2d
    645a:	ea 81       	ldd	r30, Y+2	; 0x02
    645c:	fb 81       	ldd	r31, Y+3	; 0x03
    645e:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6460:	ea 81       	ldd	r30, Y+2	; 0x02
    6462:	fb 81       	ldd	r31, Y+3	; 0x03
    6464:	86 89       	ldd	r24, Z+22	; 0x16
    6466:	28 2f       	mov	r18, r24
    6468:	30 e0       	ldi	r19, 0x00	; 0
    646a:	84 e0       	ldi	r24, 0x04	; 4
    646c:	90 e0       	ldi	r25, 0x00	; 0
    646e:	82 1b       	sub	r24, r18
    6470:	93 0b       	sbc	r25, r19
    6472:	ea 81       	ldd	r30, Y+2	; 0x02
    6474:	fb 81       	ldd	r31, Y+3	; 0x03
    6476:	95 87       	std	Z+13, r25	; 0x0d
    6478:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    647a:	ea 81       	ldd	r30, Y+2	; 0x02
    647c:	fb 81       	ldd	r31, Y+3	; 0x03
    647e:	96 89       	ldd	r25, Z+22	; 0x16
    6480:	80 91 6e 06 	lds	r24, 0x066E
    6484:	89 17       	cp	r24, r25
    6486:	28 f4       	brcc	.+10     	; 0x6492 <xTaskPriorityDisinherit+0x9a>
    6488:	ea 81       	ldd	r30, Y+2	; 0x02
    648a:	fb 81       	ldd	r31, Y+3	; 0x03
    648c:	86 89       	ldd	r24, Z+22	; 0x16
    648e:	80 93 6e 06 	sts	0x066E, r24
    6492:	ea 81       	ldd	r30, Y+2	; 0x02
    6494:	fb 81       	ldd	r31, Y+3	; 0x03
    6496:	86 89       	ldd	r24, Z+22	; 0x16
    6498:	28 2f       	mov	r18, r24
    649a:	30 e0       	ldi	r19, 0x00	; 0
    649c:	c9 01       	movw	r24, r18
    649e:	88 0f       	add	r24, r24
    64a0:	99 1f       	adc	r25, r25
    64a2:	88 0f       	add	r24, r24
    64a4:	99 1f       	adc	r25, r25
    64a6:	88 0f       	add	r24, r24
    64a8:	99 1f       	adc	r25, r25
    64aa:	82 0f       	add	r24, r18
    64ac:	93 1f       	adc	r25, r19
    64ae:	ac 01       	movw	r20, r24
    64b0:	4b 58       	subi	r20, 0x8B	; 139
    64b2:	59 4f       	sbci	r21, 0xF9	; 249
    64b4:	8a 81       	ldd	r24, Y+2	; 0x02
    64b6:	9b 81       	ldd	r25, Y+3	; 0x03
    64b8:	9c 01       	movw	r18, r24
    64ba:	2e 5f       	subi	r18, 0xFE	; 254
    64bc:	3f 4f       	sbci	r19, 0xFF	; 255
    64be:	ca 01       	movw	r24, r20
    64c0:	b9 01       	movw	r22, r18
    64c2:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    64c6:	81 e0       	ldi	r24, 0x01	; 1
    64c8:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    64ca:	89 81       	ldd	r24, Y+1	; 0x01
	}
    64cc:	0f 90       	pop	r0
    64ce:	0f 90       	pop	r0
    64d0:	0f 90       	pop	r0
    64d2:	0f 90       	pop	r0
    64d4:	0f 90       	pop	r0
    64d6:	cf 91       	pop	r28
    64d8:	df 91       	pop	r29
    64da:	08 95       	ret

000064dc <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    64dc:	df 93       	push	r29
    64de:	cf 93       	push	r28
    64e0:	00 d0       	rcall	.+0      	; 0x64e2 <uxTaskResetEventItemValue+0x6>
    64e2:	cd b7       	in	r28, 0x3d	; 61
    64e4:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    64e6:	e0 91 68 06 	lds	r30, 0x0668
    64ea:	f0 91 69 06 	lds	r31, 0x0669
    64ee:	84 85       	ldd	r24, Z+12	; 0x0c
    64f0:	95 85       	ldd	r25, Z+13	; 0x0d
    64f2:	9a 83       	std	Y+2, r25	; 0x02
    64f4:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    64f6:	a0 91 68 06 	lds	r26, 0x0668
    64fa:	b0 91 69 06 	lds	r27, 0x0669
    64fe:	e0 91 68 06 	lds	r30, 0x0668
    6502:	f0 91 69 06 	lds	r31, 0x0669
    6506:	86 89       	ldd	r24, Z+22	; 0x16
    6508:	28 2f       	mov	r18, r24
    650a:	30 e0       	ldi	r19, 0x00	; 0
    650c:	84 e0       	ldi	r24, 0x04	; 4
    650e:	90 e0       	ldi	r25, 0x00	; 0
    6510:	82 1b       	sub	r24, r18
    6512:	93 0b       	sbc	r25, r19
    6514:	1d 96       	adiw	r26, 0x0d	; 13
    6516:	9c 93       	st	X, r25
    6518:	8e 93       	st	-X, r24
    651a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    651c:	89 81       	ldd	r24, Y+1	; 0x01
    651e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6520:	0f 90       	pop	r0
    6522:	0f 90       	pop	r0
    6524:	cf 91       	pop	r28
    6526:	df 91       	pop	r29
    6528:	08 95       	ret

0000652a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    652a:	df 93       	push	r29
    652c:	cf 93       	push	r28
    652e:	cd b7       	in	r28, 0x3d	; 61
    6530:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    6532:	80 91 68 06 	lds	r24, 0x0668
    6536:	90 91 69 06 	lds	r25, 0x0669
    653a:	00 97       	sbiw	r24, 0x00	; 0
    653c:	39 f0       	breq	.+14     	; 0x654c <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    653e:	e0 91 68 06 	lds	r30, 0x0668
    6542:	f0 91 69 06 	lds	r31, 0x0669
    6546:	86 a5       	ldd	r24, Z+46	; 0x2e
    6548:	8f 5f       	subi	r24, 0xFF	; 255
    654a:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    654c:	80 91 68 06 	lds	r24, 0x0668
    6550:	90 91 69 06 	lds	r25, 0x0669
	}
    6554:	cf 91       	pop	r28
    6556:	df 91       	pop	r29
    6558:	08 95       	ret

0000655a <main>:
static u8 Global_Turn_Right_[2] =  {100 , 70 } ;

QueueHandle_t xQueue;

void main()
{
    655a:	af 92       	push	r10
    655c:	bf 92       	push	r11
    655e:	cf 92       	push	r12
    6560:	df 92       	push	r13
    6562:	ef 92       	push	r14
    6564:	ff 92       	push	r15
    6566:	0f 93       	push	r16
    6568:	df 93       	push	r29
    656a:	cf 93       	push	r28
    656c:	cd b7       	in	r28, 0x3d	; 61
    656e:	de b7       	in	r29, 0x3e	; 62
	//System Initialization
	systemInit();
    6570:	0e 94 d8 32 	call	0x65b0	; 0x65b0 <systemInit>

	//Queue Creation (By default taken).
	xQueue = xQueueCreate(2, 1);
    6574:	82 e0       	ldi	r24, 0x02	; 2
    6576:	61 e0       	ldi	r22, 0x01	; 1
    6578:	40 e0       	ldi	r20, 0x00	; 0
    657a:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <xQueueGenericCreate>
    657e:	90 93 db 06 	sts	0x06DB, r25
    6582:	80 93 da 06 	sts	0x06DA, r24

	/* Create Tasks */
	xTaskCreate(Send_SpeedTask, "Send_SpeedTask", 120, NULL, 1, NULL);
    6586:	8c e0       	ldi	r24, 0x0C	; 12
    6588:	93 e3       	ldi	r25, 0x33	; 51
    658a:	2d e7       	ldi	r18, 0x7D	; 125
    658c:	30 e0       	ldi	r19, 0x00	; 0
    658e:	b9 01       	movw	r22, r18
    6590:	48 e7       	ldi	r20, 0x78	; 120
    6592:	50 e0       	ldi	r21, 0x00	; 0
    6594:	20 e0       	ldi	r18, 0x00	; 0
    6596:	30 e0       	ldi	r19, 0x00	; 0
    6598:	01 e0       	ldi	r16, 0x01	; 1
    659a:	ee 24       	eor	r14, r14
    659c:	ff 24       	eor	r15, r15
    659e:	cc 24       	eor	r12, r12
    65a0:	dd 24       	eor	r13, r13
    65a2:	aa 24       	eor	r10, r10
    65a4:	bb 24       	eor	r11, r11
    65a6:	0e 94 da 26 	call	0x4db4	; 0x4db4 <xTaskGenericCreate>

	/* Start OS */
	vTaskStartScheduler();
    65aa:	0e 94 2b 2b 	call	0x5656	; 0x5656 <vTaskStartScheduler>
    65ae:	ff cf       	rjmp	.-2      	; 0x65ae <main+0x54>

000065b0 <systemInit>:
	while(1);

}

void systemInit(void)
{
    65b0:	df 93       	push	r29
    65b2:	cf 93       	push	r28
    65b4:	cd b7       	in	r28, 0x3d	; 61
    65b6:	de b7       	in	r29, 0x3e	; 62

	//EXTI Initialization
	EXTI_voidSet_INT0_Cbf(&EXTI_CallBackFUNC);
    65b8:	80 ef       	ldi	r24, 0xF0	; 240
    65ba:	92 e3       	ldi	r25, 0x32	; 50
    65bc:	0e 94 5f 0b 	call	0x16be	; 0x16be <EXTI_voidSet_INT0_Cbf>
	EXTI_u8SetSource( EXTI_INT_0,EXTI_FALLING_EDGE);
    65c0:	80 e0       	ldi	r24, 0x00	; 0
    65c2:	62 e0       	ldi	r22, 0x02	; 2
    65c4:	0e 94 91 09 	call	0x1322	; 0x1322 <EXTI_u8SetSource>
	EXTI_u8EnablePIE(EXTI_INT_0);
    65c8:	80 e0       	ldi	r24, 0x00	; 0
    65ca:	0e 94 c9 0a 	call	0x1592	; 0x1592 <EXTI_u8EnablePIE>
	EXTI_voidEnableGIE();
    65ce:	0e 94 43 0b 	call	0x1686	; 0x1686 <EXTI_voidEnableGIE>

	//CAN Initialization
	HMCP2515_voidRecievInit();
    65d2:	0e 94 31 11 	call	0x2262	; 0x2262 <HMCP2515_voidRecievInit>
	HMCP2515_voidInitTransimiter();
    65d6:	0e 94 2b 10 	call	0x2056	; 0x2056 <HMCP2515_voidInitTransimiter>

}
    65da:	cf 91       	pop	r28
    65dc:	df 91       	pop	r29
    65de:	08 95       	ret

000065e0 <EXTI_CallBackFUNC>:

void EXTI_CallBackFUNC(void)
{
    65e0:	df 93       	push	r29
    65e2:	cf 93       	push	r28
    65e4:	0f 92       	push	r0
    65e6:	cd b7       	in	r28, 0x3d	; 61
    65e8:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8Data;

	//Receive CAN message
	HMCP2515_voidRecieveMess(RXB0CTRL);
    65ea:	80 e6       	ldi	r24, 0x60	; 96
    65ec:	0e 94 64 11 	call	0x22c8	; 0x22c8 <HMCP2515_voidRecieveMess>

	//Store the data.
	Local_u8Data =  REC_Message[6];
    65f0:	80 91 d0 06 	lds	r24, 0x06D0
    65f4:	89 83       	std	Y+1, r24	; 0x01

	//Push the data into the queue.
	xQueueSendFromISR(xQueue, &Local_u8Data, NULL);
    65f6:	80 91 da 06 	lds	r24, 0x06DA
    65fa:	90 91 db 06 	lds	r25, 0x06DB
    65fe:	9e 01       	movw	r18, r28
    6600:	2f 5f       	subi	r18, 0xFF	; 255
    6602:	3f 4f       	sbci	r19, 0xFF	; 255
    6604:	b9 01       	movw	r22, r18
    6606:	40 e0       	ldi	r20, 0x00	; 0
    6608:	50 e0       	ldi	r21, 0x00	; 0
    660a:	20 e0       	ldi	r18, 0x00	; 0
    660c:	0e 94 2b 21 	call	0x4256	; 0x4256 <xQueueGenericSendFromISR>

}
    6610:	0f 90       	pop	r0
    6612:	cf 91       	pop	r28
    6614:	df 91       	pop	r29
    6616:	08 95       	ret

00006618 <Send_SpeedTask>:

void Send_SpeedTask(void){
    6618:	df 93       	push	r29
    661a:	cf 93       	push	r28
    661c:	0f 92       	push	r0
    661e:	cd b7       	in	r28, 0x3d	; 61
    6620:	de b7       	in	r29, 0x3e	; 62

	u8 Local_u8RX_Data = 0;
    6622:	19 82       	std	Y+1, r1	; 0x01

	while(1){

		//Receive data from the queue.
		if(xQueueReceive(xQueue, &Local_u8RX_Data, portMAX_DELAY)){
    6624:	80 91 da 06 	lds	r24, 0x06DA
    6628:	90 91 db 06 	lds	r25, 0x06DB
    662c:	9e 01       	movw	r18, r28
    662e:	2f 5f       	subi	r18, 0xFF	; 255
    6630:	3f 4f       	sbci	r19, 0xFF	; 255
    6632:	b9 01       	movw	r22, r18
    6634:	4f ef       	ldi	r20, 0xFF	; 255
    6636:	5f ef       	ldi	r21, 0xFF	; 255
    6638:	20 e0       	ldi	r18, 0x00	; 0
    663a:	0e 94 8d 21 	call	0x431a	; 0x431a <xQueueGenericReceive>
    663e:	88 23       	and	r24, r24
    6640:	89 f3       	breq	.-30     	; 0x6624 <Send_SpeedTask+0xc>

			if(Local_u8RX_Data == 'l'){
    6642:	89 81       	ldd	r24, Y+1	; 0x01
    6644:	8c 36       	cpi	r24, 0x6C	; 108
    6646:	49 f4       	brne	.+18     	; 0x665a <Send_SpeedTask+0x42>

				// speed of the motors
				HMCP2515_VidSendCAN_Msg(TXB0CTRL, 0x7E1, 2, Global_Turn_Left_);
    6648:	27 e9       	ldi	r18, 0x97	; 151
    664a:	31 e0       	ldi	r19, 0x01	; 1
    664c:	80 e3       	ldi	r24, 0x30	; 48
    664e:	61 ee       	ldi	r22, 0xE1	; 225
    6650:	77 e0       	ldi	r23, 0x07	; 7
    6652:	42 e0       	ldi	r20, 0x02	; 2
    6654:	0e 94 4a 10 	call	0x2094	; 0x2094 <HMCP2515_VidSendCAN_Msg>
    6658:	0b c0       	rjmp	.+22     	; 0x6670 <Send_SpeedTask+0x58>

			}
			else if(Local_u8RX_Data == 'r'){
    665a:	89 81       	ldd	r24, Y+1	; 0x01
    665c:	82 37       	cpi	r24, 0x72	; 114
    665e:	41 f4       	brne	.+16     	; 0x6670 <Send_SpeedTask+0x58>

				// speed of the motors
				HMCP2515_VidSendCAN_Msg(TXB0CTRL, 0x7E1, 2 , Global_Turn_Right_);
    6660:	29 e9       	ldi	r18, 0x99	; 153
    6662:	31 e0       	ldi	r19, 0x01	; 1
    6664:	80 e3       	ldi	r24, 0x30	; 48
    6666:	61 ee       	ldi	r22, 0xE1	; 225
    6668:	77 e0       	ldi	r23, 0x07	; 7
    666a:	42 e0       	ldi	r20, 0x02	; 2
    666c:	0e 94 4a 10 	call	0x2094	; 0x2094 <HMCP2515_VidSendCAN_Msg>
			}
			else{
				//wrong message
			}

			Local_u8RX_Data = 0;
    6670:	19 82       	std	Y+1, r1	; 0x01
    6672:	d8 cf       	rjmp	.-80     	; 0x6624 <Send_SpeedTask+0xc>

00006674 <__mulsi3>:
    6674:	62 9f       	mul	r22, r18
    6676:	d0 01       	movw	r26, r0
    6678:	73 9f       	mul	r23, r19
    667a:	f0 01       	movw	r30, r0
    667c:	82 9f       	mul	r24, r18
    667e:	e0 0d       	add	r30, r0
    6680:	f1 1d       	adc	r31, r1
    6682:	64 9f       	mul	r22, r20
    6684:	e0 0d       	add	r30, r0
    6686:	f1 1d       	adc	r31, r1
    6688:	92 9f       	mul	r25, r18
    668a:	f0 0d       	add	r31, r0
    668c:	83 9f       	mul	r24, r19
    668e:	f0 0d       	add	r31, r0
    6690:	74 9f       	mul	r23, r20
    6692:	f0 0d       	add	r31, r0
    6694:	65 9f       	mul	r22, r21
    6696:	f0 0d       	add	r31, r0
    6698:	99 27       	eor	r25, r25
    669a:	72 9f       	mul	r23, r18
    669c:	b0 0d       	add	r27, r0
    669e:	e1 1d       	adc	r30, r1
    66a0:	f9 1f       	adc	r31, r25
    66a2:	63 9f       	mul	r22, r19
    66a4:	b0 0d       	add	r27, r0
    66a6:	e1 1d       	adc	r30, r1
    66a8:	f9 1f       	adc	r31, r25
    66aa:	bd 01       	movw	r22, r26
    66ac:	cf 01       	movw	r24, r30
    66ae:	11 24       	eor	r1, r1
    66b0:	08 95       	ret

000066b2 <__divmodsi4>:
    66b2:	97 fb       	bst	r25, 7
    66b4:	09 2e       	mov	r0, r25
    66b6:	05 26       	eor	r0, r21
    66b8:	0e d0       	rcall	.+28     	; 0x66d6 <__divmodsi4_neg1>
    66ba:	57 fd       	sbrc	r21, 7
    66bc:	04 d0       	rcall	.+8      	; 0x66c6 <__divmodsi4_neg2>
    66be:	14 d0       	rcall	.+40     	; 0x66e8 <__udivmodsi4>
    66c0:	0a d0       	rcall	.+20     	; 0x66d6 <__divmodsi4_neg1>
    66c2:	00 1c       	adc	r0, r0
    66c4:	38 f4       	brcc	.+14     	; 0x66d4 <__divmodsi4_exit>

000066c6 <__divmodsi4_neg2>:
    66c6:	50 95       	com	r21
    66c8:	40 95       	com	r20
    66ca:	30 95       	com	r19
    66cc:	21 95       	neg	r18
    66ce:	3f 4f       	sbci	r19, 0xFF	; 255
    66d0:	4f 4f       	sbci	r20, 0xFF	; 255
    66d2:	5f 4f       	sbci	r21, 0xFF	; 255

000066d4 <__divmodsi4_exit>:
    66d4:	08 95       	ret

000066d6 <__divmodsi4_neg1>:
    66d6:	f6 f7       	brtc	.-4      	; 0x66d4 <__divmodsi4_exit>
    66d8:	90 95       	com	r25
    66da:	80 95       	com	r24
    66dc:	70 95       	com	r23
    66de:	61 95       	neg	r22
    66e0:	7f 4f       	sbci	r23, 0xFF	; 255
    66e2:	8f 4f       	sbci	r24, 0xFF	; 255
    66e4:	9f 4f       	sbci	r25, 0xFF	; 255
    66e6:	08 95       	ret

000066e8 <__udivmodsi4>:
    66e8:	a1 e2       	ldi	r26, 0x21	; 33
    66ea:	1a 2e       	mov	r1, r26
    66ec:	aa 1b       	sub	r26, r26
    66ee:	bb 1b       	sub	r27, r27
    66f0:	fd 01       	movw	r30, r26
    66f2:	0d c0       	rjmp	.+26     	; 0x670e <__udivmodsi4_ep>

000066f4 <__udivmodsi4_loop>:
    66f4:	aa 1f       	adc	r26, r26
    66f6:	bb 1f       	adc	r27, r27
    66f8:	ee 1f       	adc	r30, r30
    66fa:	ff 1f       	adc	r31, r31
    66fc:	a2 17       	cp	r26, r18
    66fe:	b3 07       	cpc	r27, r19
    6700:	e4 07       	cpc	r30, r20
    6702:	f5 07       	cpc	r31, r21
    6704:	20 f0       	brcs	.+8      	; 0x670e <__udivmodsi4_ep>
    6706:	a2 1b       	sub	r26, r18
    6708:	b3 0b       	sbc	r27, r19
    670a:	e4 0b       	sbc	r30, r20
    670c:	f5 0b       	sbc	r31, r21

0000670e <__udivmodsi4_ep>:
    670e:	66 1f       	adc	r22, r22
    6710:	77 1f       	adc	r23, r23
    6712:	88 1f       	adc	r24, r24
    6714:	99 1f       	adc	r25, r25
    6716:	1a 94       	dec	r1
    6718:	69 f7       	brne	.-38     	; 0x66f4 <__udivmodsi4_loop>
    671a:	60 95       	com	r22
    671c:	70 95       	com	r23
    671e:	80 95       	com	r24
    6720:	90 95       	com	r25
    6722:	9b 01       	movw	r18, r22
    6724:	ac 01       	movw	r20, r24
    6726:	bd 01       	movw	r22, r26
    6728:	cf 01       	movw	r24, r30
    672a:	08 95       	ret

0000672c <__prologue_saves__>:
    672c:	2f 92       	push	r2
    672e:	3f 92       	push	r3
    6730:	4f 92       	push	r4
    6732:	5f 92       	push	r5
    6734:	6f 92       	push	r6
    6736:	7f 92       	push	r7
    6738:	8f 92       	push	r8
    673a:	9f 92       	push	r9
    673c:	af 92       	push	r10
    673e:	bf 92       	push	r11
    6740:	cf 92       	push	r12
    6742:	df 92       	push	r13
    6744:	ef 92       	push	r14
    6746:	ff 92       	push	r15
    6748:	0f 93       	push	r16
    674a:	1f 93       	push	r17
    674c:	cf 93       	push	r28
    674e:	df 93       	push	r29
    6750:	cd b7       	in	r28, 0x3d	; 61
    6752:	de b7       	in	r29, 0x3e	; 62
    6754:	ca 1b       	sub	r28, r26
    6756:	db 0b       	sbc	r29, r27
    6758:	0f b6       	in	r0, 0x3f	; 63
    675a:	f8 94       	cli
    675c:	de bf       	out	0x3e, r29	; 62
    675e:	0f be       	out	0x3f, r0	; 63
    6760:	cd bf       	out	0x3d, r28	; 61
    6762:	09 94       	ijmp

00006764 <__epilogue_restores__>:
    6764:	2a 88       	ldd	r2, Y+18	; 0x12
    6766:	39 88       	ldd	r3, Y+17	; 0x11
    6768:	48 88       	ldd	r4, Y+16	; 0x10
    676a:	5f 84       	ldd	r5, Y+15	; 0x0f
    676c:	6e 84       	ldd	r6, Y+14	; 0x0e
    676e:	7d 84       	ldd	r7, Y+13	; 0x0d
    6770:	8c 84       	ldd	r8, Y+12	; 0x0c
    6772:	9b 84       	ldd	r9, Y+11	; 0x0b
    6774:	aa 84       	ldd	r10, Y+10	; 0x0a
    6776:	b9 84       	ldd	r11, Y+9	; 0x09
    6778:	c8 84       	ldd	r12, Y+8	; 0x08
    677a:	df 80       	ldd	r13, Y+7	; 0x07
    677c:	ee 80       	ldd	r14, Y+6	; 0x06
    677e:	fd 80       	ldd	r15, Y+5	; 0x05
    6780:	0c 81       	ldd	r16, Y+4	; 0x04
    6782:	1b 81       	ldd	r17, Y+3	; 0x03
    6784:	aa 81       	ldd	r26, Y+2	; 0x02
    6786:	b9 81       	ldd	r27, Y+1	; 0x01
    6788:	ce 0f       	add	r28, r30
    678a:	d1 1d       	adc	r29, r1
    678c:	0f b6       	in	r0, 0x3f	; 63
    678e:	f8 94       	cli
    6790:	de bf       	out	0x3e, r29	; 62
    6792:	0f be       	out	0x3f, r0	; 63
    6794:	cd bf       	out	0x3d, r28	; 61
    6796:	ed 01       	movw	r28, r26
    6798:	08 95       	ret

0000679a <memcpy>:
    679a:	fb 01       	movw	r30, r22
    679c:	dc 01       	movw	r26, r24
    679e:	02 c0       	rjmp	.+4      	; 0x67a4 <memcpy+0xa>
    67a0:	01 90       	ld	r0, Z+
    67a2:	0d 92       	st	X+, r0
    67a4:	41 50       	subi	r20, 0x01	; 1
    67a6:	50 40       	sbci	r21, 0x00	; 0
    67a8:	d8 f7       	brcc	.-10     	; 0x67a0 <memcpy+0x6>
    67aa:	08 95       	ret

000067ac <_exit>:
    67ac:	f8 94       	cli

000067ae <__stop_program>:
    67ae:	ff cf       	rjmp	.-2      	; 0x67ae <__stop_program>
